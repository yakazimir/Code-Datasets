<?xml version="1.0" encoding="UTF-8"?>
<jel>
	<admin creation="Fri Aug 17 15:41:12 CEST 2012" xsdversion="1.0.0" version="1.0.0" />
	<jelclass abstract="true" superclass="LocaleServiceProvider" visibility="public" package="java.text.spi" superclassfulltype="java.util.spi.LocaleServiceProvider" fulltype="java.text.spi.DateFormatSymbolsProvider" type="DateFormatSymbolsProvider">
		<comment>
			<description>An abstract class for service providers that
 provide instances of the
 {@link java.text.DateFormatSymbols DateFormatSymbols} class.</description>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="protected" name="DateFormatSymbolsProvider">
				<comment>
					<description>Sole constructor.  (For invocation by subclass constructors, typically
 implicit.)</description>
				</comment>
			</constructor>
			<method abstract="true" visibility="public" name="getInstance" returncomment="a &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance." fulltype="java.text.DateFormatSymbols" type="DateFormatSymbols">
				<comment>
					<description>Returns a new &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance for the
 specified locale.</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DateFormatSymbols#getInstance(java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="LocaleServiceProvider" visibility="public" package="java.text.spi" superclassfulltype="java.util.spi.LocaleServiceProvider" fulltype="java.text.spi.CollatorProvider" type="CollatorProvider">
		<comment>
			<description>An abstract class for service providers that
 provide concrete implementations of the
 {@link java.text.Collator Collator} class.</description>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="protected" name="CollatorProvider">
				<comment>
					<description>Sole constructor.  (For invocation by subclass constructors, typically
 implicit.)</description>
				</comment>
			</constructor>
			<method abstract="true" visibility="public" name="getInstance" returncomment="the &lt;code&gt;Collator&lt;/code&gt; for the desired locale." fulltype="java.text.Collator" type="Collator">
				<comment>
					<description>Returns a new &lt;code&gt;Collator&lt;/code&gt; instance for the specified locale.</description>
					<attribute name="@param">
						<description>locale the desired locale.</description>
					</attribute>
					<attribute name="@return">
						<description>the &lt;code&gt;Collator&lt;/code&gt; for the desired locale.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if
 &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#getInstance(java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale." fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="LocaleServiceProvider" visibility="public" package="java.text.spi" superclassfulltype="java.util.spi.LocaleServiceProvider" fulltype="java.text.spi.DecimalFormatSymbolsProvider" type="DecimalFormatSymbolsProvider">
		<comment>
			<description>An abstract class for service providers that
 provide instances of the
 {@link java.text.DecimalFormatSymbols DecimalFormatSymbols} class.</description>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="protected" name="DecimalFormatSymbolsProvider">
				<comment>
					<description>Sole constructor.  (For invocation by subclass constructors, typically
 implicit.)</description>
				</comment>
			</constructor>
			<method abstract="true" visibility="public" name="getInstance" returncomment="a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance." fulltype="java.text.DecimalFormatSymbols" type="DecimalFormatSymbols">
				<comment>
					<description>Returns a new &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance for the
 specified locale.</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DecimalFormatSymbols#getInstance(java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="LocaleServiceProvider" visibility="public" package="java.text.spi" superclassfulltype="java.util.spi.LocaleServiceProvider" fulltype="java.text.spi.BreakIteratorProvider" type="BreakIteratorProvider">
		<comment>
			<description>An abstract class for service providers that
 provide concrete implementations of the
 {@link java.text.BreakIterator BreakIterator} class.</description>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="protected" name="BreakIteratorProvider">
				<comment>
					<description>Sole constructor.  (For invocation by subclass constructors, typically
 implicit.)</description>
				</comment>
			</constructor>
			<method abstract="true" visibility="public" name="getWordInstance" returncomment="A break iterator for word breaks" fulltype="java.text.BreakIterator" type="BreakIterator">
				<comment>
					<description>Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
 for &lt;a href=&quot;../BreakIterator.html#word&quot;&gt;word breaks&lt;/a&gt;
 for the given locale.</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@return">
						<description>A break iterator for word breaks</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.BreakIterator#getWordInstance(java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="getLineInstance" returncomment="A break iterator for line breaks" fulltype="java.text.BreakIterator" type="BreakIterator">
				<comment>
					<description>Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
 for &lt;a href=&quot;../BreakIterator.html#line&quot;&gt;line breaks&lt;/a&gt;
 for the given locale.</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@return">
						<description>A break iterator for line breaks</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.BreakIterator#getLineInstance(java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="getCharacterInstance" returncomment="A break iterator for character breaks" fulltype="java.text.BreakIterator" type="BreakIterator">
				<comment>
					<description>Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
 for &lt;a href=&quot;../BreakIterator.html#character&quot;&gt;character breaks&lt;/a&gt;
 for the given locale.</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@return">
						<description>A break iterator for character breaks</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.BreakIterator#getCharacterInstance(java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="getSentenceInstance" returncomment="A break iterator for sentence breaks" fulltype="java.text.BreakIterator" type="BreakIterator">
				<comment>
					<description>Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
 for &lt;a href=&quot;../BreakIterator.html#sentence&quot;&gt;sentence breaks&lt;/a&gt;
 for the given locale.</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@return">
						<description>A break iterator for sentence breaks</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.BreakIterator#getSentenceInstance(java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="LocaleServiceProvider" visibility="public" package="java.text.spi" superclassfulltype="java.util.spi.LocaleServiceProvider" fulltype="java.text.spi.NumberFormatProvider" type="NumberFormatProvider">
		<comment>
			<description>An abstract class for service providers that
 provide concrete implementations of the
 {@link java.text.NumberFormat NumberFormat} class.</description>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="protected" name="NumberFormatProvider">
				<comment>
					<description>Sole constructor.  (For invocation by subclass constructors, typically
 implicit.)</description>
				</comment>
			</constructor>
			<method abstract="true" visibility="public" name="getCurrencyInstance" returncomment="a currency formatter" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a new &lt;code&gt;NumberFormat&lt;/code&gt; instance which formats
 monetary values for the specified locale.</description>
					<attribute name="@param">
						<description>locale the desired locale.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@return">
						<description>a currency formatter</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getCurrencyInstance(java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale." fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="getIntegerInstance" returncomment="a number format for integer values" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a new &lt;code&gt;NumberFormat&lt;/code&gt; instance which formats
 integer values for the specified locale.
 The returned number format is configured to
 round floating point numbers to the nearest integer using
 half-even rounding (see {@link java.math.RoundingMode#HALF_EVEN HALF_EVEN})
 for formatting, and to parse only the integer part of
 an input string (see {@link
 java.text.NumberFormat#isParseIntegerOnly isParseIntegerOnly}).</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@return">
						<description>a number format for integer values</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getIntegerInstance(java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="getNumberInstance" returncomment="a general-purpose number formatter" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a new general-purpose &lt;code&gt;NumberFormat&lt;/code&gt; instance for
 the specified locale.</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@return">
						<description>a general-purpose number formatter</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getNumberInstance(java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="getPercentInstance" returncomment="a percent formatter" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a new &lt;code&gt;NumberFormat&lt;/code&gt; instance which formats
 percentage values for the specified locale.</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@return">
						<description>a percent formatter</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getPercentInstance(java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="LocaleServiceProvider" visibility="public" package="java.text.spi" superclassfulltype="java.util.spi.LocaleServiceProvider" fulltype="java.text.spi.DateFormatProvider" type="DateFormatProvider">
		<comment>
			<description>An abstract class for service providers that
 provide concrete implementations of the
 {@link java.text.DateFormat DateFormat} class.</description>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="protected" name="DateFormatProvider">
				<comment>
					<description>Sole constructor.  (For invocation by subclass constructors, typically
 implicit.)</description>
				</comment>
			</constructor>
			<method abstract="true" visibility="public" name="getTimeInstance" returncomment="a time formatter." fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Returns a new &lt;code&gt;DateFormat&lt;/code&gt; instance which formats time
 with the given formatting style for the specified locale.</description>
					<attribute name="@param">
						<description>style the given formatting style.  Either one of
     {@link java.text.DateFormat#SHORT DateFormat.SHORT},
     {@link java.text.DateFormat#MEDIUM DateFormat.MEDIUM},
     {@link java.text.DateFormat#LONG DateFormat.LONG}, or
     {@link java.text.DateFormat#FULL DateFormat.FULL}.</description>
					</attribute>
					<attribute name="@param">
						<description>locale the desired locale.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;style&lt;/code&gt; is invalid,
     or if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@return">
						<description>a time formatter.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DateFormat#getTimeInstance(int, java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="style" comment="the given formatting style.  Either one of
     {@link java.text.DateFormat#SHORT DateFormat.SHORT},
     {@link java.text.DateFormat#MEDIUM DateFormat.MEDIUM},
     {@link java.text.DateFormat#LONG DateFormat.LONG}, or
     {@link java.text.DateFormat#FULL DateFormat.FULL}." fulltype="int" type="int" />
					<param name="locale" comment="the desired locale." fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="getDateInstance" returncomment="a date formatter." fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Returns a new &lt;code&gt;DateFormat&lt;/code&gt; instance which formats date
 with the given formatting style for the specified locale.</description>
					<attribute name="@param">
						<description>style the given formatting style.  Either one of
     {@link java.text.DateFormat#SHORT DateFormat.SHORT},
     {@link java.text.DateFormat#MEDIUM DateFormat.MEDIUM},
     {@link java.text.DateFormat#LONG DateFormat.LONG}, or
     {@link java.text.DateFormat#FULL DateFormat.FULL}.</description>
					</attribute>
					<attribute name="@param">
						<description>locale the desired locale.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;style&lt;/code&gt; is invalid,
     or if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@return">
						<description>a date formatter.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DateFormat#getDateInstance(int, java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="style" comment="the given formatting style.  Either one of
     {@link java.text.DateFormat#SHORT DateFormat.SHORT},
     {@link java.text.DateFormat#MEDIUM DateFormat.MEDIUM},
     {@link java.text.DateFormat#LONG DateFormat.LONG}, or
     {@link java.text.DateFormat#FULL DateFormat.FULL}." fulltype="int" type="int" />
					<param name="locale" comment="the desired locale." fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="getDateTimeInstance" returncomment="a date/time formatter." fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Returns a new &lt;code&gt;DateFormat&lt;/code&gt; instance which formats date and time
 with the given formatting style for the specified locale.</description>
					<attribute name="@param">
						<description>dateStyle the given date formatting style.  Either one of
     {@link java.text.DateFormat#SHORT DateFormat.SHORT},
     {@link java.text.DateFormat#MEDIUM DateFormat.MEDIUM},
     {@link java.text.DateFormat#LONG DateFormat.LONG}, or
     {@link java.text.DateFormat#FULL DateFormat.FULL}.</description>
					</attribute>
					<attribute name="@param">
						<description>timeStyle the given time formatting style.  Either one of
     {@link java.text.DateFormat#SHORT DateFormat.SHORT},
     {@link java.text.DateFormat#MEDIUM DateFormat.MEDIUM},
     {@link java.text.DateFormat#LONG DateFormat.LONG}, or
     {@link java.text.DateFormat#FULL DateFormat.FULL}.</description>
					</attribute>
					<attribute name="@param">
						<description>locale the desired locale.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;dateStyle&lt;/code&gt; or
     &lt;code&gt;timeStyle&lt;/code&gt; is invalid,
     or if &lt;code&gt;locale&lt;/code&gt; isn&apos;t
     one of the locales returned from
     {@link java.util.spi.LocaleServiceProvider#getAvailableLocales()
     getAvailableLocales()}.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@return">
						<description>a date/time formatter.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DateFormat#getDateTimeInstance(int, int, java.util.Locale)</description>
					</attribute>
				</comment>
				<params>
					<param name="dateStyle" comment="the given date formatting style.  Either one of
     {@link java.text.DateFormat#SHORT DateFormat.SHORT},
     {@link java.text.DateFormat#MEDIUM DateFormat.MEDIUM},
     {@link java.text.DateFormat#LONG DateFormat.LONG}, or
     {@link java.text.DateFormat#FULL DateFormat.FULL}." fulltype="int" type="int" />
					<param name="timeStyle" comment="the given time formatting style.  Either one of
     {@link java.text.DateFormat#SHORT DateFormat.SHORT},
     {@link java.text.DateFormat#MEDIUM DateFormat.MEDIUM},
     {@link java.text.DateFormat#LONG DateFormat.LONG}, or
     {@link java.text.DateFormat#FULL DateFormat.FULL}." fulltype="int" type="int" />
					<param name="locale" comment="the desired locale." fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.RBCollationTables" type="RBCollationTables">
		<comment>
			<description>This class contains the static state of a RuleBasedCollator: The various
 tables that are used by the collation routines.  Several RuleBasedCollators
 can share a single RBCollationTables object, easing memory requirements and
 improving performance.</description>
		</comment>
		<fields>
			<field final="true" static="true" const="2113929216" visibility="package-private" name="EXPANDCHARINDEX" constexpr="2113929216" fulltype="int" type="int" />
			<field final="true" static="true" const="2130706432" visibility="package-private" name="CONTRACTCHARINDEX" constexpr="2130706432" fulltype="int" type="int" />
			<field final="true" static="true" const="-1" visibility="package-private" name="UNMAPPED" constexpr="-1" fulltype="int" type="int" />
			<field final="true" static="true" const="-65536" visibility="package-private" name="PRIMARYORDERMASK" constexpr="-65536" fulltype="int" type="int" />
			<field final="true" static="true" const="65280" visibility="package-private" name="SECONDARYORDERMASK" constexpr="65280" fulltype="int" type="int" />
			<field final="true" static="true" const="255" visibility="package-private" name="TERTIARYORDERMASK" constexpr="255" fulltype="int" type="int" />
			<field final="true" static="true" const="-65536" visibility="package-private" name="PRIMARYDIFFERENCEONLY" constexpr="-65536" fulltype="int" type="int" />
			<field final="true" static="true" const="-256" visibility="package-private" name="SECONDARYDIFFERENCEONLY" constexpr="-256" fulltype="int" type="int" />
			<field final="true" static="true" const="16" visibility="package-private" name="PRIMARYORDERSHIFT" constexpr="16" fulltype="int" type="int" />
			<field final="true" static="true" const="8" visibility="package-private" name="SECONDARYORDERSHIFT" constexpr="8" fulltype="int" type="int" />
			<field visibility="private" name="rules" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="frenchSec" fulltype="boolean" type="boolean" />
			<field visibility="private" name="seAsianSwapping" fulltype="boolean" type="boolean" />
			<field visibility="private" name="mapping" fulltype="sun.text.UCompactIntArray" type="UCompactIntArray" />
			<field visibility="private" name="contractTable" fulltype="java.util.Vector" type="Vector" />
			<field visibility="private" name="expandTable" fulltype="java.util.Vector" type="Vector" />
			<field visibility="private" name="contractFlags" fulltype="sun.text.IntHashtable" type="IntHashtable" />
			<field visibility="private" name="maxSecOrder" fulltype="short" type="short" />
			<field visibility="private" name="maxTerOrder" fulltype="short" type="short" />
		</fields>
		<methods>
			<constructor visibility="public" name="RBCollationTables">
				<params>
					<param name="rules" fulltype="java.lang.String" type="String" />
					<param name="decmp" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</constructor>
			<method visibility="public" name="getRules" returncomment="returns the collation rules that the table collation object
 was created from." fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the table-based rules for the collation object.</description>
					<attribute name="@return">
						<description>returns the collation rules that the table collation object
 was created from.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isFrenchSec" fulltype="boolean" type="boolean" />
			<method visibility="public" name="isSEAsianSwapping" fulltype="boolean" type="boolean" />
			<method visibility="package-private" name="getContractValues" fulltype="java.util.Vector" type="Vector">
				<comment>
					<description>Get the entry of hash table of the contracting string in the collation
  table.</description>
					<attribute name="@param">
						<description>ch the starting character of the contracting string</description>
					</attribute>
				</comment>
				<params>
					<param name="ch" comment="the starting character of the contracting string" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="getContractValuesImpl" fulltype="java.util.Vector" type="Vector">
				<params>
					<param name="index" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="package-private" name="usedInContractSeq" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if this character appears anywhere in a contracting
 character sequence.  (Used by CollationElementIterator.setOffset().)</description>
				</comment>
				<params>
					<param name="c" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="package-private" name="getMaxExpansion" returncomment="the maximum length of any expansion seuences ending
         with the specified order." fulltype="int" type="int">
				<comment>
					<description>Return the maximum length of any expansion sequences that end
 with the specified comparison order.</description>
					<attribute name="@param">
						<description>order a collation order returned by previous or next.</description>
					</attribute>
					<attribute name="@return">
						<description>the maximum length of any expansion seuences ending
         with the specified order.</description>
					</attribute>
					<attribute name="@see">
						<description>CollationElementIterator#getMaxExpansion</description>
					</attribute>
				</comment>
				<params>
					<param name="order" comment="a collation order returned by previous or next." fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="package-private" name="getExpandValueList" fulltype="int[]" type="int">
				<comment>
					<description>Get the entry of hash table of the expanding string in the collation
  table.</description>
					<attribute name="@param">
						<description>idx the index of the expanding string value list</description>
					</attribute>
				</comment>
				<params>
					<param name="order" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="package-private" name="getUnicodeOrder" returncomment="the comparison order of a character." fulltype="int" type="int">
				<comment>
					<description>Get the comarison order of a character from the collation table.</description>
					<attribute name="@return">
						<description>the comparison order of a character.</description>
					</attribute>
				</comment>
				<params>
					<param name="ch" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="package-private" name="getMaxSecOrder" fulltype="short" type="short" />
			<method visibility="package-private" name="getMaxTerOrder" fulltype="short" type="short" />
			<method static="true" visibility="package-private" name="reverse" fulltype="void" type="void">
				<comment>
					<description>Reverse a string.</description>
				</comment>
				<params>
					<param name="result" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="from" fulltype="int" type="int" />
					<param name="to" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" static="true" visibility="package-private" name="getEntry" fulltype="int" type="int">
				<params>
					<param name="list" fulltype="java.util.Vector" type="Vector" />
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="fwd" fulltype="boolean" type="boolean" />
				</params>
			</method>
		</methods>
		<jelclass final="true" superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.RBCollationTables.BuildAPI" type="RBCollationTables.BuildAPI">
			<methods>
				<constructor visibility="private" name="RBCollationTables.BuildAPI">
					<comment>
						<description>Private constructor.  Prevents anyone else besides RBTableBuilder
 from gaining direct access to the internals of this class.</description>
					</comment>
				</constructor>
				<method visibility="package-private" name="fillInTables" fulltype="void" type="void">
					<comment>
						<description>This function is used by RBTableBuilder to fill in all the members of this
 object.  (Effectively, the builder class functions as a &quot;friend&quot; of this
 class, but to avoid changing too much of the logic, it carries around &quot;shadow&quot;
 copies of all these variables until the end of the build process and then
 copies them en masse into the actual tables object once all the construction
 logic is complete.  This function does that &quot;copying en masse&quot;.</description>
						<attribute name="@param">
							<description>f2ary The value for frenchSec (the French-secondary flag)</description>
						</attribute>
						<attribute name="@param">
							<description>swap The value for SE Asian swapping rule</description>
						</attribute>
						<attribute name="@param">
							<description>map The collator&apos;s character-mapping table (the value for mapping)</description>
						</attribute>
						<attribute name="@param">
							<description>cTbl The collator&apos;s contracting-character table (the value for contractTable)</description>
						</attribute>
						<attribute name="@param">
							<description>eTbl The collator&apos;s expanding-character table (the value for expandTable)</description>
						</attribute>
						<attribute name="@param">
							<description>cFlgs The hash table of characters that participate in contracting-
              character sequences (the value for contractFlags)</description>
						</attribute>
						<attribute name="@param">
							<description>mso The value for maxSecOrder</description>
						</attribute>
						<attribute name="@param">
							<description>mto The value for maxTerOrder</description>
						</attribute>
					</comment>
					<params>
						<param name="f2ary" comment="The value for frenchSec (the French-secondary flag)" fulltype="boolean" type="boolean" />
						<param name="swap" comment="The value for SE Asian swapping rule" fulltype="boolean" type="boolean" />
						<param name="map" comment="The collator&apos;s character-mapping table (the value for mapping)" fulltype="sun.text.UCompactIntArray" type="UCompactIntArray" />
						<param name="cTbl" comment="The collator&apos;s contracting-character table (the value for contractTable)" fulltype="java.util.Vector" type="Vector" />
						<param name="eTbl" comment="The collator&apos;s expanding-character table (the value for expandTable)" fulltype="java.util.Vector" type="Vector" />
						<param name="cFlgs" comment="The hash table of characters that participate in contracting-
              character sequences (the value for contractFlags)" fulltype="sun.text.IntHashtable" type="IntHashtable" />
						<param name="mso" comment="The value for maxSecOrder" fulltype="short" type="short" />
						<param name="mto" comment="The value for maxTerOrder" fulltype="short" type="short" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.RBCollationTables.BuildAPI" type="RBCollationTables.BuildAPI">
		<methods>
			<constructor visibility="private" name="RBCollationTables.BuildAPI">
				<comment>
					<description>Private constructor.  Prevents anyone else besides RBTableBuilder
 from gaining direct access to the internals of this class.</description>
				</comment>
			</constructor>
			<method visibility="package-private" name="fillInTables" fulltype="void" type="void">
				<comment>
					<description>This function is used by RBTableBuilder to fill in all the members of this
 object.  (Effectively, the builder class functions as a &quot;friend&quot; of this
 class, but to avoid changing too much of the logic, it carries around &quot;shadow&quot;
 copies of all these variables until the end of the build process and then
 copies them en masse into the actual tables object once all the construction
 logic is complete.  This function does that &quot;copying en masse&quot;.</description>
					<attribute name="@param">
						<description>f2ary The value for frenchSec (the French-secondary flag)</description>
					</attribute>
					<attribute name="@param">
						<description>swap The value for SE Asian swapping rule</description>
					</attribute>
					<attribute name="@param">
						<description>map The collator&apos;s character-mapping table (the value for mapping)</description>
					</attribute>
					<attribute name="@param">
						<description>cTbl The collator&apos;s contracting-character table (the value for contractTable)</description>
					</attribute>
					<attribute name="@param">
						<description>eTbl The collator&apos;s expanding-character table (the value for expandTable)</description>
					</attribute>
					<attribute name="@param">
						<description>cFlgs The hash table of characters that participate in contracting-
              character sequences (the value for contractFlags)</description>
					</attribute>
					<attribute name="@param">
						<description>mso The value for maxSecOrder</description>
					</attribute>
					<attribute name="@param">
						<description>mto The value for maxTerOrder</description>
					</attribute>
				</comment>
				<params>
					<param name="f2ary" comment="The value for frenchSec (the French-secondary flag)" fulltype="boolean" type="boolean" />
					<param name="swap" comment="The value for SE Asian swapping rule" fulltype="boolean" type="boolean" />
					<param name="map" comment="The collator&apos;s character-mapping table (the value for mapping)" fulltype="sun.text.UCompactIntArray" type="UCompactIntArray" />
					<param name="cTbl" comment="The collator&apos;s contracting-character table (the value for contractTable)" fulltype="java.util.Vector" type="Vector" />
					<param name="eTbl" comment="The collator&apos;s expanding-character table (the value for expandTable)" fulltype="java.util.Vector" type="Vector" />
					<param name="cFlgs" comment="The hash table of characters that participate in contracting-
              character sequences (the value for contractFlags)" fulltype="sun.text.IntHashtable" type="IntHashtable" />
					<param name="mso" comment="The value for maxSecOrder" fulltype="short" type="short" />
					<param name="mto" comment="The value for maxTerOrder" fulltype="short" type="short" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.CharacterIteratorFieldDelegate" type="CharacterIteratorFieldDelegate">
		<implements>
			<interface fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
		</implements>
		<comment>
			<description>CharacterIteratorFieldDelegate combines the notifications from a Format
 into a resulting &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;. The resulting
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; can be retrieved by way of
 the &lt;code&gt;getIterator&lt;/code&gt; method.</description>
		</comment>
		<fields>
			<field visibility="private" name="attributedStrings" fulltype="java.util.ArrayList" type="ArrayList">
				<comment>
					<description>Array of AttributeStrings. Whenever &lt;code&gt;formatted&lt;/code&gt; is invoked
 for a region &gt; size, a new instance of AttributedString is added to
 attributedStrings. Subsequent invocations of &lt;code&gt;formatted&lt;/code&gt;
 for existing regions result in invoking addAttribute on the existing
 AttributedStrings.</description>
				</comment>
			</field>
			<field visibility="private" name="size" fulltype="int" type="int">
				<comment>
					<description>Running count of the number of characters that have
 been encountered.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="CharacterIteratorFieldDelegate" />
			<method visibility="public" name="formatted" fulltype="void" type="void">
				<params>
					<param name="attr" fulltype="java.text.Format.Field" type="Format.Field" />
					<param name="value" fulltype="java.lang.Object" type="Object" />
					<param name="start" fulltype="int" type="int" />
					<param name="end" fulltype="int" type="int" />
					<param name="buffer" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
			<method visibility="public" name="formatted" fulltype="void" type="void">
				<params>
					<param name="fieldID" fulltype="int" type="int" />
					<param name="attr" fulltype="java.text.Format.Field" type="Format.Field" />
					<param name="value" fulltype="java.lang.Object" type="Object" />
					<param name="start" fulltype="int" type="int" />
					<param name="end" fulltype="int" type="int" />
					<param name="buffer" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
			<method visibility="public" name="getIterator" fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
				<comment>
					<description>Returns an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; that can be used
 to iterate over the resulting formatted String.</description>
					<attribute name="@pararm">
						<description>string Result of formatting.</description>
					</attribute>
				</comment>
				<params>
					<param name="string" fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.AttributedString" type="AttributedString">
		<comment>
			<description>An AttributedString holds text and related attribute information. It
 may be used as the actual data storage in some cases where a text
 reader wants to access attributed text through the AttributedCharacterIterator
 interface.

 &lt;p&gt;
 An attribute is a key/value pair, identified by the key.  No two
 attributes on a given character can have the same key.

 &lt;p&gt;The values for an attribute are immutable, or must not be mutated
 by clients or storage.  They are always passed by reference, and not
 cloned.</description>
			<attribute name="@see">
				<description>AttributedCharacterIterator</description>
			</attribute>
			<attribute name="@see">
				<description>Annotation</description>
			</attribute>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="10" visibility="private" name="ARRAY_SIZE_INCREMENT" constexpr="10" fulltype="int" type="int" />
			<field visibility="package-private" name="text" fulltype="java.lang.String" type="String" />
			<field visibility="package-private" name="runArraySize" fulltype="int" type="int" />
			<field visibility="package-private" name="runCount" fulltype="int" type="int" />
			<field visibility="package-private" name="runStarts" fulltype="int[]" type="int" />
			<field visibility="package-private" name="runAttributes" fulltype="java.util.Vector[]" type="Vector" />
			<field visibility="package-private" name="runAttributeValues" fulltype="java.util.Vector[]" type="Vector" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="AttributedString">
				<comment>
					<description>Constructs an AttributedString instance with the given
 AttributedCharacterIterators.</description>
					<attribute name="@param">
						<description>iterators AttributedCharacterIterators to construct
 AttributedString from.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if iterators is null</description>
					</attribute>
				</comment>
				<params>
					<param name="iterators" comment="AttributedCharacterIterators to construct
 AttributedString from." fulltype="java.text.AttributedCharacterIterator[]" type="AttributedCharacterIterator" />
				</params>
			</constructor>
			<constructor visibility="public" name="AttributedString">
				<comment>
					<description>Constructs an AttributedString instance with the given text.</description>
					<attribute name="@param">
						<description>text The text for this attributed string.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;text&lt;/code&gt; is null.</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="The text for this attributed string." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="AttributedString">
				<comment>
					<description>Constructs an AttributedString instance with the given text and attributes.</description>
					<attribute name="@param">
						<description>text The text for this attributed string.</description>
					</attribute>
					<attribute name="@param">
						<description>attributes The attributes that apply to the entire string.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;text&lt;/code&gt; or
            &lt;code&gt;attributes&lt;/code&gt; is null.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the text has length 0
 and the attributes parameter is not an empty Map (attributes
 cannot be applied to a 0-length range).</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="The text for this attributed string." fulltype="java.lang.String" type="String" />
					<param name="attributes" comment="The attributes that apply to the entire string." fulltype="java.util.Map" type="Map" />
				</params>
			</constructor>
			<constructor visibility="public" name="AttributedString">
				<comment>
					<description>Constructs an AttributedString instance with the given attributed
 text represented by AttributedCharacterIterator.</description>
					<attribute name="@param">
						<description>text The text for this attributed string.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;text&lt;/code&gt; is null.</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="The text for this attributed string." fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator" />
				</params>
			</constructor>
			<constructor visibility="public" name="AttributedString">
				<comment>
					<description>Constructs an AttributedString instance with the subrange of
 the given attributed text represented by
 AttributedCharacterIterator. If the given range produces an
 empty text, all attributes will be discarded.  Note that any
 attributes wrapped by an Annotation object are discarded for a
 subrange of the original attribute range.</description>
					<attribute name="@param">
						<description>text The text for this attributed string.</description>
					</attribute>
					<attribute name="@param">
						<description>beginIndex Index of the first character of the range.</description>
					</attribute>
					<attribute name="@param">
						<description>endIndex Index of the character following the last character
 of the range.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;text&lt;/code&gt; is null.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the subrange given by
 beginIndex and endIndex is out of the text range.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Annotation</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="The text for this attributed string." fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator" />
					<param name="beginIndex" comment="Index of the first character of the range." fulltype="int" type="int" />
					<param name="endIndex" comment="Index of the character following the last character
 of the range." fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="AttributedString">
				<comment>
					<description>Constructs an AttributedString instance with the subrange of
 the given attributed text represented by
 AttributedCharacterIterator.  Only attributes that match the
 given attributes will be incorporated into the instance. If the
 given range produces an empty text, all attributes will be
 discarded. Note that any attributes wrapped by an Annotation
 object are discarded for a subrange of the original attribute
 range.</description>
					<attribute name="@param">
						<description>text The text for this attributed string.</description>
					</attribute>
					<attribute name="@param">
						<description>beginIndex Index of the first character of the range.</description>
					</attribute>
					<attribute name="@param">
						<description>endIndex Index of the character following the last character
 of the range.</description>
					</attribute>
					<attribute name="@param">
						<description>attributes Specifies attributes to be extracted
 from the text. If null is specified, all available attributes will
 be used.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;text&lt;/code&gt; or
            &lt;code&gt;attributes&lt;/code&gt; is null.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the subrange given by
 beginIndex and endIndex is out of the text range.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Annotation</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="The text for this attributed string." fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator" />
					<param name="beginIndex" comment="Index of the first character of the range." fulltype="int" type="int" />
					<param name="endIndex" comment="Index of the character following the last character
 of the range." fulltype="int" type="int" />
					<param name="attributes" comment="Specifies attributes to be extracted
 from the text. If null is specified, all available attributes will
 be used." fulltype="java.text.AttributedCharacterIterator.Attribute[]" type="AttributedCharacterIterator.Attribute" />
				</params>
			</constructor>
			<method visibility="public" name="addAttribute" fulltype="void" type="void">
				<comment>
					<description>Adds an attribute to the entire string.</description>
					<attribute name="@param">
						<description>attribute the attribute key</description>
					</attribute>
					<attribute name="@param">
						<description>value the value of the attribute; may be null</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;attribute&lt;/code&gt; is null.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the AttributedString has length 0
 (attributes cannot be applied to a 0-length range).</description>
					</attribute>
				</comment>
				<params>
					<param name="attribute" comment="the attribute key" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
					<param name="value" comment="the value of the attribute; may be null" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="addAttribute" fulltype="void" type="void">
				<comment>
					<description>Adds an attribute to a subrange of the string.</description>
					<attribute name="@param">
						<description>attribute the attribute key</description>
					</attribute>
					<attribute name="@param">
						<description>value The value of the attribute. May be null.</description>
					</attribute>
					<attribute name="@param">
						<description>beginIndex Index of the first character of the range.</description>
					</attribute>
					<attribute name="@param">
						<description>endIndex Index of the character following the last character of the range.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;attribute&lt;/code&gt; is null.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if beginIndex is less then 0, endIndex is
 greater than the length of the string, or beginIndex and endIndex together don&apos;t
 define a non-empty subrange of the string.</description>
					</attribute>
				</comment>
				<params>
					<param name="attribute" comment="the attribute key" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
					<param name="value" comment="The value of the attribute. May be null." fulltype="java.lang.Object" type="Object" />
					<param name="beginIndex" comment="Index of the first character of the range." fulltype="int" type="int" />
					<param name="endIndex" comment="Index of the character following the last character of the range." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="addAttributes" fulltype="void" type="void">
				<comment>
					<description>Adds a set of attributes to a subrange of the string.</description>
					<attribute name="@param">
						<description>attributes The attributes to be added to the string.</description>
					</attribute>
					<attribute name="@param">
						<description>beginIndex Index of the first character of the range.</description>
					</attribute>
					<attribute name="@param">
						<description>endIndex Index of the character following the last
 character of the range.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;attributes&lt;/code&gt; is null.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if beginIndex is less then
 0, endIndex is greater than the length of the string, or
 beginIndex and endIndex together don&apos;t define a non-empty
 subrange of the string and the attributes parameter is not an
 empty Map.</description>
					</attribute>
				</comment>
				<params>
					<param name="attributes" comment="The attributes to be added to the string." fulltype="java.util.Map" type="Map" />
					<param name="beginIndex" comment="Index of the first character of the range." fulltype="int" type="int" />
					<param name="endIndex" comment="Index of the character following the last
 character of the range." fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="private" name="addAttributeImpl" fulltype="void" type="void">
				<params>
					<param name="attribute" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
					<param name="value" fulltype="java.lang.Object" type="Object" />
					<param name="beginIndex" fulltype="int" type="int" />
					<param name="endIndex" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="private" name="createRunAttributeDataVectors" fulltype="void" type="void" />
			<method final="true" visibility="private" name="ensureRunBreak" fulltype="int" type="int">
				<params>
					<param name="offset" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="private" name="ensureRunBreak" fulltype="int" type="int">
				<comment>
					<description>Ensures there is a run break at offset, returning the index of
 the run. If this results in splitting a run, two things can happen:
 &lt;ul&gt;
 &lt;li&gt;If copyAttrs is true, the attributes from the existing run
     will be placed in both of the newly created runs.
 &lt;li&gt;If copyAttrs is false, the attributes from the existing run
 will NOT be copied to the run to the right (&gt;= offset) of the break,
 but will exist on the run to the left (&lt; offset).
 &lt;/ul&gt;</description>
				</comment>
				<params>
					<param name="offset" fulltype="int" type="int" />
					<param name="copyAttrs" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="private" name="addAttributeRunData" fulltype="void" type="void">
				<params>
					<param name="attribute" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
					<param name="value" fulltype="java.lang.Object" type="Object" />
					<param name="beginRunIndex" fulltype="int" type="int" />
					<param name="endRunIndex" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getIterator" returncomment="An iterator providing access to the text and its attributes." fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
				<comment>
					<description>Creates an AttributedCharacterIterator instance that provides access to the entire contents of
 this string.</description>
					<attribute name="@return">
						<description>An iterator providing access to the text and its attributes.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getIterator" returncomment="an iterator providing access to the entire text and its selected attributes" fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
				<comment>
					<description>Creates an AttributedCharacterIterator instance that provides access to
 selected contents of this string.
 Information about attributes not listed in attributes that the
 implementor may have need not be made accessible through the iterator.
 If the list is null, all available attribute information should be made
 accessible.</description>
					<attribute name="@param">
						<description>attributes a list of attributes that the client is interested in</description>
					</attribute>
					<attribute name="@return">
						<description>an iterator providing access to the entire text and its selected attributes</description>
					</attribute>
				</comment>
				<params>
					<param name="attributes" comment="a list of attributes that the client is interested in" fulltype="java.text.AttributedCharacterIterator.Attribute[]" type="AttributedCharacterIterator.Attribute" />
				</params>
			</method>
			<method visibility="public" name="getIterator" returncomment="an iterator providing access to the text and its attributes" fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
				<comment>
					<description>Creates an AttributedCharacterIterator instance that provides access to
 selected contents of this string.
 Information about attributes not listed in attributes that the
 implementor may have need not be made accessible through the iterator.
 If the list is null, all available attribute information should be made
 accessible.</description>
					<attribute name="@param">
						<description>attributes a list of attributes that the client is interested in</description>
					</attribute>
					<attribute name="@param">
						<description>beginIndex the index of the first character</description>
					</attribute>
					<attribute name="@param">
						<description>endIndex the index of the character following the last character</description>
					</attribute>
					<attribute name="@return">
						<description>an iterator providing access to the text and its attributes</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if beginIndex is less then 0,
 endIndex is greater than the length of the string, or beginIndex is
 greater than endIndex.</description>
					</attribute>
				</comment>
				<params>
					<param name="attributes" comment="a list of attributes that the client is interested in" fulltype="java.text.AttributedCharacterIterator.Attribute[]" type="AttributedCharacterIterator.Attribute" />
					<param name="beginIndex" comment="the index of the first character" fulltype="int" type="int" />
					<param name="endIndex" comment="the index of the character following the last character" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="package-private" name="length" fulltype="int" type="int" />
			<method visibility="private" name="charAt" fulltype="char" type="char">
				<params>
					<param name="index" fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="private" name="getAttribute" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="attribute" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
					<param name="runIndex" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="getAttributeCheckRange" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="attribute" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
					<param name="runIndex" fulltype="int" type="int" />
					<param name="beginIndex" fulltype="int" type="int" />
					<param name="endIndex" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="attributeValuesMatch" fulltype="boolean" type="boolean">
				<params>
					<param name="attributes" fulltype="java.util.Set" type="Set" />
					<param name="runIndex1" fulltype="int" type="int" />
					<param name="runIndex2" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" static="true" visibility="private" name="valuesMatch" fulltype="boolean" type="boolean">
				<params>
					<param name="value1" fulltype="java.lang.Object" type="Object" />
					<param name="value2" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method final="true" visibility="private" name="appendContents" fulltype="void" type="void">
				<comment>
					<description>Appends the contents of the CharacterIterator iterator into the
 StringBuffer buf.</description>
				</comment>
				<params>
					<param name="buf" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="iterator" fulltype="java.text.CharacterIterator" type="CharacterIterator" />
				</params>
			</method>
			<method visibility="private" name="setAttributes" fulltype="void" type="void">
				<comment>
					<description>Sets the attributes for the range from offset to the next run break
 (typically the end of the text) to the ones specified in attrs.
 This is only meant to be called from the constructor!</description>
				</comment>
				<params>
					<param name="attrs" fulltype="java.util.Map" type="Map" />
					<param name="offset" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="mapsDiffer" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if the attributes specified in last and attrs differ.</description>
				</comment>
				<params>
					<param name="last" fulltype="java.util.Map" type="Map" />
					<param name="attrs" fulltype="java.util.Map" type="Map" />
				</params>
			</method>
		</methods>
		<jelclass final="true" superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.AttributedString.AttributedStringIterator" type="AttributedString.AttributedStringIterator">
			<implements>
				<interface fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator" />
			</implements>
			<fields>
				<field visibility="private" name="beginIndex" fulltype="int" type="int" />
				<field visibility="private" name="endIndex" fulltype="int" type="int" />
				<field visibility="private" name="relevantAttributes" fulltype="java.text.AttributedCharacterIterator.Attribute[]" type="AttributedCharacterIterator.Attribute" />
				<field visibility="private" name="currentIndex" fulltype="int" type="int" />
				<field visibility="private" name="currentRunIndex" fulltype="int" type="int" />
				<field visibility="private" name="currentRunStart" fulltype="int" type="int" />
				<field visibility="private" name="currentRunLimit" fulltype="int" type="int" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="AttributedString.AttributedStringIterator">
					<params>
						<param name="attributes" fulltype="java.text.AttributedCharacterIterator.Attribute[]" type="AttributedCharacterIterator.Attribute" />
						<param name="beginIndex" fulltype="int" type="int" />
						<param name="endIndex" fulltype="int" type="int" />
					</params>
				</constructor>
				<method visibility="public" name="equals" fulltype="boolean" type="boolean">
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
				<method visibility="public" name="hashCode" fulltype="int" type="int" />
				<method visibility="public" name="clone" fulltype="java.lang.Object" type="Object" />
				<method visibility="public" name="first" fulltype="char" type="char" />
				<method visibility="public" name="last" fulltype="char" type="char" />
				<method visibility="public" name="current" fulltype="char" type="char" />
				<method visibility="public" name="next" fulltype="char" type="char" />
				<method visibility="public" name="previous" fulltype="char" type="char" />
				<method visibility="public" name="setIndex" fulltype="char" type="char">
					<params>
						<param name="position" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="public" name="getBeginIndex" fulltype="int" type="int" />
				<method visibility="public" name="getEndIndex" fulltype="int" type="int" />
				<method visibility="public" name="getIndex" fulltype="int" type="int" />
				<method visibility="public" name="getRunStart" fulltype="int" type="int" />
				<method visibility="public" name="getRunStart" fulltype="int" type="int">
					<params>
						<param name="attribute" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
					</params>
				</method>
				<method visibility="public" name="getRunStart" fulltype="int" type="int">
					<params>
						<param name="attributes" fulltype="java.util.Set" type="Set" />
					</params>
				</method>
				<method visibility="public" name="getRunLimit" fulltype="int" type="int" />
				<method visibility="public" name="getRunLimit" fulltype="int" type="int">
					<params>
						<param name="attribute" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
					</params>
				</method>
				<method visibility="public" name="getRunLimit" fulltype="int" type="int">
					<params>
						<param name="attributes" fulltype="java.util.Set" type="Set" />
					</params>
				</method>
				<method visibility="public" name="getAttributes" fulltype="java.util.Map" type="Map" />
				<method visibility="public" name="getAllAttributeKeys" fulltype="java.util.Set" type="Set" />
				<method visibility="public" name="getAttribute" fulltype="java.lang.Object" type="Object">
					<params>
						<param name="attribute" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
					</params>
				</method>
				<method visibility="private" name="getString" fulltype="java.text.AttributedString" type="AttributedString" />
				<method visibility="private" name="internalSetIndex" fulltype="char" type="char">
					<params>
						<param name="position" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="private" name="updateRunInfo" fulltype="void" type="void" />
			</methods>
		</jelclass>
		<jelclass final="true" superclass="AbstractMap" visibility="private" package="java.text" superclassfulltype="java.util.AbstractMap" fulltype="java.text.AttributedString.AttributeMap" type="AttributedString.AttributeMap">
			<fields>
				<field visibility="package-private" name="runIndex" fulltype="int" type="int" />
				<field visibility="package-private" name="beginIndex" fulltype="int" type="int" />
				<field visibility="package-private" name="endIndex" fulltype="int" type="int" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="AttributedString.AttributeMap">
					<params>
						<param name="runIndex" fulltype="int" type="int" />
						<param name="beginIndex" fulltype="int" type="int" />
						<param name="endIndex" fulltype="int" type="int" />
					</params>
				</constructor>
				<method visibility="public" name="entrySet" fulltype="java.util.Set" type="Set" />
				<method visibility="public" name="get" fulltype="java.lang.Object" type="Object">
					<params>
						<param name="key" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.AttributedString.AttributedStringIterator" type="AttributedString.AttributedStringIterator">
		<implements>
			<interface fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator" />
		</implements>
		<fields>
			<field visibility="private" name="beginIndex" fulltype="int" type="int" />
			<field visibility="private" name="endIndex" fulltype="int" type="int" />
			<field visibility="private" name="relevantAttributes" fulltype="java.text.AttributedCharacterIterator.Attribute[]" type="AttributedCharacterIterator.Attribute" />
			<field visibility="private" name="currentIndex" fulltype="int" type="int" />
			<field visibility="private" name="currentRunIndex" fulltype="int" type="int" />
			<field visibility="private" name="currentRunStart" fulltype="int" type="int" />
			<field visibility="private" name="currentRunLimit" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="AttributedString.AttributedStringIterator">
				<params>
					<param name="attributes" fulltype="java.text.AttributedCharacterIterator.Attribute[]" type="AttributedCharacterIterator.Attribute" />
					<param name="beginIndex" fulltype="int" type="int" />
					<param name="endIndex" fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int" />
			<method visibility="public" name="clone" fulltype="java.lang.Object" type="Object" />
			<method visibility="public" name="first" fulltype="char" type="char" />
			<method visibility="public" name="last" fulltype="char" type="char" />
			<method visibility="public" name="current" fulltype="char" type="char" />
			<method visibility="public" name="next" fulltype="char" type="char" />
			<method visibility="public" name="previous" fulltype="char" type="char" />
			<method visibility="public" name="setIndex" fulltype="char" type="char">
				<params>
					<param name="position" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getBeginIndex" fulltype="int" type="int" />
			<method visibility="public" name="getEndIndex" fulltype="int" type="int" />
			<method visibility="public" name="getIndex" fulltype="int" type="int" />
			<method visibility="public" name="getRunStart" fulltype="int" type="int" />
			<method visibility="public" name="getRunStart" fulltype="int" type="int">
				<params>
					<param name="attribute" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
				</params>
			</method>
			<method visibility="public" name="getRunStart" fulltype="int" type="int">
				<params>
					<param name="attributes" fulltype="java.util.Set" type="Set" />
				</params>
			</method>
			<method visibility="public" name="getRunLimit" fulltype="int" type="int" />
			<method visibility="public" name="getRunLimit" fulltype="int" type="int">
				<params>
					<param name="attribute" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
				</params>
			</method>
			<method visibility="public" name="getRunLimit" fulltype="int" type="int">
				<params>
					<param name="attributes" fulltype="java.util.Set" type="Set" />
				</params>
			</method>
			<method visibility="public" name="getAttributes" fulltype="java.util.Map" type="Map" />
			<method visibility="public" name="getAllAttributeKeys" fulltype="java.util.Set" type="Set" />
			<method visibility="public" name="getAttribute" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="attribute" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
				</params>
			</method>
			<method visibility="private" name="getString" fulltype="java.text.AttributedString" type="AttributedString" />
			<method visibility="private" name="internalSetIndex" fulltype="char" type="char">
				<params>
					<param name="position" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="updateRunInfo" fulltype="void" type="void" />
		</methods>
	</jelclass>
	<jelclass final="true" superclass="AbstractMap" visibility="private" package="java.text" superclassfulltype="java.util.AbstractMap" fulltype="java.text.AttributedString.AttributeMap" type="AttributedString.AttributeMap">
		<fields>
			<field visibility="package-private" name="runIndex" fulltype="int" type="int" />
			<field visibility="package-private" name="beginIndex" fulltype="int" type="int" />
			<field visibility="package-private" name="endIndex" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="AttributedString.AttributeMap">
				<params>
					<param name="runIndex" fulltype="int" type="int" />
					<param name="beginIndex" fulltype="int" type="int" />
					<param name="endIndex" fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="public" name="entrySet" fulltype="java.util.Set" type="Set" />
			<method visibility="public" name="get" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="key" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.AttributeEntry" type="AttributeEntry">
		<implements>
			<interface fulltype="java.util.Map.Entry" type="Map.Entry" />
		</implements>
		<fields>
			<field visibility="private" name="key" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
			<field visibility="private" name="value" fulltype="java.lang.Object" type="Object" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="AttributeEntry">
				<params>
					<param name="key" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
					<param name="value" fulltype="java.lang.Object" type="Object" />
				</params>
			</constructor>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<params>
					<param name="o" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="getKey" fulltype="java.lang.Object" type="Object" />
			<method visibility="public" name="getValue" fulltype="java.lang.Object" type="Object" />
			<method visibility="public" name="setValue" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="newValue" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int" />
			<method visibility="public" name="toString" fulltype="java.lang.String" type="String" />
		</methods>
	</jelclass>
	<jelclass superclass="NumberFormat" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.NumberFormat" fulltype="java.text.DecimalFormat" type="DecimalFormat">
		<comment>
			<description>&lt;code&gt;DecimalFormat&lt;/code&gt; is a concrete subclass of
 &lt;code&gt;NumberFormat&lt;/code&gt; that formats decimal numbers. It has a variety of
 features designed to make it possible to parse and format numbers in any
 locale, including support for Western, Arabic, and Indic digits.  It also
 supports different kinds of numbers, including integers (123), fixed-point
 numbers (123.4), scientific notation (1.23E4), percentages (12%), and
 currency amounts ($123).  All of these can be localized.

 &lt;p&gt;To obtain a &lt;code&gt;NumberFormat&lt;/code&gt; for a specific locale, including the
 default locale, call one of &lt;code&gt;NumberFormat&lt;/code&gt;&apos;s factory methods, such
 as &lt;code&gt;getInstance()&lt;/code&gt;.  In general, do not call the
 &lt;code&gt;DecimalFormat&lt;/code&gt; constructors directly, since the
 &lt;code&gt;NumberFormat&lt;/code&gt; factory methods may return subclasses other than
 &lt;code&gt;DecimalFormat&lt;/code&gt;. If you need to customize the format object, do
 something like this:

 &lt;blockquote&gt;&lt;pre&gt;
 NumberFormat f = NumberFormat.getInstance(loc);
 if (f instanceof DecimalFormat) {
     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
 }
 &lt;/pre&gt;&lt;/blockquote&gt;

 &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; comprises a &lt;em&gt;pattern&lt;/em&gt; and a set of
 &lt;em&gt;symbols&lt;/em&gt;.  The pattern may be set directly using
 &lt;code&gt;applyPattern()&lt;/code&gt;, or indirectly using the API methods.  The
 symbols are stored in a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  When using
 the &lt;code&gt;NumberFormat&lt;/code&gt; factory methods, the pattern and symbols are
 read from localized &lt;code&gt;ResourceBundle&lt;/code&gt;s.

 &lt;h4&gt;Patterns&lt;/h4&gt;

 &lt;code&gt;DecimalFormat&lt;/code&gt; patterns have the following syntax:
 &lt;blockquote&gt;&lt;pre&gt;
 &lt;i&gt;Pattern:&lt;/i&gt;
         &lt;i&gt;PositivePattern&lt;/i&gt;
         &lt;i&gt;PositivePattern&lt;/i&gt; ; &lt;i&gt;NegativePattern&lt;/i&gt;
 &lt;i&gt;PositivePattern:&lt;/i&gt;
         &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 &lt;i&gt;NegativePattern:&lt;/i&gt;
         &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 &lt;i&gt;Prefix:&lt;/i&gt;
         any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
 &lt;i&gt;Suffix:&lt;/i&gt;
         any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
 &lt;i&gt;Number:&lt;/i&gt;
         &lt;i&gt;Integer&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
         &lt;i&gt;Integer&lt;/i&gt; . &lt;i&gt;Fraction&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 &lt;i&gt;Integer:&lt;/i&gt;
         &lt;i&gt;MinimumInteger&lt;/i&gt;
         #
         # &lt;i&gt;Integer&lt;/i&gt;
         # , &lt;i&gt;Integer&lt;/i&gt;
 &lt;i&gt;MinimumInteger:&lt;/i&gt;
         0
         0 &lt;i&gt;MinimumInteger&lt;/i&gt;
         0 , &lt;i&gt;MinimumInteger&lt;/i&gt;
 &lt;i&gt;Fraction:&lt;/i&gt;
         &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 &lt;i&gt;MinimumFraction:&lt;/i&gt;
         0 &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 &lt;i&gt;OptionalFraction:&lt;/i&gt;
         # &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 &lt;i&gt;Exponent:&lt;/i&gt;
         E &lt;i&gt;MinimumExponent&lt;/i&gt;
 &lt;i&gt;MinimumExponent:&lt;/i&gt;
         0 &lt;i&gt;MinimumExponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 &lt;/pre&gt;&lt;/blockquote&gt;

 &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; pattern contains a positive and negative
 subpattern, for example, &lt;code&gt;&quot;#,##0.00;(#,##0.00)&quot;&lt;/code&gt;.  Each
 subpattern has a prefix, numeric part, and suffix. The negative subpattern
 is optional; if absent, then the positive subpattern prefixed with the
 localized minus sign (&lt;code&gt;&apos;-&apos;&lt;/code&gt; in most locales) is used as the
 negative subpattern. That is, &lt;code&gt;&quot;0.00&quot;&lt;/code&gt; alone is equivalent to
 &lt;code&gt;&quot;0.00;-0.00&quot;&lt;/code&gt;.  If there is an explicit negative subpattern, it
 serves only to specify the negative prefix and suffix; the number of digits,
 minimal digits, and other characteristics are all the same as the positive
 pattern. That means that &lt;code&gt;&quot;#,##0.0#;(#)&quot;&lt;/code&gt; produces precisely
 the same behavior as &lt;code&gt;&quot;#,##0.0#;(#,##0.0#)&quot;&lt;/code&gt;.

 &lt;p&gt;The prefixes, suffixes, and various symbols used for infinity, digits,
 thousands separators, decimal separators, etc. may be set to arbitrary
 values, and they will appear properly during formatting.  However, care must
 be taken that the symbols and strings do not conflict, or parsing will be
 unreliable.  For example, either the positive and negative prefixes or the
 suffixes must be distinct for &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; to be able
 to distinguish positive from negative values.  (If they are identical, then
 &lt;code&gt;DecimalFormat&lt;/code&gt; will behave as if no negative subpattern was
 specified.)  Another example is that the decimal separator and thousands
 separator should be distinct characters, or parsing will be impossible.

 &lt;p&gt;The grouping separator is commonly used for thousands, but in some
 countries it separates ten-thousands. The grouping size is a constant number
 of digits between the grouping characters, such as 3 for 100,000,000 or 4 for
 1,0000,0000.  If you supply a pattern with multiple grouping characters, the
 interval between the last one and the end of the integer is the one that is
 used. So &lt;code&gt;&quot;#,##,###,####&quot;&lt;/code&gt; == &lt;code&gt;&quot;######,####&quot;&lt;/code&gt; ==
 &lt;code&gt;&quot;##,####,####&quot;&lt;/code&gt;.

 &lt;h4&gt;Special Pattern Characters&lt;/h4&gt;

 &lt;p&gt;Many characters in a pattern are taken literally; they are matched during
 parsing and output unchanged during formatting.  Special characters, on the
 other hand, stand for other characters, strings, or classes of characters.
 They must be quoted, unless noted otherwise, if they are to appear in the
 prefix or suffix as literals.

 &lt;p&gt;The characters listed here are used in non-localized patterns.  Localized
 patterns use the corresponding characters taken from this formatter&apos;s
 &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object instead, and these characters lose
 their special status.  Two exceptions are the currency sign and quote, which
 are not localized.

 &lt;blockquote&gt;
 &lt;table border=0 cellspacing=3 cellpadding=0 summary=&quot;Chart showing symbol,
  location, localized, and meaning.&quot;&gt;
     &lt;tr bgcolor=&quot;#ccccff&quot;&gt;
          &lt;th align=left&gt;Symbol
          &lt;th align=left&gt;Location
          &lt;th align=left&gt;Localized?
          &lt;th align=left&gt;Meaning
     &lt;tr valign=top&gt;
          &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
          &lt;td&gt;Number
          &lt;td&gt;Yes
          &lt;td&gt;Digit
     &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
          &lt;td&gt;&lt;code&gt;#&lt;/code&gt;
          &lt;td&gt;Number
          &lt;td&gt;Yes
          &lt;td&gt;Digit, zero shows as absent
     &lt;tr valign=top&gt;
          &lt;td&gt;&lt;code&gt;.&lt;/code&gt;
          &lt;td&gt;Number
          &lt;td&gt;Yes
          &lt;td&gt;Decimal separator or monetary decimal separator
     &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
          &lt;td&gt;&lt;code&gt;-&lt;/code&gt;
          &lt;td&gt;Number
          &lt;td&gt;Yes
          &lt;td&gt;Minus sign
     &lt;tr valign=top&gt;
          &lt;td&gt;&lt;code&gt;,&lt;/code&gt;
          &lt;td&gt;Number
          &lt;td&gt;Yes
          &lt;td&gt;Grouping separator
     &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
          &lt;td&gt;&lt;code&gt;E&lt;/code&gt;
          &lt;td&gt;Number
          &lt;td&gt;Yes
          &lt;td&gt;Separates mantissa and exponent in scientific notation.
              &lt;em&gt;Need not be quoted in prefix or suffix.&lt;/em&gt;
     &lt;tr valign=top&gt;
          &lt;td&gt;&lt;code&gt;;&lt;/code&gt;
          &lt;td&gt;Subpattern boundary
          &lt;td&gt;Yes
          &lt;td&gt;Separates positive and negative subpatterns
     &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
          &lt;td&gt;&lt;code&gt;%&lt;/code&gt;
          &lt;td&gt;Prefix or suffix
          &lt;td&gt;Yes
          &lt;td&gt;Multiply by 100 and show as percentage
     &lt;tr valign=top&gt;
          &lt;td&gt;&lt;code&gt;&amp;#92;u2030&lt;/code&gt;
          &lt;td&gt;Prefix or suffix
          &lt;td&gt;Yes
          &lt;td&gt;Multiply by 1000 and show as per mille value
     &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
          &lt;td&gt;&lt;code&gt;&amp;#164;&lt;/code&gt; (&lt;code&gt;&amp;#92;u00A4&lt;/code&gt;)
          &lt;td&gt;Prefix or suffix
          &lt;td&gt;No
          &lt;td&gt;Currency sign, replaced by currency symbol.  If
              doubled, replaced by international currency symbol.
              If present in a pattern, the monetary decimal separator
              is used instead of the decimal separator.
     &lt;tr valign=top&gt;
          &lt;td&gt;&lt;code&gt;&apos;&lt;/code&gt;
          &lt;td&gt;Prefix or suffix
          &lt;td&gt;No
          &lt;td&gt;Used to quote special characters in a prefix or suffix,
              for example, &lt;code&gt;&quot;&apos;#&apos;#&quot;&lt;/code&gt; formats 123 to
              &lt;code&gt;&quot;#123&quot;&lt;/code&gt;.  To create a single quote
              itself, use two in a row: &lt;code&gt;&quot;# o&apos;&apos;clock&quot;&lt;/code&gt;.
 &lt;/table&gt;
 &lt;/blockquote&gt;

 &lt;h4&gt;Scientific Notation&lt;/h4&gt;

 &lt;p&gt;Numbers in scientific notation are expressed as the product of a mantissa
 and a power of ten, for example, 1234 can be expressed as 1.234 x 10^3.  The
 mantissa is often in the range 1.0 &lt;= x &lt; 10.0, but it need not be.
 &lt;code&gt;DecimalFormat&lt;/code&gt; can be instructed to format and parse scientific
 notation &lt;em&gt;only via a pattern&lt;/em&gt;; there is currently no factory method
 that creates a scientific notation format.  In a pattern, the exponent
 character immediately followed by one or more digit characters indicates
 scientific notation.  Example: &lt;code&gt;&quot;0.###E0&quot;&lt;/code&gt; formats the number
 1234 as &lt;code&gt;&quot;1.234E3&quot;&lt;/code&gt;.

 &lt;ul&gt;
 &lt;li&gt;The number of digit characters after the exponent character gives the
 minimum exponent digit count.  There is no maximum.  Negative exponents are
 formatted using the localized minus sign, &lt;em&gt;not&lt;/em&gt; the prefix and suffix
 from the pattern.  This allows patterns such as &lt;code&gt;&quot;0.###E0 m/s&quot;&lt;/code&gt;.

 &lt;li&gt;The minimum and maximum number of integer digits are interpreted
 together:

 &lt;ul&gt;
 &lt;li&gt;If the maximum number of integer digits is greater than their minimum number
 and greater than 1, it forces the exponent to be a multiple of the maximum
 number of integer digits, and the minimum number of integer digits to be
 interpreted as 1.  The most common use of this is to generate
 &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three,
 e.g., &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt;. Using this pattern, the number 12345
 formats to &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt;, and 123456 formats to
 &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt;.

 &lt;li&gt;Otherwise, the minimum number of integer digits is achieved by adjusting the
 exponent.  Example: 0.00123 formatted with &lt;code&gt;&quot;00.###E0&quot;&lt;/code&gt; yields
 &lt;code&gt;&quot;12.3E-4&quot;&lt;/code&gt;.
 &lt;/ul&gt;

 &lt;li&gt;The number of significant digits in the mantissa is the sum of the
 &lt;em&gt;minimum integer&lt;/em&gt; and &lt;em&gt;maximum fraction&lt;/em&gt; digits, and is
 unaffected by the maximum integer digits.  For example, 12345 formatted with
 &lt;code&gt;&quot;##0.##E0&quot;&lt;/code&gt; is &lt;code&gt;&quot;12.3E3&quot;&lt;/code&gt;. To show all digits, set
 the significant digits count to zero.  The number of significant digits
 does not affect parsing.

 &lt;li&gt;Exponential patterns may not contain grouping separators.
 &lt;/ul&gt;

 &lt;h4&gt;Rounding&lt;/h4&gt;

 &lt;code&gt;DecimalFormat&lt;/code&gt; provides rounding modes defined in
 {@link java.math.RoundingMode} for formatting.  By default, it uses
 {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.

 &lt;h4&gt;Digits&lt;/h4&gt;

 For formatting, &lt;code&gt;DecimalFormat&lt;/code&gt; uses the ten consecutive
 characters starting with the localized zero digit defined in the
 &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object as digits. For parsing, these
 digits as well as all Unicode decimal digits, as defined by
 {@link Character#digit Character.digit}, are recognized.

 &lt;h4&gt;Special Values&lt;/h4&gt;

 &lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; is formatted as a string, which typically has a single character
 &lt;code&gt;&amp;#92;uFFFD&lt;/code&gt;.  This string is determined by the
 &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  This is the only value for which
 the prefixes and suffixes are not used.

 &lt;p&gt;Infinity is formatted as a string, which typically has a single character
 &lt;code&gt;&amp;#92;u221E&lt;/code&gt;, with the positive or negative prefixes and suffixes
 applied.  The infinity string is determined by the
 &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.

 &lt;p&gt;Negative zero (&lt;code&gt;&quot;-0&quot;&lt;/code&gt;) parses to
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;BigDecimal(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is
 true,
 &lt;li&gt;&lt;code&gt;Long(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false
     and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; is true,
 &lt;li&gt;&lt;code&gt;Double(-0.0)&lt;/code&gt; if both &lt;code&gt;isParseBigDecimal()&lt;/code&gt;
 and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; are false.
 &lt;/ul&gt;

 &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;

 &lt;p&gt;
 Decimal formats are generally not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently, it must be synchronized
 externally.

 &lt;h4&gt;Example&lt;/h4&gt;

 &lt;blockquote&gt;&lt;pre&gt;
 &lt;strong&gt;// Print out a number using the localized number, integer, currency,
 // and percent format for each locale&lt;/strong&gt;
 Locale[] locales = NumberFormat.getAvailableLocales();
 double myNumber = -1234.56;
 NumberFormat form;
 for (int j=0; j&lt;4; ++j) {
     System.out.println(&quot;FORMAT&quot;);
     for (int i = 0; i &lt; locales.length; ++i) {
         if (locales[i].getCountry().length() == 0) {
            continue; // Skip language-only locales
         }
         System.out.print(locales[i].getDisplayName());
         switch (j) {
         case 0:
             form = NumberFormat.getInstance(locales[i]); break;
         case 1:
             form = NumberFormat.getIntegerInstance(locales[i]); break;
         case 2:
             form = NumberFormat.getCurrencyInstance(locales[i]); break;
         default:
             form = NumberFormat.getPercentInstance(locales[i]); break;
         }
         if (form instanceof DecimalFormat) {
             System.out.print(&quot;: &quot; + ((DecimalFormat) form).toPattern());
         }
         System.out.print(&quot; -&gt; &quot; + form.format(myNumber));
         try {
             System.out.println(&quot; -&gt; &quot; + form.parse(form.format(myNumber)));
         } catch (ParseException e) {}
     }
 }
 &lt;/pre&gt;&lt;/blockquote&gt;</description>
			<attribute name="@see">
				<description>&lt;a href=&quot;http://java.sun.com/docs/books/tutorial/i18n/format/decimalFormat.html&quot;&gt;Java Tutorial&lt;/a&gt;</description>
			</attribute>
			<attribute name="@see">
				<description>NumberFormat</description>
			</attribute>
			<attribute name="@see">
				<description>DecimalFormatSymbols</description>
			</attribute>
			<attribute name="@see">
				<description>ParsePosition</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Davis</description>
			</attribute>
			<attribute name="@author">
				<description>Alan Liu</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" transient="true" name="bigIntegerMultiplier" fulltype="java.math.BigInteger" type="BigInteger" />
			<field visibility="private" transient="true" name="bigDecimalMultiplier" fulltype="java.math.BigDecimal" type="BigDecimal" />
			<field final="true" static="true" const="0" visibility="private" name="STATUS_INFINITE" constexpr="0" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="private" name="STATUS_POSITIVE" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="2" visibility="private" name="STATUS_LENGTH" constexpr="2" fulltype="int" type="int" />
			<field visibility="private" transient="true" name="digitList" fulltype="java.text.DigitList" type="DigitList" />
			<field visibility="private" name="positivePrefix" fulltype="java.lang.String" type="String">
				<comment>
					<description>The symbol used as a prefix when formatting positive numbers, e.g. &quot;+&quot;.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getPositivePrefix</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="positiveSuffix" fulltype="java.lang.String" type="String">
				<comment>
					<description>The symbol used as a suffix when formatting positive numbers.
 This is often an empty string.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getPositiveSuffix</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="negativePrefix" fulltype="java.lang.String" type="String">
				<comment>
					<description>The symbol used as a prefix when formatting negative numbers, e.g. &quot;-&quot;.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getNegativePrefix</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="negativeSuffix" fulltype="java.lang.String" type="String">
				<comment>
					<description>The symbol used as a suffix when formatting negative numbers.
 This is often an empty string.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getNegativeSuffix</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="posPrefixPattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>The prefix pattern for non-negative numbers.  This variable corresponds
 to &lt;code&gt;positivePrefix&lt;/code&gt;.

 &lt;p&gt;This pattern is expanded by the method &lt;code&gt;expandAffix()&lt;/code&gt; to
 &lt;code&gt;positivePrefix&lt;/code&gt; to update the latter to reflect changes in
 &lt;code&gt;symbols&lt;/code&gt;.  If this variable is &lt;code&gt;null&lt;/code&gt; then
 &lt;code&gt;positivePrefix&lt;/code&gt; is taken as a literal value that does not
 change when &lt;code&gt;symbols&lt;/code&gt; changes.  This variable is always
 &lt;code&gt;null&lt;/code&gt; for &lt;code&gt;DecimalFormat&lt;/code&gt; objects older than
 stream version 2 restored from stream.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="posSuffixPattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>The suffix pattern for non-negative numbers.  This variable corresponds
 to &lt;code&gt;positiveSuffix&lt;/code&gt;.  This variable is analogous to
 &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
 documentation.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="negPrefixPattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>The prefix pattern for negative numbers.  This variable corresponds
 to &lt;code&gt;negativePrefix&lt;/code&gt;.  This variable is analogous to
 &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
 documentation.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="negSuffixPattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>The suffix pattern for negative numbers.  This variable corresponds
 to &lt;code&gt;negativeSuffix&lt;/code&gt;.  This variable is analogous to
 &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
 documentation.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="multiplier" fulltype="int" type="int">
				<comment>
					<description>The multiplier for use in percent, per mille, etc.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getMultiplier</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="groupingSize" fulltype="byte" type="byte">
				<comment>
					<description>The number of digits between grouping separators in the integer
 portion of a number.  Must be greater than 0 if
 &lt;code&gt;NumberFormat.groupingUsed&lt;/code&gt; is true.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getGroupingSize</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#isGroupingUsed</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="decimalSeparatorAlwaysShown" fulltype="boolean" type="boolean">
				<comment>
					<description>If true, forces the decimal separator to always appear in a formatted
 number, even if the fractional part of the number is zero.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#isDecimalSeparatorAlwaysShown</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="parseBigDecimal" fulltype="boolean" type="boolean">
				<comment>
					<description>If true, parse returns BigDecimal wherever possible.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#isParseBigDecimal</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" transient="true" name="isCurrencyFormat" fulltype="boolean" type="boolean">
				<comment>
					<description>True if this object represents a currency format.  This determines
 whether the monetary decimal separator is used instead of the normal one.</description>
				</comment>
			</field>
			<field visibility="private" name="symbols" fulltype="java.text.DecimalFormatSymbols" type="DecimalFormatSymbols">
				<comment>
					<description>The &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object used by this format.
 It contains the symbols used to format numbers, e.g. the grouping separator,
 decimal separator, and so on.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#setDecimalFormatSymbols</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DecimalFormatSymbols</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="useExponentialNotation" fulltype="boolean" type="boolean">
				<comment>
					<description>True to force the use of exponential (i.e. scientific) notation when formatting
 numbers.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" transient="true" name="positivePrefixFieldPositions" fulltype="java.text.FieldPosition[]" type="FieldPosition">
				<comment>
					<description>FieldPositions describing the positive prefix String. This is
 lazily created. Use &lt;code&gt;getPositivePrefixFieldPositions&lt;/code&gt;
 when needed.</description>
				</comment>
			</field>
			<field visibility="private" transient="true" name="positiveSuffixFieldPositions" fulltype="java.text.FieldPosition[]" type="FieldPosition">
				<comment>
					<description>FieldPositions describing the positive suffix String. This is
 lazily created. Use &lt;code&gt;getPositiveSuffixFieldPositions&lt;/code&gt;
 when needed.</description>
				</comment>
			</field>
			<field visibility="private" transient="true" name="negativePrefixFieldPositions" fulltype="java.text.FieldPosition[]" type="FieldPosition">
				<comment>
					<description>FieldPositions describing the negative prefix String. This is
 lazily created. Use &lt;code&gt;getNegativePrefixFieldPositions&lt;/code&gt;
 when needed.</description>
				</comment>
			</field>
			<field visibility="private" transient="true" name="negativeSuffixFieldPositions" fulltype="java.text.FieldPosition[]" type="FieldPosition">
				<comment>
					<description>FieldPositions describing the negative suffix String. This is
 lazily created. Use &lt;code&gt;getNegativeSuffixFieldPositions&lt;/code&gt;
 when needed.</description>
				</comment>
			</field>
			<field visibility="private" name="minExponentDigits" fulltype="byte" type="byte">
				<comment>
					<description>The minimum number of digits used to display the exponent when a number is
 formatted in exponential notation.  This field is ignored if
 &lt;code&gt;useExponentialNotation&lt;/code&gt; is not true.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="maximumIntegerDigits" fulltype="int" type="int">
				<comment>
					<description>The maximum number of digits allowed in the integer portion of a
 &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
 &lt;code&gt;maximumIntegerDigits&lt;/code&gt; must be greater than or equal to
 &lt;code&gt;minimumIntegerDigits&lt;/code&gt;.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getMaximumIntegerDigits</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="minimumIntegerDigits" fulltype="int" type="int">
				<comment>
					<description>The minimum number of digits allowed in the integer portion of a
 &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
 &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to
 &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getMinimumIntegerDigits</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="maximumFractionDigits" fulltype="int" type="int">
				<comment>
					<description>The maximum number of digits allowed in the fractional portion of a
 &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
 &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to
 &lt;code&gt;minimumFractionDigits&lt;/code&gt;.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getMaximumFractionDigits</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="minimumFractionDigits" fulltype="int" type="int">
				<comment>
					<description>The minimum number of digits allowed in the fractional portion of a
 &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
 &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to
 &lt;code&gt;maximumFractionDigits&lt;/code&gt;.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getMinimumFractionDigits</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="roundingMode" fulltype="java.math.RoundingMode" type="RoundingMode">
				<comment>
					<description>The {@link java.math.RoundingMode} used in this DecimalFormat.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="4" visibility="package-private" name="currentSerialVersion" constexpr="4" fulltype="int" type="int" />
			<field visibility="private" name="serialVersionOnStream" fulltype="int" type="int">
				<comment>
					<description>The internal serial version which says which version was written.
 Possible values are:
 &lt;ul&gt;
 &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (default): versions before the Java 2 platform v1.2
 &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: version for 1.2, which includes the two new fields
      &lt;code&gt;useExponentialNotation&lt;/code&gt; and
      &lt;code&gt;minExponentDigits&lt;/code&gt;.
 &lt;li&gt;&lt;b&gt;2&lt;/b&gt;: version for 1.3 and later, which adds four new fields:
      &lt;code&gt;posPrefixPattern&lt;/code&gt;, &lt;code&gt;posSuffixPattern&lt;/code&gt;,
      &lt;code&gt;negPrefixPattern&lt;/code&gt;, and &lt;code&gt;negSuffixPattern&lt;/code&gt;.
 &lt;li&gt;&lt;b&gt;3&lt;/b&gt;: version for 1.5 and later, which adds five new fields:
      &lt;code&gt;maximumIntegerDigits&lt;/code&gt;,
      &lt;code&gt;minimumIntegerDigits&lt;/code&gt;,
      &lt;code&gt;maximumFractionDigits&lt;/code&gt;,
      &lt;code&gt;minimumFractionDigits&lt;/code&gt;, and
      &lt;code&gt;parseBigDecimal&lt;/code&gt;.
 &lt;li&gt;&lt;b&gt;4&lt;/b&gt;: version for 1.6 and later, which adds one new field:
      &lt;code&gt;roundingMode&lt;/code&gt;.
 &lt;/ul&gt;</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
					<attribute name="@serial" />
				</comment>
			</field>
			<field final="true" static="true" const="48" visibility="private" name="PATTERN_ZERO_DIGIT" constexpr="48" fulltype="char" type="char" />
			<field final="true" static="true" const="44" visibility="private" name="PATTERN_GROUPING_SEPARATOR" constexpr="44" fulltype="char" type="char" />
			<field final="true" static="true" const="46" visibility="private" name="PATTERN_DECIMAL_SEPARATOR" constexpr="46" fulltype="char" type="char" />
			<field final="true" static="true" const="8240" visibility="private" name="PATTERN_PER_MILLE" constexpr="8240" fulltype="char" type="char" />
			<field final="true" static="true" const="37" visibility="private" name="PATTERN_PERCENT" constexpr="37" fulltype="char" type="char" />
			<field final="true" static="true" const="35" visibility="private" name="PATTERN_DIGIT" constexpr="35" fulltype="char" type="char" />
			<field final="true" static="true" const="59" visibility="private" name="PATTERN_SEPARATOR" constexpr="59" fulltype="char" type="char" />
			<field final="true" static="true" const="E" visibility="private" name="PATTERN_EXPONENT" constexpr="&quot;E&quot;" fulltype="java.lang.String" type="String" />
			<field final="true" static="true" const="45" visibility="private" name="PATTERN_MINUS" constexpr="45" fulltype="char" type="char" />
			<field final="true" static="true" const="164" visibility="private" name="CURRENCY_SIGN" constexpr="164" fulltype="char" type="char">
				<comment>
					<description>The CURRENCY_SIGN is the standard Unicode symbol for currency.  It
 is used in patterns and substituted with either the currency symbol,
 or if it is doubled, with the international currency symbol.  If the
 CURRENCY_SIGN is seen in a pattern, then the decimal separator is
 replaced with the monetary decimal separator.

 The CURRENCY_SIGN is not localized.</description>
				</comment>
			</field>
			<field final="true" static="true" const="39" visibility="private" name="QUOTE" constexpr="39" fulltype="char" type="char" />
			<field static="true" visibility="private" name="EmptyFieldPositionArray" fulltype="java.text.FieldPosition[]" type="FieldPosition" />
			<field final="true" static="true" const="309" visibility="package-private" name="DOUBLE_INTEGER_DIGITS" constexpr="309" fulltype="int" type="int" />
			<field final="true" static="true" const="340" visibility="package-private" name="DOUBLE_FRACTION_DIGITS" constexpr="340" fulltype="int" type="int" />
			<field final="true" static="true" const="2147483647" visibility="package-private" name="MAXIMUM_INTEGER_DIGITS" constexpr="2147483647" fulltype="int" type="int" />
			<field final="true" static="true" const="2147483647" visibility="package-private" name="MAXIMUM_FRACTION_DIGITS" constexpr="2147483647" fulltype="int" type="int" />
			<field final="true" static="true" const="864413376551465018" visibility="package-private" name="serialVersionUID" constexpr="864413376551465018L" fulltype="long" type="long" />
			<field static="true" visibility="private" name="cachedLocaleData" fulltype="java.util.Hashtable" type="Hashtable">
				<comment>
					<description>Cache to hold the NumberPattern of a Locale.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="DecimalFormat">
				<comment>
					<description>Creates a DecimalFormat using the default pattern and symbols
 for the default locale. This is a convenient way to obtain a
 DecimalFormat when internationalization is not the main concern.
 &lt;p&gt;
 To obtain standard formats for a given locale, use the factory methods
 on NumberFormat such as getNumberInstance. These factories will
 return the most appropriate sub-class of NumberFormat for a given
 locale.</description>
					<attribute name="@see">
						<description>java.text.NumberFormat#getInstance</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getNumberInstance</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getCurrencyInstance</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getPercentInstance</description>
					</attribute>
				</comment>
			</constructor>
			<constructor visibility="public" name="DecimalFormat">
				<comment>
					<description>Creates a DecimalFormat using the given pattern and the symbols
 for the default locale. This is a convenient way to obtain a
 DecimalFormat when internationalization is not the main concern.
 &lt;p&gt;
 To obtain standard formats for a given locale, use the factory methods
 on NumberFormat such as getNumberInstance. These factories will
 return the most appropriate sub-class of NumberFormat for a given
 locale.</description>
					<attribute name="@param">
						<description>pattern A non-localized pattern string.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;pattern&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the given pattern is invalid.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getInstance</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getNumberInstance</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getCurrencyInstance</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getPercentInstance</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="A non-localized pattern string." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="DecimalFormat">
				<comment>
					<description>Creates a DecimalFormat using the given pattern and symbols.
 Use this constructor when you need to completely customize the
 behavior of the format.
 &lt;p&gt;
 To obtain standard formats for a given
 locale, use the factory methods on NumberFormat such as
 getInstance or getCurrencyInstance. If you need only minor adjustments
 to a standard format, you can modify the format returned by
 a NumberFormat factory method.</description>
					<attribute name="@param">
						<description>pattern a non-localized pattern string</description>
					</attribute>
					<attribute name="@param">
						<description>symbols the set of symbols to be used</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if any of the given arguments is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the given pattern is invalid</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getInstance</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getNumberInstance</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getCurrencyInstance</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#getPercentInstance</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DecimalFormatSymbols</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="a non-localized pattern string" fulltype="java.lang.String" type="String" />
					<param name="symbols" comment="the set of symbols to be used" fulltype="java.text.DecimalFormatSymbols" type="DecimalFormatSymbols" />
				</params>
			</constructor>
			<method final="true" visibility="public" name="format" returncomment="the value passed in as &lt;code&gt;toAppendTo&lt;/code&gt;" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Formats a number and appends the resulting text to the given string
 buffer.
 The number can be of any subclass of {@link java.lang.Number}.
 &lt;p&gt;
 This implementation uses the maximum precision permitted.</description>
					<attribute name="@param">
						<description>number     the number to format</description>
					</attribute>
					<attribute name="@param">
						<description>toAppendTo the &lt;code&gt;StringBuffer&lt;/code&gt; to which the formatted
                   text is to be appended</description>
					</attribute>
					<attribute name="@param">
						<description>pos        On input: an alignment field, if desired.
                   On output: the offsets of the alignment field.</description>
					</attribute>
					<attribute name="@return">
						<description>the value passed in as &lt;code&gt;toAppendTo&lt;/code&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;number&lt;/code&gt; is
                   null or not an instance of &lt;code&gt;Number&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or
                   &lt;code&gt;pos&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                   mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.FieldPosition</description>
					</attribute>
				</comment>
				<params>
					<param name="number" comment="the number to format" fulltype="java.lang.Object" type="Object" />
					<param name="toAppendTo" comment="the &lt;code&gt;StringBuffer&lt;/code&gt; to which the formatted
                   text is to be appended" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="pos" comment="On input: an alignment field, if desired.
                   On output: the offsets of the alignment field." fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method visibility="public" name="format" returncomment="The formatted number string" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Formats a double to produce a string.</description>
					<attribute name="@param">
						<description>number    The double to format</description>
					</attribute>
					<attribute name="@param">
						<description>result    where the text is to be appended</description>
					</attribute>
					<attribute name="@param">
						<description>fieldPosition    On input: an alignment field, if desired.
 On output: the offsets of the alignment field.</description>
					</attribute>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
            mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@return">
						<description>The formatted number string</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.FieldPosition</description>
					</attribute>
				</comment>
				<params>
					<param name="number" comment="The double to format" fulltype="double" type="double" />
					<param name="result" comment="where the text is to be appended" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="fieldPosition" comment="On input: an alignment field, if desired.
 On output: the offsets of the alignment field." fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method visibility="private" name="format" returncomment="The formatted number string" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Formats a double to produce a string.</description>
					<attribute name="@param">
						<description>number    The double to format</description>
					</attribute>
					<attribute name="@param">
						<description>result    where the text is to be appended</description>
					</attribute>
					<attribute name="@param">
						<description>delegate notified of locations of sub fields</description>
					</attribute>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                  mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@return">
						<description>The formatted number string</description>
					</attribute>
				</comment>
				<params>
					<param name="number" comment="The double to format" fulltype="double" type="double" />
					<param name="result" comment="where the text is to be appended" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="delegate" comment="notified of locations of sub fields" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
				</params>
			</method>
			<method visibility="public" name="format" returncomment="The formatted number string" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Format a long to produce a string.</description>
					<attribute name="@param">
						<description>number    The long to format</description>
					</attribute>
					<attribute name="@param">
						<description>result    where the text is to be appended</description>
					</attribute>
					<attribute name="@param">
						<description>fieldPosition    On input: an alignment field, if desired.
 On output: the offsets of the alignment field.</description>
					</attribute>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                  mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@return">
						<description>The formatted number string</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.FieldPosition</description>
					</attribute>
				</comment>
				<params>
					<param name="number" comment="The long to format" fulltype="long" type="long" />
					<param name="result" comment="where the text is to be appended" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="fieldPosition" comment="On input: an alignment field, if desired.
 On output: the offsets of the alignment field." fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method visibility="private" name="format" returncomment="The formatted number string" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Format a long to produce a string.</description>
					<attribute name="@param">
						<description>number    The long to format</description>
					</attribute>
					<attribute name="@param">
						<description>result    where the text is to be appended</description>
					</attribute>
					<attribute name="@param">
						<description>delegate notified of locations of sub fields</description>
					</attribute>
					<attribute name="@return">
						<description>The formatted number string</description>
					</attribute>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                   mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.FieldPosition</description>
					</attribute>
				</comment>
				<params>
					<param name="number" comment="The long to format" fulltype="long" type="long" />
					<param name="result" comment="where the text is to be appended" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="delegate" comment="notified of locations of sub fields" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
				</params>
			</method>
			<method visibility="private" name="format" returncomment="The formatted number string" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Formats a BigDecimal to produce a string.</description>
					<attribute name="@param">
						<description>number    The BigDecimal to format</description>
					</attribute>
					<attribute name="@param">
						<description>result    where the text is to be appended</description>
					</attribute>
					<attribute name="@param">
						<description>fieldPosition    On input: an alignment field, if desired.
 On output: the offsets of the alignment field.</description>
					</attribute>
					<attribute name="@return">
						<description>The formatted number string</description>
					</attribute>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                   mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.FieldPosition</description>
					</attribute>
				</comment>
				<params>
					<param name="number" comment="The BigDecimal to format" fulltype="java.math.BigDecimal" type="BigDecimal" />
					<param name="result" comment="where the text is to be appended" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="fieldPosition" comment="On input: an alignment field, if desired.
 On output: the offsets of the alignment field." fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method visibility="private" name="format" returncomment="The formatted number string" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Formats a BigDecimal to produce a string.</description>
					<attribute name="@param">
						<description>number    The BigDecimal to format</description>
					</attribute>
					<attribute name="@param">
						<description>result    where the text is to be appended</description>
					</attribute>
					<attribute name="@param">
						<description>delegate notified of locations of sub fields</description>
					</attribute>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                   mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@return">
						<description>The formatted number string</description>
					</attribute>
				</comment>
				<params>
					<param name="number" comment="The BigDecimal to format" fulltype="java.math.BigDecimal" type="BigDecimal" />
					<param name="result" comment="where the text is to be appended" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="delegate" comment="notified of locations of sub fields" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
				</params>
			</method>
			<method visibility="private" name="format" returncomment="The formatted number string" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Format a BigInteger to produce a string.</description>
					<attribute name="@param">
						<description>number    The BigInteger to format</description>
					</attribute>
					<attribute name="@param">
						<description>result    where the text is to be appended</description>
					</attribute>
					<attribute name="@param">
						<description>fieldPosition    On input: an alignment field, if desired.
 On output: the offsets of the alignment field.</description>
					</attribute>
					<attribute name="@return">
						<description>The formatted number string</description>
					</attribute>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                   mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.FieldPosition</description>
					</attribute>
				</comment>
				<params>
					<param name="number" comment="The BigInteger to format" fulltype="java.math.BigInteger" type="BigInteger" />
					<param name="result" comment="where the text is to be appended" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="fieldPosition" comment="On input: an alignment field, if desired.
 On output: the offsets of the alignment field." fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method visibility="private" name="format" returncomment="The formatted number string" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Format a BigInteger to produce a string.</description>
					<attribute name="@param">
						<description>number    The BigInteger to format</description>
					</attribute>
					<attribute name="@param">
						<description>result    where the text is to be appended</description>
					</attribute>
					<attribute name="@param">
						<description>delegate notified of locations of sub fields</description>
					</attribute>
					<attribute name="@return">
						<description>The formatted number string</description>
					</attribute>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                   mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.FieldPosition</description>
					</attribute>
				</comment>
				<params>
					<param name="number" comment="The BigInteger to format" fulltype="java.math.BigInteger" type="BigInteger" />
					<param name="result" comment="where the text is to be appended" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="delegate" comment="notified of locations of sub fields" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
					<param name="formatLong" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="formatToCharacterIterator" returncomment="AttributedCharacterIterator describing the formatted value." fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
				<comment>
					<description>Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
 You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
 to build the resulting String, as well as to determine information
 about the resulting String.
 &lt;p&gt;
 Each attribute key of the AttributedCharacterIterator will be of type
 &lt;code&gt;NumberFormat.Field&lt;/code&gt;, with the attribute value being the
 same as the attribute key.</description>
					<attribute name="@exception">
						<description>NullPointerException if obj is null.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException when the Format cannot format the
            given object.</description>
					</attribute>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                   mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@param">
						<description>obj The object to format</description>
					</attribute>
					<attribute name="@return">
						<description>AttributedCharacterIterator describing the formatted value.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="The object to format" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="private" name="subformat" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Complete the formatting of a finite number.  On entry, the digitList must
 be filled in with the correct digits.</description>
				</comment>
				<params>
					<param name="result" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="delegate" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
					<param name="isNegative" fulltype="boolean" type="boolean" />
					<param name="isInteger" fulltype="boolean" type="boolean" />
					<param name="maxIntDigits" fulltype="int" type="int" />
					<param name="minIntDigits" fulltype="int" type="int" />
					<param name="maxFraDigits" fulltype="int" type="int" />
					<param name="minFraDigits" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="append" fulltype="void" type="void">
				<comment>
					<description>Appends the String &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;result&lt;/code&gt;.
 &lt;code&gt;delegate&lt;/code&gt; is notified of all  the
 &lt;code&gt;FieldPosition&lt;/code&gt;s in &lt;code&gt;positions&lt;/code&gt;.
 &lt;p&gt;
 If one of the &lt;code&gt;FieldPosition&lt;/code&gt;s in &lt;code&gt;positions&lt;/code&gt;
 identifies a &lt;code&gt;SIGN&lt;/code&gt; attribute, it is mapped to
 &lt;code&gt;signAttribute&lt;/code&gt;. This is used
 to map the &lt;code&gt;SIGN&lt;/code&gt; attribute to the &lt;code&gt;EXPONENT&lt;/code&gt;
 attribute as necessary.
 &lt;p&gt;
 This is used by &lt;code&gt;subformat&lt;/code&gt; to add the prefix/suffix.</description>
				</comment>
				<params>
					<param name="result" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="string" fulltype="java.lang.String" type="String" />
					<param name="delegate" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
					<param name="positions" fulltype="java.text.FieldPosition[]" type="FieldPosition" />
					<param name="signAttribute" fulltype="java.text.Format.Field" type="Format.Field" />
				</params>
			</method>
			<method visibility="public" name="parse" returncomment="the parsed value, or &lt;code&gt;null&lt;/code&gt; if the parse fails" fulltype="java.lang.Number" type="Number">
				<comment>
					<description>Parses text from a string to produce a &lt;code&gt;Number&lt;/code&gt;.
 &lt;p&gt;
 The method attempts to parse text starting at the index given by
 &lt;code&gt;pos&lt;/code&gt;.
 If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
 to the index after the last character used (parsing does not necessarily
 use all characters up to the end of the string), and the parsed
 number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
 indicate the starting point for the next call to this method.
 If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
 changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
 the character where the error occurred, and null is returned.
 &lt;p&gt;
 The subclass returned depends on the value of {@link #isParseBigDecimal}
 as well as on the string being parsed.
 &lt;ul&gt;
   &lt;li&gt;If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false (the default),
       most integer values are returned as &lt;code&gt;Long&lt;/code&gt;
       objects, no matter how they are written: &lt;code&gt;&quot;17&quot;&lt;/code&gt; and
       &lt;code&gt;&quot;17.000&quot;&lt;/code&gt; both parse to &lt;code&gt;Long(17)&lt;/code&gt;.
       Values that cannot fit into a &lt;code&gt;Long&lt;/code&gt; are returned as
       &lt;code&gt;Double&lt;/code&gt;s. This includes values with a fractional part,
       infinite values, &lt;code&gt;NaN&lt;/code&gt;, and the value -0.0.
       &lt;code&gt;DecimalFormat&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; decide whether to
       return a &lt;code&gt;Double&lt;/code&gt; or a &lt;code&gt;Long&lt;/code&gt; based on the
       presence of a decimal separator in the source string. Doing so
       would prevent integers that overflow the mantissa of a double,
       such as &lt;code&gt;&quot;-9,223,372,036,854,775,808.00&quot;&lt;/code&gt;, from being
       parsed accurately.
       &lt;p&gt;
       Callers may use the &lt;code&gt;Number&lt;/code&gt; methods
       &lt;code&gt;doubleValue&lt;/code&gt;, &lt;code&gt;longValue&lt;/code&gt;, etc., to obtain
       the type they want.
   &lt;li&gt;If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is true, values are returned
       as &lt;code&gt;BigDecimal&lt;/code&gt; objects. The values are the ones
       constructed by {@link java.math.BigDecimal#BigDecimal(String)}
       for corresponding strings in locale-independent format. The
       special cases negative and positive infinity and NaN are returned
       as &lt;code&gt;Double&lt;/code&gt; instances holding the values of the
       corresponding &lt;code&gt;Double&lt;/code&gt; constants.
 &lt;/ul&gt;
 &lt;p&gt;
 &lt;code&gt;DecimalFormat&lt;/code&gt; parses all Unicode characters that represent
 decimal digits, as defined by &lt;code&gt;Character.digit()&lt;/code&gt;. In
 addition, &lt;code&gt;DecimalFormat&lt;/code&gt; also recognizes as digits the ten
 consecutive characters starting with the localized zero digit defined in
 the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.</description>
					<attribute name="@param">
						<description>text the string to be parsed</description>
					</attribute>
					<attribute name="@param">
						<description>pos  A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
             index information as described above.</description>
					</attribute>
					<attribute name="@return">
						<description>the parsed value, or &lt;code&gt;null&lt;/code&gt; if the parse fails</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;text&lt;/code&gt; or
             &lt;code&gt;pos&lt;/code&gt; is null.</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="the string to be parsed" fulltype="java.lang.String" type="String" />
					<param name="pos" comment="A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
             index information as described above." fulltype="java.text.ParsePosition" type="ParsePosition" />
				</params>
			</method>
			<method visibility="private" name="getBigIntegerMultiplier" fulltype="java.math.BigInteger" type="BigInteger">
				<comment>
					<description>Return a BigInteger multiplier.</description>
				</comment>
			</method>
			<method visibility="private" name="getBigDecimalMultiplier" fulltype="java.math.BigDecimal" type="BigDecimal">
				<comment>
					<description>Return a BigDecimal multiplier.</description>
				</comment>
			</method>
			<method final="true" visibility="private" name="subparse" fulltype="boolean" type="boolean">
				<comment>
					<description>Parse the given text into a number.  The text is parsed beginning at
 parsePosition, until an unparseable character is seen.</description>
					<attribute name="@param">
						<description>text The string to parse.</description>
					</attribute>
					<attribute name="@param">
						<description>parsePosition The position at which to being parsing.  Upon
 return, the first unparseable character.</description>
					</attribute>
					<attribute name="@param">
						<description>digits The DigitList to set to the parsed value.</description>
					</attribute>
					<attribute name="@param">
						<description>isExponent If true, parse an exponent.  This means no
 infinite values and integer only.</description>
					</attribute>
					<attribute name="@param">
						<description>status Upon return contains boolean status flags indicating
 whether the value was infinite and whether it was positive.</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="The string to parse." fulltype="java.lang.String" type="String" />
					<param name="parsePosition" comment="The position at which to being parsing.  Upon
 return, the first unparseable character." fulltype="java.text.ParsePosition" type="ParsePosition" />
					<param name="positivePrefix" fulltype="java.lang.String" type="String" />
					<param name="negativePrefix" fulltype="java.lang.String" type="String" />
					<param name="digits" comment="The DigitList to set to the parsed value." fulltype="java.text.DigitList" type="DigitList" />
					<param name="isExponent" comment="If true, parse an exponent.  This means no
 infinite values and integer only." fulltype="boolean" type="boolean" />
					<param name="status" comment="Upon return contains boolean status flags indicating
 whether the value was infinite and whether it was positive." fulltype="boolean[]" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="getDecimalFormatSymbols" returncomment="a copy of the desired DecimalFormatSymbols" fulltype="java.text.DecimalFormatSymbols" type="DecimalFormatSymbols">
				<comment>
					<description>Returns a copy of the decimal format symbols, which is generally not
 changed by the programmer or user.</description>
					<attribute name="@return">
						<description>a copy of the desired DecimalFormatSymbols</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DecimalFormatSymbols</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setDecimalFormatSymbols" fulltype="void" type="void">
				<comment>
					<description>Sets the decimal format symbols, which is generally not changed
 by the programmer or user.</description>
					<attribute name="@param">
						<description>newSymbols desired DecimalFormatSymbols</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DecimalFormatSymbols</description>
					</attribute>
				</comment>
				<params>
					<param name="newSymbols" comment="desired DecimalFormatSymbols" fulltype="java.text.DecimalFormatSymbols" type="DecimalFormatSymbols" />
				</params>
			</method>
			<method visibility="public" name="getPositivePrefix" fulltype="java.lang.String" type="String">
				<comment>
					<description>Get the positive prefix.
 &lt;P&gt;Examples: +123, $123, sFr123</description>
				</comment>
			</method>
			<method visibility="public" name="setPositivePrefix" fulltype="void" type="void">
				<comment>
					<description>Set the positive prefix.
 &lt;P&gt;Examples: +123, $123, sFr123</description>
				</comment>
				<params>
					<param name="newValue" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="getPositivePrefixFieldPositions" returncomment="FieldPositions in positive prefix" fulltype="java.text.FieldPosition[]" type="FieldPosition">
				<comment>
					<description>Returns the FieldPositions of the fields in the prefix used for
 positive numbers. This is not used if the user has explicitly set
 a positive prefix via &lt;code&gt;setPositivePrefix&lt;/code&gt;. This is
 lazily created.</description>
					<attribute name="@return">
						<description>FieldPositions in positive prefix</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getNegativePrefix" fulltype="java.lang.String" type="String">
				<comment>
					<description>Get the negative prefix.
 &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123</description>
				</comment>
			</method>
			<method visibility="public" name="setNegativePrefix" fulltype="void" type="void">
				<comment>
					<description>Set the negative prefix.
 &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123</description>
				</comment>
				<params>
					<param name="newValue" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="getNegativePrefixFieldPositions" returncomment="FieldPositions in positive prefix" fulltype="java.text.FieldPosition[]" type="FieldPosition">
				<comment>
					<description>Returns the FieldPositions of the fields in the prefix used for
 negative numbers. This is not used if the user has explicitly set
 a negative prefix via &lt;code&gt;setNegativePrefix&lt;/code&gt;. This is
 lazily created.</description>
					<attribute name="@return">
						<description>FieldPositions in positive prefix</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getPositiveSuffix" fulltype="java.lang.String" type="String">
				<comment>
					<description>Get the positive suffix.
 &lt;P&gt;Example: 123%</description>
				</comment>
			</method>
			<method visibility="public" name="setPositiveSuffix" fulltype="void" type="void">
				<comment>
					<description>Set the positive suffix.
 &lt;P&gt;Example: 123%</description>
				</comment>
				<params>
					<param name="newValue" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="getPositiveSuffixFieldPositions" returncomment="FieldPositions in positive prefix" fulltype="java.text.FieldPosition[]" type="FieldPosition">
				<comment>
					<description>Returns the FieldPositions of the fields in the suffix used for
 positive numbers. This is not used if the user has explicitly set
 a positive suffix via &lt;code&gt;setPositiveSuffix&lt;/code&gt;. This is
 lazily created.</description>
					<attribute name="@return">
						<description>FieldPositions in positive prefix</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getNegativeSuffix" fulltype="java.lang.String" type="String">
				<comment>
					<description>Get the negative suffix.
 &lt;P&gt;Examples: -123%, ($123) (with positive suffixes)</description>
				</comment>
			</method>
			<method visibility="public" name="setNegativeSuffix" fulltype="void" type="void">
				<comment>
					<description>Set the negative suffix.
 &lt;P&gt;Examples: 123%</description>
				</comment>
				<params>
					<param name="newValue" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="getNegativeSuffixFieldPositions" returncomment="FieldPositions in positive prefix" fulltype="java.text.FieldPosition[]" type="FieldPosition">
				<comment>
					<description>Returns the FieldPositions of the fields in the suffix used for
 negative numbers. This is not used if the user has explicitly set
 a negative suffix via &lt;code&gt;setNegativeSuffix&lt;/code&gt;. This is
 lazily created.</description>
					<attribute name="@return">
						<description>FieldPositions in positive prefix</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getMultiplier" fulltype="int" type="int">
				<comment>
					<description>Gets the multiplier for use in percent, per mille, and similar
 formats.</description>
					<attribute name="@see">
						<description>#setMultiplier(int)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setMultiplier" fulltype="void" type="void">
				<comment>
					<description>Sets the multiplier for use in percent, per mille, and similar
 formats.
 For a percent format, set the multiplier to 100 and the suffixes to
 have &apos;%&apos; (for Arabic, use the Arabic percent sign).
 For a per mille format, set the multiplier to 1000 and the suffixes to
 have &apos;&amp;#92;u2030&apos;.

 &lt;P&gt;Example: with multiplier 100, 1.23 is formatted as &quot;123&quot;, and
 &quot;123&quot; is parsed into 1.23.</description>
					<attribute name="@see">
						<description>#getMultiplier</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getGroupingSize" fulltype="int" type="int">
				<comment>
					<description>Return the grouping size. Grouping size is the number of digits between
 grouping separators in the integer portion of a number.  For example,
 in the number &quot;123,456.78&quot;, the grouping size is 3.</description>
					<attribute name="@see">
						<description>#setGroupingSize</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#isGroupingUsed</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DecimalFormatSymbols#getGroupingSeparator</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setGroupingSize" fulltype="void" type="void">
				<comment>
					<description>Set the grouping size. Grouping size is the number of digits between
 grouping separators in the integer portion of a number.  For example,
 in the number &quot;123,456.78&quot;, the grouping size is 3.
 &lt;br&gt;
 The value passed in is converted to a byte, which may lose information.</description>
					<attribute name="@see">
						<description>#getGroupingSize</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#setGroupingUsed</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DecimalFormatSymbols#setGroupingSeparator</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="isDecimalSeparatorAlwaysShown" fulltype="boolean" type="boolean">
				<comment>
					<description>Allows you to get the behavior of the decimal separator with integers.
 (The decimal separator will always appear with decimals.)
 &lt;P&gt;Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345</description>
				</comment>
			</method>
			<method visibility="public" name="setDecimalSeparatorAlwaysShown" fulltype="void" type="void">
				<comment>
					<description>Allows you to set the behavior of the decimal separator with integers.
 (The decimal separator will always appear with decimals.)
 &lt;P&gt;Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345</description>
				</comment>
				<params>
					<param name="newValue" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="isParseBigDecimal" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns whether the {@link #parse(java.lang.String, java.text.ParsePosition)}
 method returns &lt;code&gt;BigDecimal&lt;/code&gt;. The default value is false.</description>
					<attribute name="@see">
						<description>#setParseBigDecimal</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setParseBigDecimal" fulltype="void" type="void">
				<comment>
					<description>Sets whether the {@link #parse(java.lang.String, java.text.ParsePosition)}
 method returns &lt;code&gt;BigDecimal&lt;/code&gt;.</description>
					<attribute name="@see">
						<description>#isParseBigDecimal</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="clone" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Standard override; no change in semantics.</description>
				</comment>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Overrides equals</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Overrides hashCode</description>
				</comment>
			</method>
			<method visibility="public" name="toPattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>Synthesizes a pattern string that represents the current state
 of this Format object.</description>
					<attribute name="@see">
						<description>#applyPattern</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toLocalizedPattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>Synthesizes a localized pattern string that represents the current
 state of this Format object.</description>
					<attribute name="@see">
						<description>#applyPattern</description>
					</attribute>
				</comment>
			</method>
			<method visibility="private" name="expandAffixes" fulltype="void" type="void">
				<comment>
					<description>Expand the affix pattern strings into the expanded affix strings.  If any
 affix pattern string is null, do not expand it.  This method should be
 called any time the symbols or the affix patterns change in order to keep
 the expanded affix strings up to date.</description>
				</comment>
			</method>
			<method visibility="private" name="expandAffix" returncomment="the expanded equivalent of pattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>Expand an affix pattern into an affix string.  All characters in the
 pattern are literal unless prefixed by QUOTE.  The following characters
 after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
 PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
 CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
 currency code.  Any other character after a QUOTE represents itself.
 QUOTE must be followed by another character; QUOTE may not occur by
 itself at the end of the pattern.</description>
					<attribute name="@param">
						<description>pattern the non-null, possibly empty pattern</description>
					</attribute>
					<attribute name="@param">
						<description>buffer a scratch StringBuffer; its contents will be lost</description>
					</attribute>
					<attribute name="@return">
						<description>the expanded equivalent of pattern</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="the non-null, possibly empty pattern" fulltype="java.lang.String" type="String" />
					<param name="buffer" comment="a scratch StringBuffer; its contents will be lost" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
			<method visibility="private" name="expandAffix" returncomment="FieldPosition array of the resulting fields." fulltype="java.text.FieldPosition[]" type="FieldPosition">
				<comment>
					<description>Expand an affix pattern into an array of FieldPositions describing
 how the pattern would be expanded.
 All characters in the
 pattern are literal unless prefixed by QUOTE.  The following characters
 after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
 PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
 CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
 currency code.  Any other character after a QUOTE represents itself.
 QUOTE must be followed by another character; QUOTE may not occur by
 itself at the end of the pattern.</description>
					<attribute name="@param">
						<description>pattern the non-null, possibly empty pattern</description>
					</attribute>
					<attribute name="@return">
						<description>FieldPosition array of the resulting fields.</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="the non-null, possibly empty pattern" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="appendAffix" fulltype="void" type="void">
				<comment>
					<description>Appends an affix pattern to the given StringBuffer, quoting special
 characters as needed.  Uses the internal affix pattern, if that exists,
 or the literal affix, if the internal affix pattern is null.  The
 appended string will generate the same affix pattern (or literal affix)
 when passed to toPattern().</description>
					<attribute name="@param">
						<description>buffer the affix string is appended to this</description>
					</attribute>
					<attribute name="@param">
						<description>affixPattern a pattern such as posPrefixPattern; may be null</description>
					</attribute>
					<attribute name="@param">
						<description>expAffix a corresponding expanded affix, such as positivePrefix.
 Ignored unless affixPattern is null.  If affixPattern is null, then
 expAffix is appended as a literal affix.</description>
					</attribute>
					<attribute name="@param">
						<description>localized true if the appended pattern should contain localized
 pattern characters; otherwise, non-localized pattern chars are appended</description>
					</attribute>
				</comment>
				<params>
					<param name="buffer" comment="the affix string is appended to this" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="affixPattern" comment="a pattern such as posPrefixPattern; may be null" fulltype="java.lang.String" type="String" />
					<param name="expAffix" comment="a corresponding expanded affix, such as positivePrefix.
 Ignored unless affixPattern is null.  If affixPattern is null, then
 expAffix is appended as a literal affix." fulltype="java.lang.String" type="String" />
					<param name="localized" comment="true if the appended pattern should contain localized
 pattern characters; otherwise, non-localized pattern chars are appended" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="private" name="appendAffix" fulltype="void" type="void">
				<comment>
					<description>Append an affix to the given StringBuffer, using quotes if
 there are special characters.  Single quotes themselves must be
 escaped in either case.</description>
				</comment>
				<params>
					<param name="buffer" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="affix" fulltype="java.lang.String" type="String" />
					<param name="localized" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="private" name="toPattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>Does the real work of generating a pattern.</description>
				</comment>
				<params>
					<param name="localized" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="applyPattern" fulltype="void" type="void">
				<comment>
					<description>Apply the given pattern to this Format object.  A pattern is a
 short-hand specification for the various formatting properties.
 These properties can also be changed individually through the
 various setter methods.
 &lt;p&gt;
 There is no limit to integer digits set
 by this routine, since that is the typical end-user desire;
 use setMaximumInteger if you want to set a real value.
 For negative numbers, use a second pattern, separated by a semicolon
 &lt;P&gt;Example &lt;code&gt;&quot;#,#00.0#&quot;&lt;/code&gt; -&gt; 1,234.56
 &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
 a maximum of 2 fraction digits.
 &lt;p&gt;Example: &lt;code&gt;&quot;#,#00.0#;(#,#00.0#)&quot;&lt;/code&gt; for negatives in
 parentheses.
 &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
 these are presumed to be set in the positive pattern.</description>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;pattern&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the given pattern is invalid.</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="applyLocalizedPattern" fulltype="void" type="void">
				<comment>
					<description>Apply the given pattern to this Format object.  The pattern
 is assumed to be in a localized notation. A pattern is a
 short-hand specification for the various formatting properties.
 These properties can also be changed individually through the
 various setter methods.
 &lt;p&gt;
 There is no limit to integer digits set
 by this routine, since that is the typical end-user desire;
 use setMaximumInteger if you want to set a real value.
 For negative numbers, use a second pattern, separated by a semicolon
 &lt;P&gt;Example &lt;code&gt;&quot;#,#00.0#&quot;&lt;/code&gt; -&gt; 1,234.56
 &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
 a maximum of 2 fraction digits.
 &lt;p&gt;Example: &lt;code&gt;&quot;#,#00.0#;(#,#00.0#)&quot;&lt;/code&gt; for negatives in
 parentheses.
 &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
 these are presumed to be set in the positive pattern.</description>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;pattern&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the given pattern is invalid.</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="applyPattern" fulltype="void" type="void">
				<comment>
					<description>Does the real work of applying a pattern.</description>
				</comment>
				<params>
					<param name="pattern" fulltype="java.lang.String" type="String" />
					<param name="localized" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="setMaximumIntegerDigits" fulltype="void" type="void">
				<comment>
					<description>Sets the maximum number of digits allowed in the integer portion of a
 number.
 For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
 &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
 309 is used. Negative input values are replaced with 0.</description>
					<attribute name="@see">
						<description>NumberFormat#setMaximumIntegerDigits</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="setMinimumIntegerDigits" fulltype="void" type="void">
				<comment>
					<description>Sets the minimum number of digits allowed in the integer portion of a
 number.
 For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
 &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
 309 is used. Negative input values are replaced with 0.</description>
					<attribute name="@see">
						<description>NumberFormat#setMinimumIntegerDigits</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="setMaximumFractionDigits" fulltype="void" type="void">
				<comment>
					<description>Sets the maximum number of digits allowed in the fraction portion of a
 number.
 For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
 &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
 340 is used. Negative input values are replaced with 0.</description>
					<attribute name="@see">
						<description>NumberFormat#setMaximumFractionDigits</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="setMinimumFractionDigits" fulltype="void" type="void">
				<comment>
					<description>Sets the minimum number of digits allowed in the fraction portion of a
 number.
 For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
 &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
 340 is used. Negative input values are replaced with 0.</description>
					<attribute name="@see">
						<description>NumberFormat#setMinimumFractionDigits</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getMaximumIntegerDigits" fulltype="int" type="int">
				<comment>
					<description>Gets the maximum number of digits allowed in the integer portion of a
 number.
 For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
 &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
 309 is used.</description>
					<attribute name="@see">
						<description>#setMaximumIntegerDigits</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getMinimumIntegerDigits" fulltype="int" type="int">
				<comment>
					<description>Gets the minimum number of digits allowed in the integer portion of a
 number.
 For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
 &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
 309 is used.</description>
					<attribute name="@see">
						<description>#setMinimumIntegerDigits</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getMaximumFractionDigits" fulltype="int" type="int">
				<comment>
					<description>Gets the maximum number of digits allowed in the fraction portion of a
 number.
 For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
 &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
 340 is used.</description>
					<attribute name="@see">
						<description>#setMaximumFractionDigits</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getMinimumFractionDigits" fulltype="int" type="int">
				<comment>
					<description>Gets the minimum number of digits allowed in the fraction portion of a
 number.
 For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
 &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
 340 is used.</description>
					<attribute name="@see">
						<description>#setMinimumFractionDigits</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getCurrency" returncomment="the currency used by this decimal format, or &lt;code&gt;null&lt;/code&gt;" fulltype="java.util.Currency" type="Currency">
				<comment>
					<description>Gets the currency used by this decimal format when formatting
 currency values.
 The currency is obtained by calling
 {@link DecimalFormatSymbols#getCurrency DecimalFormatSymbols.getCurrency}
 on this number format&apos;s symbols.</description>
					<attribute name="@return">
						<description>the currency used by this decimal format, or &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setCurrency" fulltype="void" type="void">
				<comment>
					<description>Sets the currency used by this number format when formatting
 currency values. This does not update the minimum or maximum
 number of fraction digits used by the number format.
 The currency is set by calling
 {@link DecimalFormatSymbols#setCurrency DecimalFormatSymbols.setCurrency}
 on this number format&apos;s symbols.</description>
					<attribute name="@param">
						<description>currency the new currency to be used by this decimal format</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;currency&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="currency" comment="the new currency to be used by this decimal format" fulltype="java.util.Currency" type="Currency" />
				</params>
			</method>
			<method visibility="public" name="getRoundingMode" returncomment="The &lt;code&gt;RoundingMode&lt;/code&gt; used for this DecimalFormat." fulltype="java.math.RoundingMode" type="RoundingMode">
				<comment>
					<description>Gets the {@link java.math.RoundingMode} used in this DecimalFormat.</description>
					<attribute name="@return">
						<description>The &lt;code&gt;RoundingMode&lt;/code&gt; used for this DecimalFormat.</description>
					</attribute>
					<attribute name="@see">
						<description>#setRoundingMode(RoundingMode)</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setRoundingMode" fulltype="void" type="void">
				<comment>
					<description>Sets the {@link java.math.RoundingMode} used in this DecimalFormat.</description>
					<attribute name="@param">
						<description>roundingMode The &lt;code&gt;RoundingMode&lt;/code&gt; to be used</description>
					</attribute>
					<attribute name="@see">
						<description>#getRoundingMode()</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;roundingMode&lt;/code&gt; is null.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="roundingMode" comment="The &lt;code&gt;RoundingMode&lt;/code&gt; to be used" fulltype="java.math.RoundingMode" type="RoundingMode" />
				</params>
			</method>
			<method visibility="package-private" name="adjustForCurrencyDefaultFractionDigits" fulltype="void" type="void">
				<comment>
					<description>Adjusts the minimum and maximum fraction digits to values that
 are reasonable for the currency&apos;s default fraction digits.</description>
				</comment>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<comment>
					<description>Reads the default serializable fields from the stream and performs
 validations and adjustments for older serialized versions. The
 validations and adjustments are:
 &lt;ol&gt;
 &lt;li&gt;
 Verify that the superclass&apos;s digit count fields correctly reflect
 the limits imposed on formatting numbers other than
 &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; objects. These
 limits are stored in the superclass for serialization compatibility
 with older versions, while the limits for &lt;code&gt;BigInteger&lt;/code&gt; and
 &lt;code&gt;BigDecimal&lt;/code&gt; objects are kept in this class.
 If, in the superclass, the minimum or maximum integer digit count is
 larger than &lt;code&gt;DOUBLE_INTEGER_DIGITS&lt;/code&gt; or if the minimum or
 maximum fraction digit count is larger than
 &lt;code&gt;DOUBLE_FRACTION_DIGITS&lt;/code&gt;, then the stream data is invalid
 and this method throws an &lt;code&gt;InvalidObjectException&lt;/code&gt;.
 &lt;li&gt;
 If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 4, initialize
 &lt;code&gt;roundingMode&lt;/code&gt; to {@link java.math.RoundingMode#HALF_EVEN
 RoundingMode.HALF_EVEN}.  This field is new with version 4.
 &lt;li&gt;
 If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 3, then call
 the setters for the minimum and maximum integer and fraction digits with
 the values of the corresponding superclass getters to initialize the
 fields in this class. The fields in this class are new with version 3.
 &lt;li&gt;
 If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1, indicating that
 the stream was written by JDK 1.1, initialize
 &lt;code&gt;useExponentialNotation&lt;/code&gt;
 to false, since it was not present in JDK 1.1.
 &lt;li&gt;
 Set &lt;code&gt;serialVersionOnStream&lt;/code&gt; to the maximum allowed value so
 that default serialization will work properly if this object is streamed
 out again.
 &lt;/ol&gt;

 &lt;p&gt;Stream versions older than 2 will not have the affix pattern variables
 &lt;code&gt;posPrefixPattern&lt;/code&gt; etc.  As a result, they will be initialized
 to &lt;code&gt;null&lt;/code&gt;, which means the affix strings will be taken as
 literal values.  This is exactly what we want, since that corresponds to
 the pre-version-2 behavior.</description>
				</comment>
				<params>
					<param name="stream" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Format" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.Format" fulltype="java.text.NumberFormat" type="NumberFormat">
		<comment>
			<description>&lt;code&gt;NumberFormat&lt;/code&gt; is the abstract base class for all number
 formats. This class provides the interface for formatting and parsing
 numbers. &lt;code&gt;NumberFormat&lt;/code&gt; also provides methods for determining
 which locales have number formats, and what their names are.

 &lt;p&gt;
 &lt;code&gt;NumberFormat&lt;/code&gt; helps you to format and parse numbers for any locale.
 Your code can be completely independent of the locale conventions for
 decimal points, thousands-separators, or even the particular decimal
 digits used, or whether the number format is even decimal.

 &lt;p&gt;
 To format a number for the current Locale, use one of the factory
 class methods:
 &lt;blockquote&gt;
 &lt;pre&gt;
  myString = NumberFormat.getInstance().format(myNumber);
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 If you are formatting multiple numbers, it is
 more efficient to get the format and use it multiple times so that
 the system doesn&apos;t have to fetch the information about the local
 language and country conventions multiple times.
 &lt;blockquote&gt;
 &lt;pre&gt;
 NumberFormat nf = NumberFormat.getInstance();
 for (int i = 0; i &lt; myNumber.length; ++i) {
     output.println(nf.format(myNumber[i]) + &quot;; &quot;);
 }
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 To format a number for a different Locale, specify it in the
 call to &lt;code&gt;getInstance&lt;/code&gt;.
 &lt;blockquote&gt;
 &lt;pre&gt;
 NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 You can also use a &lt;code&gt;NumberFormat&lt;/code&gt; to parse numbers:
 &lt;blockquote&gt;
 &lt;pre&gt;
 myNumber = nf.parse(myString);
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 Use &lt;code&gt;getInstance&lt;/code&gt; or &lt;code&gt;getNumberInstance&lt;/code&gt; to get the
 normal number format. Use &lt;code&gt;getIntegerInstance&lt;/code&gt; to get an
 integer number format. Use &lt;code&gt;getCurrencyInstance&lt;/code&gt; to get the
 currency number format. And use &lt;code&gt;getPercentInstance&lt;/code&gt; to get a
 format for displaying percentages. With this format, a fraction like
 0.53 is displayed as 53%.

 &lt;p&gt;
 You can also control the display of numbers with such methods as
 &lt;code&gt;setMinimumFractionDigits&lt;/code&gt;.
 If you want even more control over the format or parsing,
 or want to give your users more control,
 you can try casting the &lt;code&gt;NumberFormat&lt;/code&gt; you get from the factory methods
 to a &lt;code&gt;DecimalFormat&lt;/code&gt;. This will work for the vast majority
 of locales; just remember to put it in a &lt;code&gt;try&lt;/code&gt; block in case you
 encounter an unusual one.

 &lt;p&gt;
 NumberFormat and DecimalFormat are designed such that some controls
 work for formatting and others work for parsing.  The following is
 the detailed description for each these control methods,
 &lt;p&gt;
 setParseIntegerOnly : only affects parsing, e.g.
 if true,  &quot;3456.78&quot; -&gt; 3456 (and leaves the parse position just after index 6)
 if false, &quot;3456.78&quot; -&gt; 3456.78 (and leaves the parse position just after index 8)
 This is independent of formatting.  If you want to not show a decimal point
 where there might be no digits after the decimal point, use
 setDecimalSeparatorAlwaysShown.
 &lt;p&gt;
 setDecimalSeparatorAlwaysShown : only affects formatting, and only where
 there might be no digits after the decimal point, such as with a pattern
 like &quot;#,##0.##&quot;, e.g.,
 if true,  3456.00 -&gt; &quot;3,456.&quot;
 if false, 3456.00 -&gt; &quot;3456&quot;
 This is independent of parsing.  If you want parsing to stop at the decimal
 point, use setParseIntegerOnly.

 &lt;p&gt;
 You can also use forms of the &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt;
 methods with &lt;code&gt;ParsePosition&lt;/code&gt; and &lt;code&gt;FieldPosition&lt;/code&gt; to
 allow you to:
 &lt;ul&gt;
 &lt;li&gt; progressively parse through pieces of a string
 &lt;li&gt; align the decimal point and other areas
 &lt;/ul&gt;
 For example, you can align numbers in two ways:
 &lt;ol&gt;
 &lt;li&gt; If you are using a monospaced font with spacing for alignment,
      you can pass the &lt;code&gt;FieldPosition&lt;/code&gt; in your format call, with
      &lt;code&gt;field&lt;/code&gt; = &lt;code&gt;INTEGER_FIELD&lt;/code&gt;. On output,
      &lt;code&gt;getEndIndex&lt;/code&gt; will be set to the offset between the
      last character of the integer and the decimal. Add
      (desiredSpaceCount - getEndIndex) spaces at the front of the string.

 &lt;li&gt; If you are using proportional fonts,
      instead of padding with spaces, measure the width
      of the string in pixels from the start to &lt;code&gt;getEndIndex&lt;/code&gt;.
      Then move the pen by
      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.
      It also works where there is no decimal, but possibly additional
      characters at the end, e.g., with parentheses in negative
      numbers: &quot;(12)&quot; for -12.
 &lt;/ol&gt;

 &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;

 &lt;p&gt;
 Number formats are generally not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently, it must be synchronized
 externally.</description>
			<attribute name="@see">
				<description>DecimalFormat</description>
			</attribute>
			<attribute name="@see">
				<description>ChoiceFormat</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Davis</description>
			</attribute>
			<attribute name="@author">
				<description>Helena Shih</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="0" visibility="public" name="INTEGER_FIELD" constexpr="0" fulltype="int" type="int">
				<comment>
					<description>Field constant used to construct a FieldPosition object. Signifies that
 the position of the integer part of a formatted number should be returned.</description>
					<attribute name="@see">
						<description>java.text.FieldPosition</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="1" visibility="public" name="FRACTION_FIELD" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>Field constant used to construct a FieldPosition object. Signifies that
 the position of the fraction part of a formatted number should be returned.</description>
					<attribute name="@see">
						<description>java.text.FieldPosition</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="cachedLocaleData" fulltype="java.util.Hashtable" type="Hashtable">
				<comment>
					<description>Cache to hold the NumberPatterns of a Locale.</description>
				</comment>
			</field>
			<field final="true" static="true" const="0" visibility="private" name="NUMBERSTYLE" constexpr="0" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="private" name="CURRENCYSTYLE" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="2" visibility="private" name="PERCENTSTYLE" constexpr="2" fulltype="int" type="int" />
			<field final="true" static="true" const="3" visibility="private" name="SCIENTIFICSTYLE" constexpr="3" fulltype="int" type="int" />
			<field final="true" static="true" const="4" visibility="private" name="INTEGERSTYLE" constexpr="4" fulltype="int" type="int" />
			<field visibility="private" name="groupingUsed" fulltype="boolean" type="boolean">
				<comment>
					<description>True if the grouping (i.e. thousands) separator is used when
 formatting and parsing numbers.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#isGroupingUsed</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="maxIntegerDigits" fulltype="byte" type="byte">
				<comment>
					<description>The maximum number of digits allowed in the integer portion of a
 number.  &lt;code&gt;maxIntegerDigits&lt;/code&gt; must be greater than or equal to
 &lt;code&gt;minIntegerDigits&lt;/code&gt;.
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
 compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
 &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;maximumIntegerDigits&lt;/code&gt; is used instead.
 When writing to a stream, &lt;code&gt;maxIntegerDigits&lt;/code&gt; is set to
 &lt;code&gt;maximumIntegerDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,
 whichever is smaller.  When reading from a stream, this field is used
 only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getMaximumIntegerDigits</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="minIntegerDigits" fulltype="byte" type="byte">
				<comment>
					<description>The minimum number of digits allowed in the integer portion of a
 number.  &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to
 &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
 compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
 &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;minimumIntegerDigits&lt;/code&gt; is used instead.
 When writing to a stream, &lt;code&gt;minIntegerDigits&lt;/code&gt; is set to
 &lt;code&gt;minimumIntegerDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,
 whichever is smaller.  When reading from a stream, this field is used
 only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getMinimumIntegerDigits</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="maxFractionDigits" fulltype="byte" type="byte">
				<comment>
					<description>The maximum number of digits allowed in the fractional portion of a
 number.  &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to
 &lt;code&gt;minimumFractionDigits&lt;/code&gt;.
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
 compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
 &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;maximumFractionDigits&lt;/code&gt; is used instead.
 When writing to a stream, &lt;code&gt;maxFractionDigits&lt;/code&gt; is set to
 &lt;code&gt;maximumFractionDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,
 whichever is smaller.  When reading from a stream, this field is used
 only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getMaximumFractionDigits</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="minFractionDigits" fulltype="byte" type="byte">
				<comment>
					<description>The minimum number of digits allowed in the fractional portion of a
 number.  &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to
 &lt;code&gt;maximumFractionDigits&lt;/code&gt;.
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
 compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
 &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;minimumFractionDigits&lt;/code&gt; is used instead.
 When writing to a stream, &lt;code&gt;minFractionDigits&lt;/code&gt; is set to
 &lt;code&gt;minimumFractionDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,
 whichever is smaller.  When reading from a stream, this field is used
 only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getMinimumFractionDigits</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="parseIntegerOnly" fulltype="boolean" type="boolean">
				<comment>
					<description>True if this format will parse numbers as integers only.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#isParseIntegerOnly</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="maximumIntegerDigits" fulltype="int" type="int">
				<comment>
					<description>The maximum number of digits allowed in the integer portion of a
 number.  &lt;code&gt;maximumIntegerDigits&lt;/code&gt; must be greater than or equal to
 &lt;code&gt;minimumIntegerDigits&lt;/code&gt;.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
					<attribute name="@see">
						<description>#getMaximumIntegerDigits</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="minimumIntegerDigits" fulltype="int" type="int">
				<comment>
					<description>The minimum number of digits allowed in the integer portion of a
 number.  &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to
 &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
					<attribute name="@see">
						<description>#getMinimumIntegerDigits</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="maximumFractionDigits" fulltype="int" type="int">
				<comment>
					<description>The maximum number of digits allowed in the fractional portion of a
 number.  &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to
 &lt;code&gt;minimumFractionDigits&lt;/code&gt;.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
					<attribute name="@see">
						<description>#getMaximumFractionDigits</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="minimumFractionDigits" fulltype="int" type="int">
				<comment>
					<description>The minimum number of digits allowed in the fractional portion of a
 number.  &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to
 &lt;code&gt;maximumFractionDigits&lt;/code&gt;.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
					<attribute name="@see">
						<description>#getMinimumFractionDigits</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="1" visibility="package-private" name="currentSerialVersion" constexpr="1" fulltype="int" type="int" />
			<field visibility="private" name="serialVersionOnStream" fulltype="int" type="int">
				<comment>
					<description>Describes the version of &lt;code&gt;NumberFormat&lt;/code&gt; present on the stream.
 Possible values are:
 &lt;ul&gt;
 &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (or uninitialized): the JDK 1.1 version of the stream format.
     In this version, the &lt;code&gt;int&lt;/code&gt; fields such as
     &lt;code&gt;maximumIntegerDigits&lt;/code&gt; were not present, and the &lt;code&gt;byte&lt;/code&gt;
     fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; are used instead.

 &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: the 1.2 version of the stream format.  The values of the
     &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; are ignored,
     and the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;
     are used instead.
 &lt;/ul&gt;
 When streaming out a &lt;code&gt;NumberFormat&lt;/code&gt;, the most recent format
 (corresponding to the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;)
 is always written.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="-2308460125733713944" visibility="package-private" name="serialVersionUID" constexpr="-2308460125733713944L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="protected" name="NumberFormat">
				<comment>
					<description>Sole constructor.  (For invocation by subclass constructors, typically
 implicit.)</description>
				</comment>
			</constructor>
			<method visibility="public" name="format" returncomment="the value passed in as &lt;code&gt;toAppendTo&lt;/code&gt;" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Formats a number and appends the resulting text to the given string
 buffer.
 The number can be of any subclass of {@link java.lang.Number}.
 &lt;p&gt;
 This implementation extracts the number&apos;s value using
 {@link java.lang.Number#longValue()} for all integral type values that
 can be converted to &lt;code&gt;long&lt;/code&gt; without loss of information,
 including &lt;code&gt;BigInteger&lt;/code&gt; values with a
 {@link java.math.BigInteger#bitLength() bit length} of less than 64,
 and {@link java.lang.Number#doubleValue()} for all other types. It
 then calls
 {@link #format(long,java.lang.StringBuffer,java.text.FieldPosition)}
 or {@link #format(double,java.lang.StringBuffer,java.text.FieldPosition)}.
 This may result in loss of magnitude information and precision for
 &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; values.</description>
					<attribute name="@param">
						<description>number     the number to format</description>
					</attribute>
					<attribute name="@param">
						<description>toAppendTo the &lt;code&gt;StringBuffer&lt;/code&gt; to which the formatted
                   text is to be appended</description>
					</attribute>
					<attribute name="@param">
						<description>pos        On input: an alignment field, if desired.
                   On output: the offsets of the alignment field.</description>
					</attribute>
					<attribute name="@return">
						<description>the value passed in as &lt;code&gt;toAppendTo&lt;/code&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;number&lt;/code&gt; is
                   null or not an instance of &lt;code&gt;Number&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or
                   &lt;code&gt;pos&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                   mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.FieldPosition</description>
					</attribute>
				</comment>
				<params>
					<param name="number" comment="the number to format" fulltype="java.lang.Object" type="Object" />
					<param name="toAppendTo" comment="the &lt;code&gt;StringBuffer&lt;/code&gt; to which the formatted
                   text is to be appended" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="pos" comment="On input: an alignment field, if desired.
                   On output: the offsets of the alignment field." fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method final="true" visibility="public" name="parseObject" returncomment="A &lt;code&gt;Number&lt;/code&gt; parsed from the string. In case of
         error, returns null." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Parses text from a string to produce a &lt;code&gt;Number&lt;/code&gt;.
 &lt;p&gt;
 The method attempts to parse text starting at the index given by
 &lt;code&gt;pos&lt;/code&gt;.
 If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
 to the index after the last character used (parsing does not necessarily
 use all characters up to the end of the string), and the parsed
 number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
 indicate the starting point for the next call to this method.
 If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
 changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
 the character where the error occurred, and null is returned.
 &lt;p&gt;
 See the {@link #parse(String, ParsePosition)} method for more information
 on number parsing.</description>
					<attribute name="@param">
						<description>source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</description>
					</attribute>
					<attribute name="@param">
						<description>pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
            index information as described above.</description>
					</attribute>
					<attribute name="@return">
						<description>A &lt;code&gt;Number&lt;/code&gt; parsed from the string. In case of
         error, returns null.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;pos&lt;/code&gt; is null.</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed." fulltype="java.lang.String" type="String" />
					<param name="pos" comment="A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
            index information as described above." fulltype="java.text.ParsePosition" type="ParsePosition" />
				</params>
			</method>
			<method final="true" visibility="public" name="format" fulltype="java.lang.String" type="String">
				<comment>
					<description>Specialization of format.</description>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                   mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Format#format</description>
					</attribute>
				</comment>
				<params>
					<param name="number" fulltype="double" type="double" />
				</params>
			</method>
			<method final="true" visibility="public" name="format" fulltype="java.lang.String" type="String">
				<comment>
					<description>Specialization of format.</description>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                   mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Format#format</description>
					</attribute>
				</comment>
				<params>
					<param name="number" fulltype="long" type="long" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="format" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Specialization of format.</description>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                   mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Format#format</description>
					</attribute>
				</comment>
				<params>
					<param name="number" fulltype="double" type="double" />
					<param name="toAppendTo" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="pos" fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="format" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Specialization of format.</description>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
                   mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Format#format</description>
					</attribute>
				</comment>
				<params>
					<param name="number" fulltype="long" type="long" />
					<param name="toAppendTo" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="pos" fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="parse" fulltype="java.lang.Number" type="Number">
				<comment>
					<description>Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,
 Long.MAX_VALUE] and with no decimals), otherwise a Double.
 If IntegerOnly is set, will stop at a decimal
 point (or equivalent; e.g., for rational numbers &quot;1 2/3&quot;, will stop
 after the 1).
 Does not throw an exception; if no object can be parsed, index is
 unchanged!</description>
					<attribute name="@see">
						<description>java.text.NumberFormat#isParseIntegerOnly</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Format#parseObject</description>
					</attribute>
				</comment>
				<params>
					<param name="source" fulltype="java.lang.String" type="String" />
					<param name="parsePosition" fulltype="java.text.ParsePosition" type="ParsePosition" />
				</params>
			</method>
			<method visibility="public" name="parse" returncomment="A &lt;code&gt;Number&lt;/code&gt; parsed from the string." fulltype="java.lang.Number" type="Number">
				<comment>
					<description>Parses text from the beginning of the given string to produce a number.
 The method may not use the entire text of the given string.
 &lt;p&gt;
 See the {@link #parse(String, ParsePosition)} method for more information
 on number parsing.</description>
					<attribute name="@param">
						<description>source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</description>
					</attribute>
					<attribute name="@return">
						<description>A &lt;code&gt;Number&lt;/code&gt; parsed from the string.</description>
					</attribute>
					<attribute name="@exception">
						<description>ParseException if the beginning of the specified string
            cannot be parsed.</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if the beginning of the specified string
            cannot be parsed." fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
			<method visibility="public" name="isParseIntegerOnly" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if this format will parse numbers as integers only.
 For example in the English locale, with ParseIntegerOnly true, the
 string &quot;1234.&quot; would be parsed as the integer value 1234 and parsing
 would stop at the &quot;.&quot; character.  Of course, the exact format accepted
 by the parse operation is locale dependant and determined by sub-classes
 of NumberFormat.</description>
				</comment>
			</method>
			<method visibility="public" name="setParseIntegerOnly" fulltype="void" type="void">
				<comment>
					<description>Sets whether or not numbers should be parsed as integers only.</description>
					<attribute name="@see">
						<description>#isParseIntegerOnly</description>
					</attribute>
				</comment>
				<params>
					<param name="value" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="getInstance" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a general-purpose number format for the current default locale.
 This is the same as calling
 {@link #getNumberInstance() getNumberInstance()}.</description>
				</comment>
			</method>
			<method static="true" visibility="public" name="getInstance" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a general-purpose number format for the specified locale.
 This is the same as calling
 {@link #getNumberInstance(java.util.Locale) getNumberInstance(inLocale)}.</description>
				</comment>
				<params>
					<param name="inLocale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="getNumberInstance" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a general-purpose number format for the current default locale.</description>
				</comment>
			</method>
			<method static="true" visibility="public" name="getNumberInstance" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a general-purpose number format for the specified locale.</description>
				</comment>
				<params>
					<param name="inLocale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="getIntegerInstance" returncomment="a number format for integer values" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns an integer number format for the current default locale. The
 returned number format is configured to round floating point numbers
 to the nearest integer using half-even rounding (see {@link
 java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}) for formatting,
 and to parse only the integer part of an input string (see {@link
 #isParseIntegerOnly isParseIntegerOnly}).</description>
					<attribute name="@see">
						<description>#getRoundingMode()</description>
					</attribute>
					<attribute name="@return">
						<description>a number format for integer values</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="public" name="getIntegerInstance" returncomment="a number format for integer values" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns an integer number format for the specified locale. The
 returned number format is configured to round floating point numbers
 to the nearest integer using half-even rounding (see {@link
 java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}) for formatting,
 and to parse only the integer part of an input string (see {@link
 #isParseIntegerOnly isParseIntegerOnly}).</description>
					<attribute name="@see">
						<description>#getRoundingMode()</description>
					</attribute>
					<attribute name="@return">
						<description>a number format for integer values</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="inLocale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="getCurrencyInstance" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a currency format for the current default locale.</description>
				</comment>
			</method>
			<method static="true" visibility="public" name="getCurrencyInstance" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a currency format for the specified locale.</description>
				</comment>
				<params>
					<param name="inLocale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="getPercentInstance" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a percentage format for the current default locale.</description>
				</comment>
			</method>
			<method static="true" visibility="public" name="getPercentInstance" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a percentage format for the specified locale.</description>
				</comment>
				<params>
					<param name="inLocale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method final="true" static="true" visibility="package-private" name="getScientificInstance" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a scientific format for the current default locale.</description>
				</comment>
			</method>
			<method static="true" visibility="package-private" name="getScientificInstance" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Returns a scientific format for the specified locale.</description>
				</comment>
				<params>
					<param name="inLocale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method static="true" visibility="public" name="getAvailableLocales" returncomment="An array of locales for which localized
         &lt;code&gt;NumberFormat&lt;/code&gt; instances are available." fulltype="java.util.Locale[]" type="Locale">
				<comment>
					<description>Returns an array of all locales for which the
 &lt;code&gt;get*Instance&lt;/code&gt; methods of this class can return
 localized instances.
 The returned array represents the union of locales supported by the Java
 runtime and by installed
 {@link java.text.spi.NumberFormatProvider NumberFormatProvider} implementations.
 It must contain at least a &lt;code&gt;Locale&lt;/code&gt; instance equal to
 {@link java.util.Locale#US Locale.US}.</description>
					<attribute name="@return">
						<description>An array of locales for which localized
         &lt;code&gt;NumberFormat&lt;/code&gt; instances are available.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Overrides hashCode</description>
				</comment>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Overrides equals</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="clone" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Overrides Cloneable</description>
				</comment>
			</method>
			<method visibility="public" name="isGroupingUsed" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if grouping is used in this format. For example, in the
 English locale, with grouping on, the number 1234567 might be formatted
 as &quot;1,234,567&quot;. The grouping separator as well as the size of each group
 is locale dependant and is determined by sub-classes of NumberFormat.</description>
					<attribute name="@see">
						<description>#setGroupingUsed</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setGroupingUsed" fulltype="void" type="void">
				<comment>
					<description>Set whether or not grouping will be used in this format.</description>
					<attribute name="@see">
						<description>#isGroupingUsed</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="getMaximumIntegerDigits" fulltype="int" type="int">
				<comment>
					<description>Returns the maximum number of digits allowed in the integer portion of a
 number.</description>
					<attribute name="@see">
						<description>#setMaximumIntegerDigits</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setMaximumIntegerDigits" fulltype="void" type="void">
				<comment>
					<description>Sets the maximum number of digits allowed in the integer portion of a
 number. maximumIntegerDigits must be &gt;= minimumIntegerDigits.  If the
 new value for maximumIntegerDigits is less than the current value
 of minimumIntegerDigits, then minimumIntegerDigits will also be set to
 the new value.</description>
					<attribute name="@param">
						<description>newValue the maximum number of integer digits to be shown; if
 less than zero, then zero is used. The concrete subclass may enforce an
 upper limit to this value appropriate to the numeric type being formatted.</description>
					</attribute>
					<attribute name="@see">
						<description>#getMaximumIntegerDigits</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" comment="the maximum number of integer digits to be shown; if
 less than zero, then zero is used. The concrete subclass may enforce an
 upper limit to this value appropriate to the numeric type being formatted." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getMinimumIntegerDigits" fulltype="int" type="int">
				<comment>
					<description>Returns the minimum number of digits allowed in the integer portion of a
 number.</description>
					<attribute name="@see">
						<description>#setMinimumIntegerDigits</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setMinimumIntegerDigits" fulltype="void" type="void">
				<comment>
					<description>Sets the minimum number of digits allowed in the integer portion of a
 number. minimumIntegerDigits must be &lt;= maximumIntegerDigits.  If the
 new value for minimumIntegerDigits exceeds the current value
 of maximumIntegerDigits, then maximumIntegerDigits will also be set to
 the new value</description>
					<attribute name="@param">
						<description>newValue the minimum number of integer digits to be shown; if
 less than zero, then zero is used. The concrete subclass may enforce an
 upper limit to this value appropriate to the numeric type being formatted.</description>
					</attribute>
					<attribute name="@see">
						<description>#getMinimumIntegerDigits</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" comment="the minimum number of integer digits to be shown; if
 less than zero, then zero is used. The concrete subclass may enforce an
 upper limit to this value appropriate to the numeric type being formatted." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getMaximumFractionDigits" fulltype="int" type="int">
				<comment>
					<description>Returns the maximum number of digits allowed in the fraction portion of a
 number.</description>
					<attribute name="@see">
						<description>#setMaximumFractionDigits</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setMaximumFractionDigits" fulltype="void" type="void">
				<comment>
					<description>Sets the maximum number of digits allowed in the fraction portion of a
 number. maximumFractionDigits must be &gt;= minimumFractionDigits.  If the
 new value for maximumFractionDigits is less than the current value
 of minimumFractionDigits, then minimumFractionDigits will also be set to
 the new value.</description>
					<attribute name="@param">
						<description>newValue the maximum number of fraction digits to be shown; if
 less than zero, then zero is used. The concrete subclass may enforce an
 upper limit to this value appropriate to the numeric type being formatted.</description>
					</attribute>
					<attribute name="@see">
						<description>#getMaximumFractionDigits</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" comment="the maximum number of fraction digits to be shown; if
 less than zero, then zero is used. The concrete subclass may enforce an
 upper limit to this value appropriate to the numeric type being formatted." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getMinimumFractionDigits" fulltype="int" type="int">
				<comment>
					<description>Returns the minimum number of digits allowed in the fraction portion of a
 number.</description>
					<attribute name="@see">
						<description>#setMinimumFractionDigits</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setMinimumFractionDigits" fulltype="void" type="void">
				<comment>
					<description>Sets the minimum number of digits allowed in the fraction portion of a
 number. minimumFractionDigits must be &lt;= maximumFractionDigits.  If the
 new value for minimumFractionDigits exceeds the current value
 of maximumFractionDigits, then maximumIntegerDigits will also be set to
 the new value</description>
					<attribute name="@param">
						<description>newValue the minimum number of fraction digits to be shown; if
 less than zero, then zero is used. The concrete subclass may enforce an
 upper limit to this value appropriate to the numeric type being formatted.</description>
					</attribute>
					<attribute name="@see">
						<description>#getMinimumFractionDigits</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" comment="the minimum number of fraction digits to be shown; if
 less than zero, then zero is used. The concrete subclass may enforce an
 upper limit to this value appropriate to the numeric type being formatted." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getCurrency" returncomment="the currency used by this number format, or &lt;code&gt;null&lt;/code&gt;" fulltype="java.util.Currency" type="Currency">
				<comment>
					<description>Gets the currency used by this number format when formatting
 currency values. The initial value is derived in a locale dependent
 way. The returned value may be null if no valid
 currency could be determined and no currency has been set using
 {@link #setCurrency(java.util.Currency) setCurrency}.
 &lt;p&gt;
 The default implementation throws
 &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the currency used by this number format, or &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>UnsupportedOperationException if the number format class
 doesn&apos;t implement currency formatting</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setCurrency" fulltype="void" type="void">
				<comment>
					<description>Sets the currency used by this number format when formatting
 currency values. This does not update the minimum or maximum
 number of fraction digits used by the number format.
 &lt;p&gt;
 The default implementation throws
 &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>currency the new currency to be used by this number format</description>
					</attribute>
					<attribute name="@exception">
						<description>UnsupportedOperationException if the number format class
 doesn&apos;t implement currency formatting</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;currency&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="currency" comment="the new currency to be used by this number format" fulltype="java.util.Currency" type="Currency" />
				</params>
			</method>
			<method visibility="public" name="getRoundingMode" returncomment="The &lt;code&gt;RoundingMode&lt;/code&gt; used for this NumberFormat." fulltype="java.math.RoundingMode" type="RoundingMode">
				<comment>
					<description>Gets the {@link java.math.RoundingMode} used in this NumberFormat.
 The default implementation of this method in NumberFormat
 always throws {@link java.lang.UnsupportedOperationException}.
 Subclasses which handle different rounding modes should override
 this method.</description>
					<attribute name="@exception">
						<description>UnsupportedOperationException The default implementation
     always throws this exception</description>
					</attribute>
					<attribute name="@return">
						<description>The &lt;code&gt;RoundingMode&lt;/code&gt; used for this NumberFormat.</description>
					</attribute>
					<attribute name="@see">
						<description>#setRoundingMode(RoundingMode)</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setRoundingMode" fulltype="void" type="void">
				<comment>
					<description>Sets the {@link java.math.RoundingMode} used in this NumberFormat.
 The default implementation of this method in NumberFormat always
 throws {@link java.lang.UnsupportedOperationException}.
 Subclasses which handle different rounding modes should override
 this method.</description>
					<attribute name="@exception">
						<description>UnsupportedOperationException The default implementation
     always throws this exception</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;roundingMode&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@param">
						<description>roundingMode The &lt;code&gt;RoundingMode&lt;/code&gt; to be used</description>
					</attribute>
					<attribute name="@see">
						<description>#getRoundingMode()</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="roundingMode" comment="The &lt;code&gt;RoundingMode&lt;/code&gt; to be used" fulltype="java.math.RoundingMode" type="RoundingMode" />
				</params>
			</method>
			<method static="true" visibility="private" name="getInstance" fulltype="java.text.NumberFormat" type="NumberFormat">
				<params>
					<param name="desiredLocale" fulltype="java.util.Locale" type="Locale" />
					<param name="choice" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<comment>
					<description>First, read in the default serializable data.

 Then, if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1, indicating that
 the stream was written by JDK 1.1,
 set the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;
 to be equal to the &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt;,
 since the &lt;code&gt;int&lt;/code&gt; fields were not present in JDK 1.1.
 Finally, set serialVersionOnStream back to the maximum allowed value so that
 default serialization will work properly if this object is streamed out again.

 &lt;p&gt;If &lt;code&gt;minimumIntegerDigits&lt;/code&gt; is greater than
 &lt;code&gt;maximumIntegerDigits&lt;/code&gt; or &lt;code&gt;minimumFractionDigits&lt;/code&gt;
 is greater than &lt;code&gt;maximumFractionDigits&lt;/code&gt;, then the stream data
 is invalid and this method throws an &lt;code&gt;InvalidObjectException&lt;/code&gt;.
 In addition, if any of these values is negative, then this method throws
 an &lt;code&gt;InvalidObjectException&lt;/code&gt;.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="stream" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeObject" fulltype="void" type="void">
				<comment>
					<description>Write out the default serializable data, after first setting
 the &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; to be
 equal to the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;
 (or to &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;, whichever is smaller), for compatibility
 with the JDK 1.1 version of the stream format.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="stream" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
		<jelclass superclass="Format.Field" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.Format.Field" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
			<comment>
				<description>Defines constants that are used as attribute keys in the
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
 from &lt;code&gt;NumberFormat.formatToCharacterIterator&lt;/code&gt; and as
 field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.</description>
				<attribute name="@since">
					<description>1.4</description>
				</attribute>
			</comment>
			<fields>
				<field final="true" static="true" const="7494728892700160890" visibility="private" name="serialVersionUID" constexpr="7494728892700160890L" fulltype="long" type="long" />
				<field final="true" static="true" visibility="private" name="instanceMap" fulltype="java.util.Map" type="Map" />
				<field final="true" static="true" visibility="public" name="INTEGER" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
					<comment>
						<description>Constant identifying the integer field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="FRACTION" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
					<comment>
						<description>Constant identifying the fraction field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="EXPONENT" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
					<comment>
						<description>Constant identifying the exponent field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="DECIMAL_SEPARATOR" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
					<comment>
						<description>Constant identifying the decimal separator field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="SIGN" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
					<comment>
						<description>Constant identifying the sign field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="GROUPING_SEPARATOR" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
					<comment>
						<description>Constant identifying the grouping separator field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="EXPONENT_SYMBOL" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
					<comment>
						<description>Constant identifying the exponent symbol field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="PERCENT" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
					<comment>
						<description>Constant identifying the percent field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="PERMILLE" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
					<comment>
						<description>Constant identifying the permille field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="CURRENCY" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
					<comment>
						<description>Constant identifying the currency field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="EXPONENT_SIGN" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
					<comment>
						<description>Constant identifying the exponent sign field.</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="protected" name="NumberFormat.Field">
					<comment>
						<description>Creates a Field instance with the specified
 name.</description>
						<attribute name="@param">
							<description>name Name of the attribute</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="Name of the attribute" fulltype="java.lang.String" type="String" />
					</params>
				</constructor>
				<method visibility="protected" name="readResolve" returncomment="resolved NumberFormat.Field constant" fulltype="java.lang.Object" type="Object">
					<comment>
						<description>Resolves instances being deserialized to the predefined constants.</description>
						<attribute name="@throws">
							<description>InvalidObjectException if the constant could not be resolved.</description>
						</attribute>
						<attribute name="@return">
							<description>resolved NumberFormat.Field constant</description>
						</attribute>
					</comment>
					<exceptions>
						<exception comment="if the constant could not be resolved." fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
					</exceptions>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.NumberFormat.NumberFormatGetter" type="NumberFormat.NumberFormatGetter">
			<implements>
				<interface fulltype="sun.util.LocaleServiceProviderPool.LocalizedObjectGetter" type="LocaleServiceProviderPool.LocalizedObjectGetter" />
			</implements>
			<comment>
				<description>Obtains a NumberFormat instance from a NumberFormatProvider implementation.</description>
			</comment>
			<fields>
				<field final="true" static="true" visibility="private" name="INSTANCE" fulltype="java.text.NumberFormat.NumberFormatGetter" type="NumberFormat.NumberFormatGetter" />
			</fields>
			<methods>
				<constructor visibility="private" name="NumberFormat.NumberFormatGetter" />
				<method visibility="public" name="getObject" fulltype="java.text.NumberFormat" type="NumberFormat">
					<params>
						<param name="numberFormatProvider" fulltype="java.text.spi.NumberFormatProvider" type="NumberFormatProvider" />
						<param name="locale" fulltype="java.util.Locale" type="Locale" />
						<param name="key" fulltype="java.lang.String" type="String" />
						<param name="params" fulltype="java.lang.Object[]" type="Object" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Format.Field" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.Format.Field" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
		<comment>
			<description>Defines constants that are used as attribute keys in the
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
 from &lt;code&gt;NumberFormat.formatToCharacterIterator&lt;/code&gt; and as
 field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.</description>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="7494728892700160890" visibility="private" name="serialVersionUID" constexpr="7494728892700160890L" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="instanceMap" fulltype="java.util.Map" type="Map" />
			<field final="true" static="true" visibility="public" name="INTEGER" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
				<comment>
					<description>Constant identifying the integer field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="FRACTION" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
				<comment>
					<description>Constant identifying the fraction field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="EXPONENT" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
				<comment>
					<description>Constant identifying the exponent field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="DECIMAL_SEPARATOR" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
				<comment>
					<description>Constant identifying the decimal separator field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="SIGN" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
				<comment>
					<description>Constant identifying the sign field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="GROUPING_SEPARATOR" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
				<comment>
					<description>Constant identifying the grouping separator field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="EXPONENT_SYMBOL" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
				<comment>
					<description>Constant identifying the exponent symbol field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="PERCENT" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
				<comment>
					<description>Constant identifying the percent field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="PERMILLE" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
				<comment>
					<description>Constant identifying the permille field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="CURRENCY" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
				<comment>
					<description>Constant identifying the currency field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="EXPONENT_SIGN" fulltype="java.text.NumberFormat.Field" type="NumberFormat.Field">
				<comment>
					<description>Constant identifying the exponent sign field.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="protected" name="NumberFormat.Field">
				<comment>
					<description>Creates a Field instance with the specified
 name.</description>
					<attribute name="@param">
						<description>name Name of the attribute</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="Name of the attribute" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method visibility="protected" name="readResolve" returncomment="resolved NumberFormat.Field constant" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Resolves instances being deserialized to the predefined constants.</description>
					<attribute name="@throws">
						<description>InvalidObjectException if the constant could not be resolved.</description>
					</attribute>
					<attribute name="@return">
						<description>resolved NumberFormat.Field constant</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the constant could not be resolved." fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.NumberFormat.NumberFormatGetter" type="NumberFormat.NumberFormatGetter">
		<implements>
			<interface fulltype="sun.util.LocaleServiceProviderPool.LocalizedObjectGetter" type="LocaleServiceProviderPool.LocalizedObjectGetter" />
		</implements>
		<comment>
			<description>Obtains a NumberFormat instance from a NumberFormatProvider implementation.</description>
		</comment>
		<fields>
			<field final="true" static="true" visibility="private" name="INSTANCE" fulltype="java.text.NumberFormat.NumberFormatGetter" type="NumberFormat.NumberFormatGetter" />
		</fields>
		<methods>
			<constructor visibility="private" name="NumberFormat.NumberFormatGetter" />
			<method visibility="public" name="getObject" fulltype="java.text.NumberFormat" type="NumberFormat">
				<params>
					<param name="numberFormatProvider" fulltype="java.text.spi.NumberFormatProvider" type="NumberFormatProvider" />
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
					<param name="key" fulltype="java.lang.String" type="String" />
					<param name="params" fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="FieldPosition" visibility="package-private" package="java.text" superclassfulltype="java.text.FieldPosition" fulltype="java.text.DontCareFieldPosition" type="DontCareFieldPosition">
		<comment>
			<description>DontCareFieldPosition defines no-op FieldDelegate. Its
 singleton is used for the format methods that don&apos;t take a
 FieldPosition.</description>
		</comment>
		<fields>
			<field final="true" static="true" visibility="package-private" name="INSTANCE" fulltype="java.text.FieldPosition" type="FieldPosition" />
			<field final="true" visibility="private" name="noDelegate" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
		</fields>
		<methods>
			<constructor visibility="private" name="DontCareFieldPosition" />
			<method visibility="package-private" name="getFieldDelegate" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.PatternEntry" type="PatternEntry">
		<comment>
			<description>Utility class for normalizing and merging patterns for collation.
 This is to be used with MergeCollation for adding patterns to an
 existing rule table.</description>
			<attribute name="@see">
				<description>MergeCollation</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Davis, Helena Shih</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-2" visibility="package-private" name="RESET" constexpr="-2" fulltype="int" type="int" />
			<field final="true" static="true" const="-1" visibility="package-private" name="UNSET" constexpr="-1" fulltype="int" type="int" />
			<field visibility="package-private" name="strength" fulltype="int" type="int" />
			<field visibility="package-private" name="chars" fulltype="java.lang.String" type="String" />
			<field visibility="package-private" name="extension" fulltype="java.lang.String" type="String" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="PatternEntry">
				<params>
					<param name="strength" fulltype="int" type="int" />
					<param name="chars" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="extension" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</constructor>
			<method visibility="public" name="appendQuotedExtension" fulltype="void" type="void">
				<comment>
					<description>Gets the current extension, quoted</description>
				</comment>
				<params>
					<param name="toAddTo" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
			<method visibility="public" name="appendQuotedChars" fulltype="void" type="void">
				<comment>
					<description>Gets the current chars, quoted</description>
				</comment>
				<params>
					<param name="toAddTo" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>WARNING this is used for searching in a Vector.
 Because Vector.indexOf doesn&apos;t take a comparator,
 this method is ill-defined and ignores strength.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int" />
			<method visibility="public" name="toString" fulltype="java.lang.String" type="String">
				<comment>
					<description>For debugging.</description>
				</comment>
			</method>
			<method final="true" visibility="package-private" name="getStrength" fulltype="int" type="int">
				<comment>
					<description>Gets the strength of the entry.</description>
				</comment>
			</method>
			<method final="true" visibility="package-private" name="getExtension" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the expanding characters of the entry.</description>
				</comment>
			</method>
			<method final="true" visibility="package-private" name="getChars" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the core characters of the entry.</description>
				</comment>
			</method>
			<method visibility="package-private" name="addToBuffer" fulltype="void" type="void">
				<params>
					<param name="toAddTo" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="showExtension" fulltype="boolean" type="boolean" />
					<param name="showWhiteSpace" fulltype="boolean" type="boolean" />
					<param name="lastEntry" fulltype="java.text.PatternEntry" type="PatternEntry" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="appendQuoted" fulltype="void" type="void">
				<params>
					<param name="chars" fulltype="java.lang.String" type="String" />
					<param name="toAddTo" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="isSpecialChar" fulltype="boolean" type="boolean">
				<params>
					<param name="ch" fulltype="char" type="char" />
				</params>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.PatternEntry.Parser" type="PatternEntry.Parser">
			<fields>
				<field visibility="private" name="pattern" fulltype="java.lang.String" type="String" />
				<field visibility="private" name="i" fulltype="int" type="int" />
				<field visibility="private" name="newChars" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				<field visibility="private" name="newExtension" fulltype="java.lang.StringBuffer" type="StringBuffer" />
			</fields>
			<methods>
				<constructor visibility="public" name="PatternEntry.Parser">
					<params>
						<param name="pattern" fulltype="java.lang.String" type="String" />
					</params>
				</constructor>
				<method visibility="public" name="next" fulltype="java.text.PatternEntry" type="PatternEntry">
					<exceptions>
						<exception fulltype="java.text.ParseException" type="ParseException" />
					</exceptions>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.PatternEntry.Parser" type="PatternEntry.Parser">
		<fields>
			<field visibility="private" name="pattern" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="i" fulltype="int" type="int" />
			<field visibility="private" name="newChars" fulltype="java.lang.StringBuffer" type="StringBuffer" />
			<field visibility="private" name="newExtension" fulltype="java.lang.StringBuffer" type="StringBuffer" />
		</fields>
		<methods>
			<constructor visibility="public" name="PatternEntry.Parser">
				<params>
					<param name="pattern" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method visibility="public" name="next" fulltype="java.text.PatternEntry" type="PatternEntry">
				<exceptions>
					<exception fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="public" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.StringCharacterIterator" type="StringCharacterIterator">
		<implements>
			<interface fulltype="java.text.CharacterIterator" type="CharacterIterator" />
		</implements>
		<comment>
			<description>&lt;code&gt;StringCharacterIterator&lt;/code&gt; implements the
 &lt;code&gt;CharacterIterator&lt;/code&gt; protocol for a &lt;code&gt;String&lt;/code&gt;.
 The &lt;code&gt;StringCharacterIterator&lt;/code&gt; class iterates over the
 entire &lt;code&gt;String&lt;/code&gt;.</description>
			<attribute name="@see">
				<description>CharacterIterator</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="text" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="begin" fulltype="int" type="int" />
			<field visibility="private" name="end" fulltype="int" type="int" />
			<field visibility="private" name="pos" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="public" name="StringCharacterIterator">
				<comment>
					<description>Constructs an iterator with an initial index of 0.</description>
				</comment>
				<params>
					<param name="text" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="StringCharacterIterator">
				<comment>
					<description>Constructs an iterator with the specified initial index.</description>
					<attribute name="@param">
						<description>text   The String to be iterated over</description>
					</attribute>
					<attribute name="@param">
						<description>pos    Initial iterator position</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="The String to be iterated over" fulltype="java.lang.String" type="String" />
					<param name="pos" comment="Initial iterator position" fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="StringCharacterIterator">
				<comment>
					<description>Constructs an iterator over the given range of the given string, with the
 index set at the specified position.</description>
					<attribute name="@param">
						<description>text   The String to be iterated over</description>
					</attribute>
					<attribute name="@param">
						<description>begin  Index of the first character</description>
					</attribute>
					<attribute name="@param">
						<description>end    Index of the character following the last character</description>
					</attribute>
					<attribute name="@param">
						<description>pos    Initial iterator position</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="The String to be iterated over" fulltype="java.lang.String" type="String" />
					<param name="begin" comment="Index of the first character" fulltype="int" type="int" />
					<param name="end" comment="Index of the character following the last character" fulltype="int" type="int" />
					<param name="pos" comment="Initial iterator position" fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="public" name="setText" fulltype="void" type="void">
				<comment>
					<description>Reset this iterator to point to a new string.  This package-visible
 method is used by other java.text classes that want to avoid allocating
 new StringCharacterIterator objects every time their setText method
 is called.</description>
					<attribute name="@param">
						<description>text   The String to be iterated over</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="The String to be iterated over" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="first" fulltype="char" type="char">
				<comment>
					<description>Implements CharacterIterator.first() for String.</description>
					<attribute name="@see">
						<description>CharacterIterator#first</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="last" fulltype="char" type="char">
				<comment>
					<description>Implements CharacterIterator.last() for String.</description>
					<attribute name="@see">
						<description>CharacterIterator#last</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setIndex" fulltype="char" type="char">
				<comment>
					<description>Implements CharacterIterator.setIndex() for String.</description>
					<attribute name="@see">
						<description>CharacterIterator#setIndex</description>
					</attribute>
				</comment>
				<params>
					<param name="p" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="current" fulltype="char" type="char">
				<comment>
					<description>Implements CharacterIterator.current() for String.</description>
					<attribute name="@see">
						<description>CharacterIterator#current</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="next" fulltype="char" type="char">
				<comment>
					<description>Implements CharacterIterator.next() for String.</description>
					<attribute name="@see">
						<description>CharacterIterator#next</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="previous" fulltype="char" type="char">
				<comment>
					<description>Implements CharacterIterator.previous() for String.</description>
					<attribute name="@see">
						<description>CharacterIterator#previous</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getBeginIndex" fulltype="int" type="int">
				<comment>
					<description>Implements CharacterIterator.getBeginIndex() for String.</description>
					<attribute name="@see">
						<description>CharacterIterator#getBeginIndex</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getEndIndex" fulltype="int" type="int">
				<comment>
					<description>Implements CharacterIterator.getEndIndex() for String.</description>
					<attribute name="@see">
						<description>CharacterIterator#getEndIndex</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getIndex" fulltype="int" type="int">
				<comment>
					<description>Implements CharacterIterator.getIndex() for String.</description>
					<attribute name="@see">
						<description>CharacterIterator#getIndex</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="equals" returncomment="true if the given obj is the same as this
 StringCharacterIterator object; false otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares the equality of two StringCharacterIterator objects.</description>
					<attribute name="@param">
						<description>obj the StringCharacterIterator object to be compared with.</description>
					</attribute>
					<attribute name="@return">
						<description>true if the given obj is the same as this
 StringCharacterIterator object; false otherwise.</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the StringCharacterIterator object to be compared with." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" returncomment="A hash code" fulltype="int" type="int">
				<comment>
					<description>Computes a hashcode for this iterator.</description>
					<attribute name="@return">
						<description>A hash code</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="clone" returncomment="A copy of this" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Creates a copy of this iterator.</description>
					<attribute name="@return">
						<description>A copy of this</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.text" serializable="true" superclassfulltype="java.lang.Object" fulltype="java.text.DateFormatSymbols" type="DateFormatSymbols">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
			<interface fulltype="java.lang.Cloneable" type="Cloneable" />
		</implements>
		<comment>
			<description>&lt;code&gt;DateFormatSymbols&lt;/code&gt; is a public class for encapsulating
 localizable date-time formatting data, such as the names of the
 months, the names of the days of the week, and the time zone data.
 &lt;code&gt;DateFormat&lt;/code&gt; and &lt;code&gt;SimpleDateFormat&lt;/code&gt; both use
 &lt;code&gt;DateFormatSymbols&lt;/code&gt; to encapsulate this information.

 &lt;p&gt;
 Typically you shouldn&apos;t use &lt;code&gt;DateFormatSymbols&lt;/code&gt; directly.
 Rather, you are encouraged to create a date-time formatter with the
 &lt;code&gt;DateFormat&lt;/code&gt; class&apos;s factory methods: &lt;code&gt;getTimeInstance&lt;/code&gt;,
 &lt;code&gt;getDateInstance&lt;/code&gt;, or &lt;code&gt;getDateTimeInstance&lt;/code&gt;.
 These methods automatically create a &lt;code&gt;DateFormatSymbols&lt;/code&gt; for
 the formatter so that you don&apos;t have to. After the
 formatter is created, you may modify its format pattern using the
 &lt;code&gt;setPattern&lt;/code&gt; method. For more information about
 creating formatters using &lt;code&gt;DateFormat&lt;/code&gt;&apos;s factory methods,
 see {@link DateFormat}.

 &lt;p&gt;
 If you decide to create a date-time formatter with a specific
 format pattern for a specific locale, you can do so with:
 &lt;blockquote&gt;
 &lt;pre&gt;
 new SimpleDateFormat(aPattern, DateFormatSymbols.getInstance(aLocale)).
 &lt;/pre&gt;
 &lt;/blockquote&gt;

 &lt;p&gt;
 &lt;code&gt;DateFormatSymbols&lt;/code&gt; objects are cloneable. When you obtain
 a &lt;code&gt;DateFormatSymbols&lt;/code&gt; object, feel free to modify the
 date-time formatting data. For instance, you can replace the localized
 date-time format pattern characters with the ones that you feel easy
 to remember. Or you can change the representative cities
 to your favorite ones.

 &lt;p&gt;
 New &lt;code&gt;DateFormatSymbols&lt;/code&gt; subclasses may be added to support
 &lt;code&gt;SimpleDateFormat&lt;/code&gt; for date-time formatting for additional locales.</description>
			<attribute name="@see">
				<description>DateFormat</description>
			</attribute>
			<attribute name="@see">
				<description>SimpleDateFormat</description>
			</attribute>
			<attribute name="@see">
				<description>java.util.SimpleTimeZone</description>
			</attribute>
			<attribute name="@author">
				<description>Chen-Lieh Huang</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="eras" fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Era strings. For example: &quot;AD&quot; and &quot;BC&quot;.  An array of 2 strings,
 indexed by &lt;code&gt;Calendar.BC&lt;/code&gt; and &lt;code&gt;Calendar.AD&lt;/code&gt;.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="package-private" name="months" fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Month strings. For example: &quot;January&quot;, &quot;February&quot;, etc.  An array
 of 13 strings (some calendars have 13 months), indexed by
 &lt;code&gt;Calendar.JANUARY&lt;/code&gt;, &lt;code&gt;Calendar.FEBRUARY&lt;/code&gt;, etc.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="package-private" name="shortMonths" fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Short month strings. For example: &quot;Jan&quot;, &quot;Feb&quot;, etc.  An array of
 13 strings (some calendars have 13 months), indexed by
 &lt;code&gt;Calendar.JANUARY&lt;/code&gt;, &lt;code&gt;Calendar.FEBRUARY&lt;/code&gt;, etc.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="package-private" name="weekdays" fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Weekday strings. For example: &quot;Sunday&quot;, &quot;Monday&quot;, etc.  An array
 of 8 strings, indexed by &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
 &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc.
 The element &lt;code&gt;weekdays[0]&lt;/code&gt; is ignored.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="package-private" name="shortWeekdays" fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Short weekday strings. For example: &quot;Sun&quot;, &quot;Mon&quot;, etc.  An array
 of 8 strings, indexed by &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
 &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc.
 The element &lt;code&gt;shortWeekdays[0]&lt;/code&gt; is ignored.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="package-private" name="ampms" fulltype="java.lang.String[]" type="String">
				<comment>
					<description>AM and PM strings. For example: &quot;AM&quot; and &quot;PM&quot;.  An array of
 2 strings, indexed by &lt;code&gt;Calendar.AM&lt;/code&gt; and
 &lt;code&gt;Calendar.PM&lt;/code&gt;.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="package-private" name="zoneStrings" fulltype="java.lang.String[][]" type="String">
				<comment>
					<description>Localized names of time zones in this locale.  This is a
 two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
 where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
 entry containing the localized names for a single &lt;code&gt;TimeZone&lt;/code&gt;.
 Each such row contains (with &lt;code&gt;i&lt;/code&gt; ranging from
 0..&lt;em&gt;n&lt;/em&gt;-1):
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][0]&lt;/code&gt; - time zone ID&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][1]&lt;/code&gt; - long name of zone in standard
 time&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][2]&lt;/code&gt; - short name of zone in
 standard time&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][3]&lt;/code&gt; - long name of zone in daylight
 saving time&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][4]&lt;/code&gt; - short name of zone in daylight
 saving time&lt;/li&gt;
 &lt;/ul&gt;
 The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it&apos;s one of the valid IDs of
 the {@link java.util.TimeZone TimeZone} class that are not
 &lt;a href=&quot;../java/util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
 All other entries are localized names.</description>
					<attribute name="@see">
						<description>java.util.TimeZone</description>
					</attribute>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="package-private" transient="true" name="isZoneStringsSet" fulltype="boolean" type="boolean">
				<comment>
					<description>Indicates that zoneStrings is set externally with setZoneStrings() method.</description>
				</comment>
			</field>
			<field final="true" static="true" const="GyMdkHmsSEDFwWahKzZ" visibility="package-private" name="patternChars" constexpr="&quot;GyMdkHmsSEDFwWahKzZ&quot;" fulltype="java.lang.String" type="String">
				<comment>
					<description>Unlocalized date-time pattern characters. For example: &apos;y&apos;, &apos;d&apos;, etc.
 All locales use the same these unlocalized pattern characters.</description>
				</comment>
			</field>
			<field visibility="package-private" name="localPatternChars" fulltype="java.lang.String" type="String">
				<comment>
					<description>Localized date-time pattern characters. For example, a locale may
 wish to use &apos;u&apos; rather than &apos;y&apos; to represent years in its date format
 pattern strings.
 This string must be exactly 18 characters long, with the index of
 the characters described by &lt;code&gt;DateFormat.ERA_FIELD&lt;/code&gt;,
 &lt;code&gt;DateFormat.YEAR_FIELD&lt;/code&gt;, etc.  Thus, if the string were
 &quot;Xz...&quot;, then localized patterns would use &apos;X&apos; for era and &apos;z&apos; for year.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="package-private" name="locale" fulltype="java.util.Locale" type="Locale">
				<comment>
					<description>The locale which is used for initializing this DateFormatSymbols object.</description>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
					<attribute name="@serial" />
				</comment>
			</field>
			<field final="true" static="true" const="-5987973545549424702" visibility="package-private" name="serialVersionUID" constexpr="-5987973545549424702L" fulltype="long" type="long" />
			<field final="true" static="true" const="3600000" visibility="package-private" name="millisPerHour" constexpr="3600000" fulltype="int" type="int">
				<comment>
					<description>Useful constant for defining time zone offsets.</description>
				</comment>
			</field>
			<field static="true" visibility="private" name="cachedLocaleData" fulltype="java.util.Hashtable" type="Hashtable">
				<comment>
					<description>Cache to hold the FormatData and TimeZoneNames ResourceBundles
 of a Locale.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="DateFormatSymbols">
				<comment>
					<description>Construct a DateFormatSymbols object by loading format data from
 resources for the default locale. This constructor can only
 construct instances for the locales supported by the Java
 runtime environment, not for those supported by installed
 {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
 implementations. For full locale coverage, use the
 {@link #getInstance(Locale) getInstance} method.</description>
					<attribute name="@see">
						<description>#getInstance()</description>
					</attribute>
					<attribute name="@exception">
						<description>java.util.MissingResourceException
             if the resources for the default locale cannot be
             found or cannot be loaded.</description>
					</attribute>
				</comment>
			</constructor>
			<constructor visibility="public" name="DateFormatSymbols">
				<comment>
					<description>Construct a DateFormatSymbols object by loading format data from
 resources for the given locale. This constructor can only
 construct instances for the locales supported by the Java
 runtime environment, not for those supported by installed
 {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
 implementations. For full locale coverage, use the
 {@link #getInstance(Locale) getInstance} method.</description>
					<attribute name="@see">
						<description>#getInstance(Locale)</description>
					</attribute>
					<attribute name="@exception">
						<description>java.util.MissingResourceException
             if the resources for the specified locale cannot be
             found or cannot be loaded.</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</constructor>
			<method static="true" visibility="public" name="getAvailableLocales" returncomment="An array of locales for which localized
         &lt;code&gt;DateFormatSymbols&lt;/code&gt; instances are available." fulltype="java.util.Locale[]" type="Locale">
				<comment>
					<description>Returns an array of all locales for which the
 &lt;code&gt;getInstance&lt;/code&gt; methods of this class can return
 localized instances.
 The returned array represents the union of locales supported by the
 Java runtime and by installed
 {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
 implementations.  It must contain at least a &lt;code&gt;Locale&lt;/code&gt;
 instance equal to {@link java.util.Locale#US Locale.US}.</description>
					<attribute name="@return">
						<description>An array of locales for which localized
         &lt;code&gt;DateFormatSymbols&lt;/code&gt; instances are available.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method final="true" static="true" visibility="public" name="getInstance" returncomment="a &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance." fulltype="java.text.DateFormatSymbols" type="DateFormatSymbols">
				<comment>
					<description>Gets the &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance for the default
 locale.  This method provides access to &lt;code&gt;DateFormatSymbols&lt;/code&gt;
 instances for locales supported by the Java runtime itself as well
 as for those supported by installed
 {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
 implementations.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method final="true" static="true" visibility="public" name="getInstance" returncomment="a &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance." fulltype="java.text.DateFormatSymbols" type="DateFormatSymbols">
				<comment>
					<description>Gets the &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance for the specified
 locale.  This method provides access to &lt;code&gt;DateFormatSymbols&lt;/code&gt;
 instances for locales supported by the Java runtime itself as well
 as for those supported by installed
 {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
 implementations.</description>
					<attribute name="@param">
						<description>locale the given locale.</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the given locale." fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method visibility="public" name="getEras" returncomment="the era strings." fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Gets era strings. For example: &quot;AD&quot; and &quot;BC&quot;.</description>
					<attribute name="@return">
						<description>the era strings.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setEras" fulltype="void" type="void">
				<comment>
					<description>Sets era strings. For example: &quot;AD&quot; and &quot;BC&quot;.</description>
					<attribute name="@param">
						<description>newEras the new era strings.</description>
					</attribute>
				</comment>
				<params>
					<param name="newEras" comment="the new era strings." fulltype="java.lang.String[]" type="String" />
				</params>
			</method>
			<method visibility="public" name="getMonths" returncomment="the month strings." fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Gets month strings. For example: &quot;January&quot;, &quot;February&quot;, etc.</description>
					<attribute name="@return">
						<description>the month strings.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setMonths" fulltype="void" type="void">
				<comment>
					<description>Sets month strings. For example: &quot;January&quot;, &quot;February&quot;, etc.</description>
					<attribute name="@param">
						<description>newMonths the new month strings.</description>
					</attribute>
				</comment>
				<params>
					<param name="newMonths" comment="the new month strings." fulltype="java.lang.String[]" type="String" />
				</params>
			</method>
			<method visibility="public" name="getShortMonths" returncomment="the short month strings." fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Gets short month strings. For example: &quot;Jan&quot;, &quot;Feb&quot;, etc.</description>
					<attribute name="@return">
						<description>the short month strings.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setShortMonths" fulltype="void" type="void">
				<comment>
					<description>Sets short month strings. For example: &quot;Jan&quot;, &quot;Feb&quot;, etc.</description>
					<attribute name="@param">
						<description>newShortMonths the new short month strings.</description>
					</attribute>
				</comment>
				<params>
					<param name="newShortMonths" comment="the new short month strings." fulltype="java.lang.String[]" type="String" />
				</params>
			</method>
			<method visibility="public" name="getWeekdays" returncomment="the weekday strings. Use &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
 &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc. to index the result array." fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Gets weekday strings. For example: &quot;Sunday&quot;, &quot;Monday&quot;, etc.</description>
					<attribute name="@return">
						<description>the weekday strings. Use &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
 &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc. to index the result array.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setWeekdays" fulltype="void" type="void">
				<comment>
					<description>Sets weekday strings. For example: &quot;Sunday&quot;, &quot;Monday&quot;, etc.</description>
					<attribute name="@param">
						<description>newWeekdays the new weekday strings. The array should
 be indexed by &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
 &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc.</description>
					</attribute>
				</comment>
				<params>
					<param name="newWeekdays" comment="the new weekday strings. The array should
 be indexed by &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
 &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc." fulltype="java.lang.String[]" type="String" />
				</params>
			</method>
			<method visibility="public" name="getShortWeekdays" returncomment="the short weekday strings. Use &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
 &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc. to index the result array." fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Gets short weekday strings. For example: &quot;Sun&quot;, &quot;Mon&quot;, etc.</description>
					<attribute name="@return">
						<description>the short weekday strings. Use &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
 &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc. to index the result array.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setShortWeekdays" fulltype="void" type="void">
				<comment>
					<description>Sets short weekday strings. For example: &quot;Sun&quot;, &quot;Mon&quot;, etc.</description>
					<attribute name="@param">
						<description>newShortWeekdays the new short weekday strings. The array should
 be indexed by &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
 &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc.</description>
					</attribute>
				</comment>
				<params>
					<param name="newShortWeekdays" comment="the new short weekday strings. The array should
 be indexed by &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
 &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc." fulltype="java.lang.String[]" type="String" />
				</params>
			</method>
			<method visibility="public" name="getAmPmStrings" returncomment="the ampm strings." fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Gets ampm strings. For example: &quot;AM&quot; and &quot;PM&quot;.</description>
					<attribute name="@return">
						<description>the ampm strings.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setAmPmStrings" fulltype="void" type="void">
				<comment>
					<description>Sets ampm strings. For example: &quot;AM&quot; and &quot;PM&quot;.</description>
					<attribute name="@param">
						<description>newAmpms the new ampm strings.</description>
					</attribute>
				</comment>
				<params>
					<param name="newAmpms" comment="the new ampm strings." fulltype="java.lang.String[]" type="String" />
				</params>
			</method>
			<method visibility="public" name="getZoneStrings" returncomment="the time zone strings." fulltype="java.lang.String[][]" type="String">
				<comment>
					<description>Gets time zone strings.  Use of this method is discouraged; use
 {@link java.util.TimeZone#getDisplayName() TimeZone.getDisplayName()}
 instead.
 &lt;p&gt;
 The value returned is a
 two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
 where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
 entry containing the localized names for a single &lt;code&gt;TimeZone&lt;/code&gt;.
 Each such row contains (with &lt;code&gt;i&lt;/code&gt; ranging from
 0..&lt;em&gt;n&lt;/em&gt;-1):
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][0]&lt;/code&gt; - time zone ID&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][1]&lt;/code&gt; - long name of zone in standard
 time&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][2]&lt;/code&gt; - short name of zone in
 standard time&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][3]&lt;/code&gt; - long name of zone in daylight
 saving time&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][4]&lt;/code&gt; - short name of zone in daylight
 saving time&lt;/li&gt;
 &lt;/ul&gt;
 The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it&apos;s one of the valid IDs of
 the {@link java.util.TimeZone TimeZone} class that are not
 &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
 All other entries are localized names.  If a zone does not implement
 daylight saving time, the daylight saving time names should not be used.
 &lt;p&gt;
 If {@link #setZoneStrings(String[][]) setZoneStrings} has been called
 on this &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance, then the strings
 provided by that call are returned. Otherwise, the returned array
 contains names provided by the Java runtime and by installed
 {@link java.util.spi.TimeZoneNameProvider TimeZoneNameProvider}
 implementations.</description>
					<attribute name="@return">
						<description>the time zone strings.</description>
					</attribute>
					<attribute name="@see">
						<description>#setZoneStrings(String[][])</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setZoneStrings" fulltype="void" type="void">
				<comment>
					<description>Sets time zone strings.  The argument must be a
 two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
 where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
 entry containing the localized names for a single &lt;code&gt;TimeZone&lt;/code&gt;.
 Each such row contains (with &lt;code&gt;i&lt;/code&gt; ranging from
 0..&lt;em&gt;n&lt;/em&gt;-1):
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][0]&lt;/code&gt; - time zone ID&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][1]&lt;/code&gt; - long name of zone in standard
 time&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][2]&lt;/code&gt; - short name of zone in
 standard time&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][3]&lt;/code&gt; - long name of zone in daylight
 saving time&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;zoneStrings[i][4]&lt;/code&gt; - short name of zone in daylight
 saving time&lt;/li&gt;
 &lt;/ul&gt;
 The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it&apos;s one of the valid IDs of
 the {@link java.util.TimeZone TimeZone} class that are not
 &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
 All other entries are localized names.</description>
					<attribute name="@param">
						<description>newZoneStrings the new time zone strings.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the length of any row in
    &lt;code&gt;newZoneStrings&lt;/code&gt; is less than 5</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;newZoneStrings&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@see">
						<description>#getZoneStrings()</description>
					</attribute>
				</comment>
				<params>
					<param name="newZoneStrings" comment="the new time zone strings." fulltype="java.lang.String[][]" type="String" />
				</params>
			</method>
			<method visibility="public" name="getLocalPatternChars" returncomment="the localized date-time pattern characters." fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets localized date-time pattern characters. For example: &apos;u&apos;, &apos;t&apos;, etc.</description>
					<attribute name="@return">
						<description>the localized date-time pattern characters.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setLocalPatternChars" fulltype="void" type="void">
				<comment>
					<description>Sets localized date-time pattern characters. For example: &apos;u&apos;, &apos;t&apos;, etc.</description>
					<attribute name="@param">
						<description>newLocalPatternChars the new localized date-time
 pattern characters.</description>
					</attribute>
				</comment>
				<params>
					<param name="newLocalPatternChars" comment="the new localized date-time
 pattern characters." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="clone" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Overrides Cloneable</description>
				</comment>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Override hashCode.
 Generates a hash code for the DateFormatSymbols object.</description>
				</comment>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Override equals</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method static="true" visibility="private" name="cacheLookup" fulltype="java.util.ResourceBundle" type="ResourceBundle">
				<comment>
					<description>Look up resource data for the desiredLocale in the cache; update the
 cache if necessary.</description>
				</comment>
				<params>
					<param name="desiredLocale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method visibility="private" name="initializeData" fulltype="void" type="void">
				<params>
					<param name="desiredLocale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method final="true" visibility="package-private" name="getZoneIndex" returncomment="the index of the given time zone ID.  Returns -1 if
 the given time zone ID can&apos;t be located in the DateFormatSymbols object." fulltype="int" type="int">
				<comment>
					<description>Package private: used by SimpleDateFormat
 Gets the index for the given time zone ID to obtain the time zone
 strings for formatting. The time zone ID is just for programmatic
 lookup. NOT LOCALIZED!!!</description>
					<attribute name="@param">
						<description>ID the given time zone ID.</description>
					</attribute>
					<attribute name="@return">
						<description>the index of the given time zone ID.  Returns -1 if
 the given time zone ID can&apos;t be located in the DateFormatSymbols object.</description>
					</attribute>
					<attribute name="@see">
						<description>java.util.SimpleTimeZone</description>
					</attribute>
				</comment>
				<params>
					<param name="ID" comment="the given time zone ID." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method final="true" visibility="package-private" name="getZoneStringsWrapper" fulltype="java.lang.String[][]" type="String">
				<comment>
					<description>Wrapper method to the getZoneStrings(), which is called from inside
 the java.text package and not to mutate the returned arrays, so that
 it does not need to create a defensive copy.</description>
				</comment>
			</method>
			<method final="true" visibility="private" name="getZoneStringsImpl" fulltype="java.lang.String[][]" type="String">
				<params>
					<param name="needsCopy" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method final="true" visibility="private" name="isSubclassObject" fulltype="boolean" type="boolean" />
			<method final="true" visibility="private" name="duplicate" returncomment="a cloned array." fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Clones an array of Strings.</description>
					<attribute name="@param">
						<description>srcArray the source array to be cloned.</description>
					</attribute>
					<attribute name="@param">
						<description>count the number of elements in the given source array.</description>
					</attribute>
					<attribute name="@return">
						<description>a cloned array.</description>
					</attribute>
				</comment>
				<params>
					<param name="srcArray" comment="the source array to be cloned." fulltype="java.lang.String[]" type="String" />
				</params>
			</method>
			<method final="true" visibility="private" name="copyMembers" fulltype="void" type="void">
				<comment>
					<description>Clones all the data members from the source DateFormatSymbols to
 the target DateFormatSymbols. This is only for subclasses.</description>
					<attribute name="@param">
						<description>src the source DateFormatSymbols.</description>
					</attribute>
					<attribute name="@param">
						<description>dst the target DateFormatSymbols.</description>
					</attribute>
				</comment>
				<params>
					<param name="src" comment="the source DateFormatSymbols." fulltype="java.text.DateFormatSymbols" type="DateFormatSymbols" />
					<param name="dst" comment="the target DateFormatSymbols." fulltype="java.text.DateFormatSymbols" type="DateFormatSymbols" />
				</params>
			</method>
			<method final="true" visibility="private" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Compares the equality of the two arrays of String.</description>
					<attribute name="@param">
						<description>current this String array.</description>
					</attribute>
					<attribute name="@param">
						<description>other that String array.</description>
					</attribute>
				</comment>
				<params>
					<param name="current" comment="this String array." fulltype="java.lang.String[]" type="String" />
					<param name="other" comment="that String array." fulltype="java.lang.String[]" type="String" />
				</params>
			</method>
			<method visibility="private" name="writeObject" fulltype="void" type="void">
				<comment>
					<description>Write out the default serializable data, after ensuring the
 &lt;code&gt;zoneStrings&lt;/code&gt; field is initialized in order to make
 sure the backward compatibility.</description>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="stream" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.DateFormatSymbols.DateFormatSymbolsGetter" type="DateFormatSymbols.DateFormatSymbolsGetter">
			<implements>
				<interface fulltype="sun.util.LocaleServiceProviderPool.LocalizedObjectGetter" type="LocaleServiceProviderPool.LocalizedObjectGetter" />
			</implements>
			<comment>
				<description>Obtains a DateFormatSymbols instance from a DateFormatSymbolsProvider
 implementation.</description>
			</comment>
			<fields>
				<field final="true" static="true" visibility="private" name="INSTANCE" fulltype="java.text.DateFormatSymbols.DateFormatSymbolsGetter" type="DateFormatSymbols.DateFormatSymbolsGetter" />
			</fields>
			<methods>
				<constructor visibility="private" name="DateFormatSymbols.DateFormatSymbolsGetter" />
				<method visibility="public" name="getObject" fulltype="java.text.DateFormatSymbols" type="DateFormatSymbols">
					<params>
						<param name="dateFormatSymbolsProvider" fulltype="java.text.spi.DateFormatSymbolsProvider" type="DateFormatSymbolsProvider" />
						<param name="locale" fulltype="java.util.Locale" type="Locale" />
						<param name="key" fulltype="java.lang.String" type="String" />
						<param name="params" fulltype="java.lang.Object[]" type="Object" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.DateFormatSymbols.DateFormatSymbolsGetter" type="DateFormatSymbols.DateFormatSymbolsGetter">
		<implements>
			<interface fulltype="sun.util.LocaleServiceProviderPool.LocalizedObjectGetter" type="LocaleServiceProviderPool.LocalizedObjectGetter" />
		</implements>
		<comment>
			<description>Obtains a DateFormatSymbols instance from a DateFormatSymbolsProvider
 implementation.</description>
		</comment>
		<fields>
			<field final="true" static="true" visibility="private" name="INSTANCE" fulltype="java.text.DateFormatSymbols.DateFormatSymbolsGetter" type="DateFormatSymbols.DateFormatSymbolsGetter" />
		</fields>
		<methods>
			<constructor visibility="private" name="DateFormatSymbols.DateFormatSymbolsGetter" />
			<method visibility="public" name="getObject" fulltype="java.text.DateFormatSymbols" type="DateFormatSymbols">
				<params>
					<param name="dateFormatSymbolsProvider" fulltype="java.text.spi.DateFormatSymbolsProvider" type="DateFormatSymbolsProvider" />
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
					<param name="key" fulltype="java.lang.String" type="String" />
					<param name="params" fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="RuleBasedBreakIterator" visibility="package-private" package="java.text" superclassfulltype="java.text.RuleBasedBreakIterator" fulltype="java.text.DictionaryBasedBreakIterator" type="DictionaryBasedBreakIterator">
		<comment>
			<description>A subclass of RuleBasedBreakIterator that adds the ability to use a dictionary
 to further subdivide ranges of text beyond what is possible using just the
 state-table-based algorithm.  This is necessary, for example, to handle
 word and line breaking in Thai, which doesn&apos;t use spaces between words.  The
 state-table-based algorithm used by RuleBasedBreakIterator is used to divide
 up text as far as possible, and then contiguous ranges of letters are
 repeatedly compared against a list of known words (i.e., the dictionary)
 to divide them up into words.

 DictionaryBasedBreakIterator uses the same rule language as RuleBasedBreakIterator,
 but adds one more special substitution name: &amp;lt;dictionary&amp;gt;.  This substitution
 name is used to identify characters in words in the dictionary.  The idea is that
 if the iterator passes over a chunk of text that includes two or more characters
 in a row that are included in &amp;lt;dictionary&amp;gt;, it goes back through that range and
 derives additional break positions (if possible) using the dictionary.

 DictionaryBasedBreakIterator is also constructed with the filename of a dictionary
 file.  It follows a prescribed search path to locate the dictionary (right now,
 it looks for it in /com/ibm/text/resources in each directory in the classpath,
 and won&apos;t find it in JAR files, but this location is likely to change).  The
 dictionary file is in a serialized binary format.  We have a very primitive (and
 slow) BuildDictionaryFile utility for creating dictionary files, but aren&apos;t
 currently making it public.  Contact us for help.</description>
		</comment>
		<fields>
			<field visibility="private" name="dictionary" fulltype="java.text.BreakDictionary" type="BreakDictionary">
				<comment>
					<description>a list of known words that is used to divide up contiguous ranges of letters,
 stored in a compressed, indexed, format that offers fast access</description>
				</comment>
			</field>
			<field visibility="private" name="categoryFlags" fulltype="boolean[]" type="boolean">
				<comment>
					<description>a list of flags indicating which character categories are contained in
 the dictionary file (this is used to determine which ranges of characters
 to apply the dictionary to)</description>
				</comment>
			</field>
			<field visibility="private" name="dictionaryCharCount" fulltype="int" type="int">
				<comment>
					<description>a temporary hiding place for the number of dictionary characters in the
 last range passed over by next()</description>
				</comment>
			</field>
			<field visibility="private" name="cachedBreakPositions" fulltype="int[]" type="int">
				<comment>
					<description>when a range of characters is divided up using the dictionary, the break
 positions that are discovered are stored here, preventing us from having
 to use either the dictionary or the state table again until the iterator
 leaves this range of text</description>
				</comment>
			</field>
			<field visibility="private" name="positionInCache" fulltype="int" type="int">
				<comment>
					<description>if cachedBreakPositions is not null, this indicates which item in the
 cache the current iteration position refers to</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="DictionaryBasedBreakIterator">
				<comment>
					<description>Constructs a DictionaryBasedBreakIterator.</description>
					<attribute name="@param">
						<description>description Same as the description parameter on RuleBasedBreakIterator,
 except for the special meaning of &quot;&lt;dictionary&gt;&quot;.  This parameter is just
 passed through to RuleBasedBreakIterator&apos;s constructor.</description>
					</attribute>
					<attribute name="@param">
						<description>dictionaryFilename The filename of the dictionary file to use</description>
					</attribute>
				</comment>
				<params>
					<param name="dataFile" fulltype="java.lang.String" type="String" />
					<param name="dictionaryFile" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<method visibility="private" name="prepareCategoryFlags" fulltype="void" type="void">
				<params>
					<param name="data" fulltype="byte[]" type="byte" />
				</params>
			</method>
			<method visibility="public" name="setText" fulltype="void" type="void">
				<params>
					<param name="newText" fulltype="java.text.CharacterIterator" type="CharacterIterator" />
				</params>
			</method>
			<method visibility="public" name="first" returncomment="The offset of the beginning of the text." fulltype="int" type="int">
				<comment>
					<description>Sets the current iteration position to the beginning of the text.
 (i.e., the CharacterIterator&apos;s starting offset).</description>
					<attribute name="@return">
						<description>The offset of the beginning of the text.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="last" returncomment="The text&apos;s past-the-end offset." fulltype="int" type="int">
				<comment>
					<description>Sets the current iteration position to the end of the text.
 (i.e., the CharacterIterator&apos;s ending offset).</description>
					<attribute name="@return">
						<description>The text&apos;s past-the-end offset.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="previous" returncomment="The position of the last boundary position before the
 current iteration position" fulltype="int" type="int">
				<comment>
					<description>Advances the iterator one step backwards.</description>
					<attribute name="@return">
						<description>The position of the last boundary position before the
 current iteration position</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="preceding" returncomment="The position of the last boundary before &quot;offset&quot;" fulltype="int" type="int">
				<comment>
					<description>Sets the current iteration position to the last boundary position
 before the specified position.</description>
					<attribute name="@param">
						<description>offset The position to begin searching from</description>
					</attribute>
					<attribute name="@return">
						<description>The position of the last boundary before &quot;offset&quot;</description>
					</attribute>
				</comment>
				<params>
					<param name="offset" comment="The position to begin searching from" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="following" returncomment="The position of the first boundary after &quot;offset&quot;" fulltype="int" type="int">
				<comment>
					<description>Sets the current iteration position to the first boundary position after
 the specified position.</description>
					<attribute name="@param">
						<description>offset The position to begin searching forward from</description>
					</attribute>
					<attribute name="@return">
						<description>The position of the first boundary after &quot;offset&quot;</description>
					</attribute>
				</comment>
				<params>
					<param name="offset" comment="The position to begin searching forward from" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="protected" name="handleNext" fulltype="int" type="int">
				<comment>
					<description>This is the implementation function for next().</description>
				</comment>
			</method>
			<method visibility="protected" name="lookupCategory" fulltype="int" type="int">
				<comment>
					<description>Looks up a character category for a character.</description>
				</comment>
				<params>
					<param name="c" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="divideUpDictionaryRange" fulltype="void" type="void">
				<comment>
					<description>This is the function that actually implements the dictionary-based
 algorithm.  Given the endpoints of a range of text, it uses the
 dictionary to determine the positions of any boundaries in this
 range.  It stores all the boundary positions it discovers in
 cachedBreakPositions so that we only have to do this work once
 for each time we enter the range.</description>
				</comment>
				<params>
					<param name="startPos" fulltype="int" type="int" />
					<param name="endPos" fulltype="int" type="int" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="BreakIterator" visibility="package-private" package="java.text" superclassfulltype="java.text.BreakIterator" fulltype="java.text.RuleBasedBreakIterator" type="RuleBasedBreakIterator">
		<comment>
			<description>&lt;p&gt;A subclass of BreakIterator whose behavior is specified using a list of rules.&lt;/p&gt;

 &lt;p&gt;There are two kinds of rules, which are separated by semicolons: &lt;i&gt;substitutions&lt;/i&gt;
 and &lt;i&gt;regular expressions.&lt;/i&gt;&lt;/p&gt;

 &lt;p&gt;A substitution rule defines a name that can be used in place of an expression. It
 consists of a name, which is a string of characters contained in angle brackets, an equals
 sign, and an expression. (There can be no whitespace on either side of the equals sign.)
 To keep its syntactic meaning intact, the expression must be enclosed in parentheses or
 square brackets. A substitution is visible after its definition, and is filled in using
 simple textual substitution. Substitution definitions can contain other substitutions, as
 long as those substitutions have been defined first. Substitutions are generally used to
 make the regular expressions (which can get quite complex) shorted and easier to read.
 They typically define either character categories or commonly-used subexpressions.&lt;/p&gt;

 &lt;p&gt;There is one special substitution.&amp;nbsp; If the description defines a substitution
 called &amp;quot;&amp;lt;ignore&amp;gt;&amp;quot;, the expression must be a [] expression, and the
 expression defines a set of characters (the &amp;quot;&lt;em&gt;ignore characters&lt;/em&gt;&amp;quot;) that
 will be transparent to the BreakIterator.&amp;nbsp; A sequence of characters will break the
 same way it would if any ignore characters it contains are taken out.&amp;nbsp; Break
 positions never occur befoer ignore characters.&lt;/p&gt;

 &lt;p&gt;A regular expression uses a subset of the normal Unix regular-expression syntax, and
 defines a sequence of characters to be kept together. With one significant exception, the
 iterator uses a longest-possible-match algorithm when matching text to regular
 expressions. The iterator also treats descriptions containing multiple regular expressions
 as if they were ORed together (i.e., as if they were separated by |).&lt;/p&gt;

 &lt;p&gt;The special characters recognized by the regular-expression parser are as follows:&lt;/p&gt;

 &lt;blockquote&gt;
   &lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;*&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;Specifies that the expression preceding the asterisk may occur any number
       of times (including not at all).&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;{}&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;Encloses a sequence of characters that is optional.&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;()&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;Encloses a sequence of characters.&amp;nbsp; If followed by *, the sequence
       repeats.&amp;nbsp; Otherwise, the parentheses are just a grouping device and a way to delimit
       the ends of expressions containing |.&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;|&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;Separates two alternative sequences of characters.&amp;nbsp; Either one
       sequence or the other, but not both, matches this expression.&amp;nbsp; The | character can
       only occur inside ().&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;.&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;Matches any character.&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;*?&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;Specifies a non-greedy asterisk.&amp;nbsp; *? works the same way as *, except
       when there is overlap between the last group of characters in the expression preceding the
       * and the first group of characters following the *.&amp;nbsp; When there is this kind of
       overlap, * will match the longest sequence of characters that match the expression before
       the *, and *? will match the shortest sequence of characters matching the expression
       before the *?.&amp;nbsp; For example, if you have &amp;quot;xxyxyyyxyxyxxyxyxyy&amp;quot; in the text,
       &amp;quot;x[xy]*x&amp;quot; will match through to the last x (i.e., &amp;quot;&lt;strong&gt;xxyxyyyxyxyxxyxyx&lt;/strong&gt;yy&amp;quot;,
       but &amp;quot;x[xy]*?x&amp;quot; will only match the first two xes (&amp;quot;&lt;strong&gt;xx&lt;/strong&gt;yxyyyxyxyxxyxyxyy&amp;quot;).&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;[]&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;Specifies a group of alternative characters.&amp;nbsp; A [] expression will
       match any single character that is specified in the [] expression.&amp;nbsp; For more on the
       syntax of [] expressions, see below.&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;/&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;Specifies where the break position should go if text matches this
       expression.&amp;nbsp; (e.g., &amp;quot;[a-z]&amp;#42;/[:Zs:]*[1-0]&amp;quot; will match if the iterator sees a run
       of letters, followed by a run of whitespace, followed by a digit, but the break position
       will actually go before the whitespace).&amp;nbsp; Expressions that don&apos;t contain / put the
       break position at the end of the matching text.&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;\&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;Escape character.&amp;nbsp; The \ itself is ignored, but causes the next
       character to be treated as literal character.&amp;nbsp; This has no effect for many
       characters, but for the characters listed above, this deprives them of their special
       meaning.&amp;nbsp; (There are no special escape sequences for Unicode characters, or tabs and
       newlines; these are all handled by a higher-level protocol.&amp;nbsp; In a Java string,
       &amp;quot;\n&amp;quot; will be converted to a literal newline character by the time the
       regular-expression parser sees it.&amp;nbsp; Of course, this means that \ sequences that are
       visible to the regexp parser must be written as \\ when inside a Java string.)&amp;nbsp; All
       characters in the ASCII range except for letters, digits, and control characters are
       reserved characters to the parser and must be preceded by \ even if they currently don&apos;t
       mean anything.&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;!&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;If ! appears at the beginning of a regular expression, it tells the regexp
       parser that this expression specifies the backwards-iteration behavior of the iterator,
       and not its normal iteration behavior.&amp;nbsp; This is generally only used in situations
       where the automatically-generated backwards-iteration brhavior doesn&apos;t produce
       satisfactory results and must be supplemented with extra client-specified rules.&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;&lt;em&gt;(all others)&lt;/em&gt;&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;All other characters are treated as literal characters, which must match
       the corresponding character(s) in the text exactly.&lt;/td&gt;
     &lt;/tr&gt;
   &lt;/table&gt;
 &lt;/blockquote&gt;

 &lt;p&gt;Within a [] expression, a number of other special characters can be used to specify
 groups of characters:&lt;/p&gt;

 &lt;blockquote&gt;
   &lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;-&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;Specifies a range of matching characters.&amp;nbsp; For example
       &amp;quot;[a-p]&amp;quot; matches all lowercase Latin letters from a to p (inclusive).&amp;nbsp; The -
       sign specifies ranges of continuous Unicode numeric values, not ranges of characters in a
       language&apos;s alphabetical order: &amp;quot;[a-z]&amp;quot; doesn&apos;t include capital letters, nor does
       it include accented letters such as a-umlaut.&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;::&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;A pair of colons containing a one- or two-letter code matches all
       characters in the corresponding Unicode category.&amp;nbsp; The two-letter codes are the same
       as the two-letter codes in the Unicode database (for example, &amp;quot;[:Sc::Sm:]&amp;quot;
       matches all currency symbols and all math symbols).&amp;nbsp; Specifying a one-letter code is
       the same as specifying all two-letter codes that begin with that letter (for example,
       &amp;quot;[:L:]&amp;quot; matches all letters, and is equivalent to
       &amp;quot;[:Lu::Ll::Lo::Lm::Lt:]&amp;quot;).&amp;nbsp; Anything other than a valid two-letter Unicode
       category code or a single letter that begins a Unicode category code is illegal within
       colons.&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;[]&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;[] expressions can nest.&amp;nbsp; This has no effect, except when used in
       conjunction with the ^ token.&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;^&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;Excludes the character (or the characters in the [] expression) following
       it from the group of characters.&amp;nbsp; For example, &amp;quot;[a-z^p]&amp;quot; matches all Latin
       lowercase letters except p.&amp;nbsp; &amp;quot;[:L:^[&amp;#92;u4e00-&amp;#92;u9fff]]&amp;quot; matches all letters
       except the Han ideographs.&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td width=&quot;6%&quot;&gt;&lt;em&gt;(all others)&lt;/em&gt;&lt;/td&gt;
       &lt;td width=&quot;94%&quot;&gt;All other characters are treated as literal characters.&amp;nbsp; (For
       example, &amp;quot;[aeiou]&amp;quot; specifies just the letters a, e, i, o, and u.)&lt;/td&gt;
     &lt;/tr&gt;
   &lt;/table&gt;
 &lt;/blockquote&gt;

 &lt;p&gt;For a more complete explanation, see &lt;a
 href=&quot;http://www.ibm.com/java/education/boundaries/boundaries.html&quot;&gt;http://www.ibm.com/java/education/boundaries/boundaries.html&lt;/a&gt;.
 &amp;nbsp; For examples, see the resource data (which is annotated).&lt;/p&gt;</description>
			<attribute name="@author">
				<description>Richard Gillam</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-1" visibility="protected" name="IGNORE" constexpr="-1" fulltype="byte" type="byte">
				<comment>
					<description>A token used as a character-category value to identify ignore characters</description>
				</comment>
			</field>
			<field final="true" static="true" const="1" visibility="private" name="START_STATE" constexpr="1" fulltype="short" type="short">
				<comment>
					<description>The state number of the starting state</description>
				</comment>
			</field>
			<field final="true" static="true" const="0" visibility="private" name="STOP_STATE" constexpr="0" fulltype="short" type="short">
				<comment>
					<description>The state-transition value indicating &quot;stop&quot;</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="package-private" name="LABEL" fulltype="byte[]" type="byte">
				<comment>
					<description>Magic number for the BreakIterator data file format.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="package-private" name="LABEL_LENGTH" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="package-private" name="supportedVersion" constexpr="1" fulltype="byte" type="byte">
				<comment>
					<description>Version number of the dictionary that was read in.</description>
				</comment>
			</field>
			<field final="true" static="true" const="36" visibility="private" name="HEADER_LENGTH" constexpr="36" fulltype="int" type="int">
				<comment>
					<description>Header size in byte count</description>
				</comment>
			</field>
			<field final="true" static="true" const="512" visibility="private" name="BMP_INDICES_LENGTH" constexpr="512" fulltype="int" type="int">
				<comment>
					<description>An array length of indices for BMP characters</description>
				</comment>
			</field>
			<field visibility="private" name="charCategoryTable" fulltype="sun.text.CompactByteArray" type="CompactByteArray">
				<comment>
					<description>Tables that indexes from character values to character category numbers</description>
				</comment>
			</field>
			<field visibility="private" name="supplementaryCharCategoryTable" fulltype="sun.text.SupplementaryCharacterData" type="SupplementaryCharacterData" />
			<field visibility="private" name="stateTable" fulltype="short[]" type="short">
				<comment>
					<description>The table of state transitions used for forward iteration</description>
				</comment>
			</field>
			<field visibility="private" name="backwardsStateTable" fulltype="short[]" type="short">
				<comment>
					<description>The table of state transitions used to sync up the iterator with the
 text in backwards and random-access iteration</description>
				</comment>
			</field>
			<field visibility="private" name="endStates" fulltype="boolean[]" type="boolean">
				<comment>
					<description>A list of flags indicating which states in the state table are accepting
 (&quot;end&quot;) states</description>
				</comment>
			</field>
			<field visibility="private" name="lookaheadStates" fulltype="boolean[]" type="boolean">
				<comment>
					<description>A list of flags indicating which states in the state table are
 lookahead states (states which turn lookahead on and off)</description>
				</comment>
			</field>
			<field visibility="private" name="additionalData" fulltype="byte[]" type="byte">
				<comment>
					<description>A table for additional data. May be used by a subclass of
 RuleBasedBreakIterator.</description>
				</comment>
			</field>
			<field visibility="private" name="numCategories" fulltype="int" type="int">
				<comment>
					<description>The number of character categories (and, thus, the number of columns in
 the state tables)</description>
				</comment>
			</field>
			<field visibility="private" name="text" fulltype="java.text.CharacterIterator" type="CharacterIterator">
				<comment>
					<description>The character iterator through which this BreakIterator accesses the text</description>
				</comment>
			</field>
			<field visibility="private" name="checksum" fulltype="long" type="long">
				<comment>
					<description>A CRC32 value of all data in datafile</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="RuleBasedBreakIterator">
				<comment>
					<description>Constructs a RuleBasedBreakIterator according to the datafile
 provided.</description>
				</comment>
				<params>
					<param name="datafile" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.util.MissingResourceException" type="MissingResourceException" />
				</exceptions>
			</constructor>
			<method visibility="protected" name="readTables" fulltype="void" type="void">
				<comment>
					<description>Read datafile. The datafile&apos;s format is as follows:
 &lt;pre&gt;
   BreakIteratorData {
       u1           magic[7];
       u1           version;
       u4           totalDataSize;
       header_info  header;
       body         value;
   }
 &lt;/pre&gt;
 &lt;code&gt;totalDataSize&lt;/code&gt; is the summation of the size of
 &lt;code&gt;header_info&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt; in byte count.
 &lt;p&gt;
 In &lt;code&gt;header&lt;/code&gt;, each field except for checksum implies the
 length of each field. Since &lt;code&gt;BMPdataLength&lt;/code&gt; is a fixed-length
  data(512 entries), its length isn&apos;t included in &lt;code&gt;header&lt;/code&gt;.
 &lt;code&gt;checksum&lt;/code&gt; is a CRC32 value of all in &lt;code&gt;body&lt;/code&gt;.
 &lt;pre&gt;
   header_info {
       u4           stateTableLength;
       u4           backwardsStateTableLength;
       u4           endStatesLength;
       u4           lookaheadStatesLength;
       u4           BMPdataLength;
       u4           nonBMPdataLength;
       u4           additionalDataLength;
       u8           checksum;
   }
 &lt;/pre&gt;
 &lt;p&gt;

 Finally, &lt;code&gt;BMPindices&lt;/code&gt; and &lt;code&gt;BMPdata&lt;/code&gt; are set to
 &lt;code&gt;charCategoryTable&lt;/code&gt;. &lt;code&gt;nonBMPdata&lt;/code&gt; is set to
 &lt;code&gt;supplementaryCharCategoryTable&lt;/code&gt;.
 &lt;pre&gt;
   body {
       u2           stateTable[stateTableLength];
       u2           backwardsStateTable[backwardsStateTableLength];
       u1           endStates[endStatesLength];
       u1           lookaheadStates[lookaheadStatesLength];
       u2           BMPindices[512];
       u1           BMPdata[BMPdataLength];
       u4           nonBMPdata[numNonBMPdataLength];
       u1           additionalData[additionalDataLength];
   }
 &lt;/pre&gt;</description>
				</comment>
				<params>
					<param name="datafile" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.util.MissingResourceException" type="MissingResourceException" />
				</exceptions>
			</method>
			<method visibility="protected" name="readFile" fulltype="byte[]" type="byte">
				<params>
					<param name="datafile" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.util.MissingResourceException" type="MissingResourceException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="getAdditionalData" fulltype="byte[]" type="byte" />
			<method visibility="package-private" name="setAdditionalData" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
				</params>
			</method>
			<method visibility="public" name="clone" returncomment="A newly-constructed RuleBasedBreakIterator with the same
 behavior as this one." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Clones this iterator.</description>
					<attribute name="@return">
						<description>A newly-constructed RuleBasedBreakIterator with the same
 behavior as this one.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if both BreakIterators are of the same class, have the same
 rules, and iterate over the same text.</description>
				</comment>
				<params>
					<param name="that" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="toString" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns text</description>
				</comment>
			</method>
			<method visibility="public" name="hashCode" returncomment="A hash code" fulltype="int" type="int">
				<comment>
					<description>Compute a hashcode for this BreakIterator</description>
					<attribute name="@return">
						<description>A hash code</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="first" returncomment="The offset of the beginning of the text." fulltype="int" type="int">
				<comment>
					<description>Sets the current iteration position to the beginning of the text.
 (i.e., the CharacterIterator&apos;s starting offset).</description>
					<attribute name="@return">
						<description>The offset of the beginning of the text.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="last" returncomment="The text&apos;s past-the-end offset." fulltype="int" type="int">
				<comment>
					<description>Sets the current iteration position to the end of the text.
 (i.e., the CharacterIterator&apos;s ending offset).</description>
					<attribute name="@return">
						<description>The text&apos;s past-the-end offset.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="next" returncomment="The character offset of the boundary position n boundaries away from
 the current one." fulltype="int" type="int">
				<comment>
					<description>Advances the iterator either forward or backward the specified number of steps.
 Negative values move backward, and positive values move forward.  This is
 equivalent to repeatedly calling next() or previous().</description>
					<attribute name="@param">
						<description>n The number of steps to move.  The sign indicates the direction
 (negative is backwards, and positive is forwards).</description>
					</attribute>
					<attribute name="@return">
						<description>The character offset of the boundary position n boundaries away from
 the current one.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="The number of steps to move.  The sign indicates the direction
 (negative is backwards, and positive is forwards)." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="next" returncomment="The position of the first boundary after this one." fulltype="int" type="int">
				<comment>
					<description>Advances the iterator to the next boundary position.</description>
					<attribute name="@return">
						<description>The position of the first boundary after this one.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="previous" returncomment="The position of the last boundary position preceding this one." fulltype="int" type="int">
				<comment>
					<description>Advances the iterator backwards, to the last boundary preceding this one.</description>
					<attribute name="@return">
						<description>The position of the last boundary position preceding this one.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="private" name="getPrevious" fulltype="int" type="int">
				<comment>
					<description>Returns previous character</description>
				</comment>
			</method>
			<method visibility="package-private" name="getCurrent" fulltype="int" type="int">
				<comment>
					<description>Returns current character</description>
				</comment>
			</method>
			<method visibility="private" name="getCurrentCodePointCount" fulltype="int" type="int">
				<comment>
					<description>Returns the count of next character.</description>
				</comment>
			</method>
			<method visibility="package-private" name="getNext" fulltype="int" type="int">
				<comment>
					<description>Returns next character</description>
				</comment>
			</method>
			<method visibility="private" name="getNextIndex" fulltype="int" type="int">
				<comment>
					<description>Returns the position of next character.</description>
				</comment>
			</method>
			<method final="true" static="true" visibility="protected" name="checkOffset" fulltype="void" type="void">
				<comment>
					<description>Throw IllegalArgumentException unless begin &lt;= offset &lt; end.</description>
				</comment>
				<params>
					<param name="offset" fulltype="int" type="int" />
					<param name="text" fulltype="java.text.CharacterIterator" type="CharacterIterator" />
				</params>
			</method>
			<method visibility="public" name="following" returncomment="The position of the first break after the current position." fulltype="int" type="int">
				<comment>
					<description>Sets the iterator to refer to the first boundary position following
 the specified position.</description>
					<attribute name="@offset">
						<description>The position from which to begin searching for a break position.</description>
					</attribute>
					<attribute name="@return">
						<description>The position of the first break after the current position.</description>
					</attribute>
				</comment>
				<params>
					<param name="offset" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="preceding" returncomment="The position of the last boundary before the starting position." fulltype="int" type="int">
				<comment>
					<description>Sets the iterator to refer to the last boundary position before the
 specified position.</description>
					<attribute name="@offset">
						<description>The position to begin searching for a break from.</description>
					</attribute>
					<attribute name="@return">
						<description>The position of the last boundary before the starting position.</description>
					</attribute>
				</comment>
				<params>
					<param name="offset" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="isBoundary" returncomment="True if &quot;offset&quot; is a boundary position." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if the specfied position is a boundary position.  As a side
 effect, leaves the iterator pointing to the first boundary position at
 or after &quot;offset&quot;.</description>
					<attribute name="@param">
						<description>offset the offset to check.</description>
					</attribute>
					<attribute name="@return">
						<description>True if &quot;offset&quot; is a boundary position.</description>
					</attribute>
				</comment>
				<params>
					<param name="offset" comment="the offset to check." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="current" returncomment="The current iteration position." fulltype="int" type="int">
				<comment>
					<description>Returns the current iteration position.</description>
					<attribute name="@return">
						<description>The current iteration position.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getText" returncomment="An iterator over the text being analyzed." fulltype="java.text.CharacterIterator" type="CharacterIterator">
				<comment>
					<description>Return a CharacterIterator over the text being analyzed.  This version
 of this method returns the actual CharacterIterator we&apos;re using internally.
 Changing the state of this iterator can have undefined consequences.  If
 you need to change it, clone it first.</description>
					<attribute name="@return">
						<description>An iterator over the text being analyzed.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setText" fulltype="void" type="void">
				<comment>
					<description>Set the iterator to analyze a new piece of text.  This function resets
 the current iteration position to the beginning of the text.</description>
					<attribute name="@param">
						<description>newText An iterator over the text to analyze.</description>
					</attribute>
				</comment>
				<params>
					<param name="newText" comment="An iterator over the text to analyze." fulltype="java.text.CharacterIterator" type="CharacterIterator" />
				</params>
			</method>
			<method visibility="protected" name="handleNext" fulltype="int" type="int">
				<comment>
					<description>This method is the actual implementation of the next() method.  All iteration
 vectors through here.  This method initializes the state machine to state 1
 and advances through the text character by character until we reach the end
 of the text or the state machine transitions to state 0.  We update our return
 value every time the state machine passes through a possible end state.</description>
				</comment>
			</method>
			<method visibility="protected" name="handlePrevious" fulltype="int" type="int">
				<comment>
					<description>This method backs the iterator back up to a &quot;safe position&quot; in the text.
 This is a position that we know, without any context, must be a break position.
 The various calling methods then iterate forward from this safe position to
 the appropriate position to return.  (For more information, see the description
 of buildBackwardsStateTable() in RuleBasedBreakIterator.Builder.)</description>
				</comment>
			</method>
			<method visibility="protected" name="lookupCategory" fulltype="int" type="int">
				<comment>
					<description>Looks up a character&apos;s category (i.e., its category for breaking purposes,
 not its Unicode category)</description>
				</comment>
				<params>
					<param name="c" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="protected" name="lookupState" fulltype="int" type="int">
				<comment>
					<description>Given a current state and a character category, looks up the
 next state to transition to in the state table.</description>
				</comment>
				<params>
					<param name="state" fulltype="int" type="int" />
					<param name="category" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="protected" name="lookupBackwardState" fulltype="int" type="int">
				<comment>
					<description>Given a current state and a character category, looks up the
 next state to transition to in the backwards state table.</description>
				</comment>
				<params>
					<param name="state" fulltype="int" type="int" />
					<param name="category" fulltype="int" type="int" />
				</params>
			</method>
		</methods>
		<jelclass final="true" superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.RuleBasedBreakIterator.SafeCharIterator" type="RuleBasedBreakIterator.SafeCharIterator">
			<implements>
				<interface fulltype="java.text.CharacterIterator" type="CharacterIterator" />
				<interface fulltype="java.lang.Cloneable" type="Cloneable" />
			</implements>
			<fields>
				<field visibility="private" name="base" fulltype="java.text.CharacterIterator" type="CharacterIterator" />
				<field visibility="private" name="rangeStart" fulltype="int" type="int" />
				<field visibility="private" name="rangeLimit" fulltype="int" type="int" />
				<field visibility="private" name="currentIndex" fulltype="int" type="int" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="RuleBasedBreakIterator.SafeCharIterator">
					<params>
						<param name="base" fulltype="java.text.CharacterIterator" type="CharacterIterator" />
					</params>
				</constructor>
				<method visibility="public" name="first" fulltype="char" type="char" />
				<method visibility="public" name="last" fulltype="char" type="char" />
				<method visibility="public" name="current" fulltype="char" type="char" />
				<method visibility="public" name="next" fulltype="char" type="char" />
				<method visibility="public" name="previous" fulltype="char" type="char" />
				<method visibility="public" name="setIndex" fulltype="char" type="char">
					<params>
						<param name="i" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="public" name="getBeginIndex" fulltype="int" type="int" />
				<method visibility="public" name="getEndIndex" fulltype="int" type="int" />
				<method visibility="public" name="getIndex" fulltype="int" type="int" />
				<method visibility="public" name="clone" fulltype="java.lang.Object" type="Object" />
			</methods>
		</jelclass>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.RuleBasedBreakIterator.SafeCharIterator" type="RuleBasedBreakIterator.SafeCharIterator">
		<implements>
			<interface fulltype="java.text.CharacterIterator" type="CharacterIterator" />
			<interface fulltype="java.lang.Cloneable" type="Cloneable" />
		</implements>
		<fields>
			<field visibility="private" name="base" fulltype="java.text.CharacterIterator" type="CharacterIterator" />
			<field visibility="private" name="rangeStart" fulltype="int" type="int" />
			<field visibility="private" name="rangeLimit" fulltype="int" type="int" />
			<field visibility="private" name="currentIndex" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="RuleBasedBreakIterator.SafeCharIterator">
				<params>
					<param name="base" fulltype="java.text.CharacterIterator" type="CharacterIterator" />
				</params>
			</constructor>
			<method visibility="public" name="first" fulltype="char" type="char" />
			<method visibility="public" name="last" fulltype="char" type="char" />
			<method visibility="public" name="current" fulltype="char" type="char" />
			<method visibility="public" name="next" fulltype="char" type="char" />
			<method visibility="public" name="previous" fulltype="char" type="char" />
			<method visibility="public" name="setIndex" fulltype="char" type="char">
				<params>
					<param name="i" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getBeginIndex" fulltype="int" type="int" />
			<method visibility="public" name="getEndIndex" fulltype="int" type="int" />
			<method visibility="public" name="getIndex" fulltype="int" type="int" />
			<method visibility="public" name="clone" fulltype="java.lang.Object" type="Object" />
		</methods>
	</jelclass>
	<jelclass superclass="NumberFormat" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.NumberFormat" fulltype="java.text.ChoiceFormat" type="ChoiceFormat">
		<comment>
			<description>A &lt;code&gt;ChoiceFormat&lt;/code&gt; allows you to attach a format to a range of numbers.
 It is generally used in a &lt;code&gt;MessageFormat&lt;/code&gt; for handling plurals.
 The choice is specified with an ascending list of doubles, where each item
 specifies a half-open interval up to the next item:
 &lt;blockquote&gt;
 &lt;pre&gt;
 X matches j if and only if limit[j] &amp;lt;= X &amp;lt; limit[j+1]
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 If there is no match, then either the first or last index is used, depending
 on whether the number (X) is too low or too high.  If the limit array is not
 in ascending order, the results of formatting will be incorrect.  ChoiceFormat
 also accepts &lt;code&gt;&amp;#92;u221E&lt;/code&gt; as equivalent to infinity(INF).

 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt;
 &lt;code&gt;ChoiceFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;
 classes in that you create a &lt;code&gt;ChoiceFormat&lt;/code&gt; object with a
 constructor (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory
 method). The factory methods aren&apos;t necessary because &lt;code&gt;ChoiceFormat&lt;/code&gt;
 doesn&apos;t require any complex setup for a given locale. In fact,
 &lt;code&gt;ChoiceFormat&lt;/code&gt; doesn&apos;t implement any locale specific behavior.

 &lt;p&gt;
 When creating a &lt;code&gt;ChoiceFormat&lt;/code&gt;, you must specify an array of formats
 and an array of limits. The length of these arrays must be the same.
 For example,
 &lt;ul&gt;
 &lt;li&gt;
     &lt;em&gt;limits&lt;/em&gt; = {1,2,3,4,5,6,7}&lt;br&gt;
     &lt;em&gt;formats&lt;/em&gt; = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thur&quot;,&quot;Fri&quot;,&quot;Sat&quot;}
 &lt;li&gt;
     &lt;em&gt;limits&lt;/em&gt; = {0, 1, ChoiceFormat.nextDouble(1)}&lt;br&gt;
     &lt;em&gt;formats&lt;/em&gt; = {&quot;no files&quot;, &quot;one file&quot;, &quot;many files&quot;}&lt;br&gt;
     (&lt;code&gt;nextDouble&lt;/code&gt; can be used to get the next higher double, to
     make the half-open interval.)
 &lt;/ul&gt;

 &lt;p&gt;
 Here is a simple example that shows formatting and parsing:
 &lt;blockquote&gt;
 &lt;pre&gt;
 double[] limits = {1,2,3,4,5,6,7};
 String[] dayOfWeekNames = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thur&quot;,&quot;Fri&quot;,&quot;Sat&quot;};
 ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);
 ParsePosition status = new ParsePosition(0);
 for (double i = 0.0; i &amp;lt;= 8.0; ++i) {
     status.setIndex(0);
     System.out.println(i + &quot; -&amp;gt; &quot; + form.format(i) + &quot; -&amp;gt; &quot;
                              + form.parse(form.format(i),status));
 }
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 Here is a more complex example, with a pattern format:
 &lt;blockquote&gt;
 &lt;pre&gt;
 double[] filelimits = {0,1,2};
 String[] filepart = {&quot;are no files&quot;,&quot;is one file&quot;,&quot;are {2} files&quot;};
 ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
 Format[] testFormats = {fileform, null, NumberFormat.getInstance()};
 MessageFormat pattform = new MessageFormat(&quot;There {0} on {1}&quot;);
 pattform.setFormats(testFormats);
 Object[] testArgs = {null, &quot;ADisk&quot;, null};
 for (int i = 0; i &amp;lt; 4; ++i) {
     testArgs[0] = new Integer(i);
     testArgs[2] = testArgs[0];
     System.out.println(pattform.format(testArgs));
 }
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
 Specifying a pattern for ChoiceFormat objects is fairly straightforward.
 For example:
 &lt;blockquote&gt;
 &lt;pre&gt;
 ChoiceFormat fmt = new ChoiceFormat(
      &quot;-1#is negative| 0#is zero or fraction | 1#is one |1.0&amp;lt;is 1+ |2#is two |2&amp;lt;is more than 2.&quot;);
 System.out.println(&quot;Formatter Pattern : &quot; + fmt.toPattern());

 System.out.println(&quot;Format with -INF : &quot; + fmt.format(Double.NEGATIVE_INFINITY));
 System.out.println(&quot;Format with -1.0 : &quot; + fmt.format(-1.0));
 System.out.println(&quot;Format with 0 : &quot; + fmt.format(0));
 System.out.println(&quot;Format with 0.9 : &quot; + fmt.format(0.9));
 System.out.println(&quot;Format with 1.0 : &quot; + fmt.format(1));
 System.out.println(&quot;Format with 1.5 : &quot; + fmt.format(1.5));
 System.out.println(&quot;Format with 2 : &quot; + fmt.format(2));
 System.out.println(&quot;Format with 2.1 : &quot; + fmt.format(2.1));
 System.out.println(&quot;Format with NaN : &quot; + fmt.format(Double.NaN));
 System.out.println(&quot;Format with +INF : &quot; + fmt.format(Double.POSITIVE_INFINITY));
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 And the output result would be like the following:
 &lt;pre&gt;
 &lt;blockquote&gt;
   Format with -INF : is negative
   Format with -1.0 : is negative
   Format with 0 : is zero or fraction
   Format with 0.9 : is zero or fraction
   Format with 1.0 : is one
   Format with 1.5 : is 1+
   Format with 2 : is two
   Format with 2.1 : is more than 2.
   Format with NaN : is negative
   Format with +INF : is more than 2.
 &lt;/pre&gt;
 &lt;/blockquote&gt;

 &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;

 &lt;p&gt;
 Choice formats are not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently, it must be synchronized
 externally.</description>
			<attribute name="@see">
				<description>DecimalFormat</description>
			</attribute>
			<attribute name="@see">
				<description>MessageFormat</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Davis</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="1795184449645032964" visibility="private" name="serialVersionUID" constexpr="1795184449645032964L" fulltype="long" type="long" />
			<field visibility="private" name="choiceLimits" fulltype="double[]" type="double">
				<comment>
					<description>A list of lower bounds for the choices.  The formatter will return
 &lt;code&gt;choiceFormats[i]&lt;/code&gt; if the number being formatted is greater than or equal to
 &lt;code&gt;choiceLimits[i]&lt;/code&gt; and less than &lt;code&gt;choiceLimits[i+1]&lt;/code&gt;.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" name="choiceFormats" fulltype="java.lang.String[]" type="String">
				<comment>
					<description>A list of choice strings.  The formatter will return
 &lt;code&gt;choiceFormats[i]&lt;/code&gt; if the number being formatted is greater than or equal to
 &lt;code&gt;choiceLimits[i]&lt;/code&gt; and less than &lt;code&gt;choiceLimits[i+1]&lt;/code&gt;.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field final="true" static="true" const="-9223372036854775808" visibility="package-private" name="SIGN" constexpr="-9223372036854775808L" fulltype="long" type="long" />
			<field final="true" static="true" const="9218868437227405312" visibility="package-private" name="EXPONENT" constexpr="9218868437227405312L" fulltype="long" type="long" />
			<field final="true" static="true" const="9218868437227405312" visibility="package-private" name="POSITIVEINFINITY" constexpr="9218868437227405312L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="public" name="ChoiceFormat">
				<comment>
					<description>Constructs with limits and corresponding formats based on the pattern.</description>
					<attribute name="@see">
						<description>#applyPattern</description>
					</attribute>
				</comment>
				<params>
					<param name="newPattern" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="ChoiceFormat">
				<comment>
					<description>Constructs with the limits and the corresponding formats.</description>
					<attribute name="@see">
						<description>#setChoices</description>
					</attribute>
				</comment>
				<params>
					<param name="limits" fulltype="double[]" type="double" />
					<param name="formats" fulltype="java.lang.String[]" type="String" />
				</params>
			</constructor>
			<method visibility="public" name="applyPattern" fulltype="void" type="void">
				<comment>
					<description>Sets the pattern.</description>
					<attribute name="@param">
						<description>newPattern See the class description.</description>
					</attribute>
				</comment>
				<params>
					<param name="newPattern" comment="See the class description." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="toPattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the pattern.</description>
				</comment>
			</method>
			<method visibility="public" name="setChoices" fulltype="void" type="void">
				<comment>
					<description>Set the choices to be used in formatting.</description>
					<attribute name="@param">
						<description>limits contains the top value that you want
 parsed with that format,and should be in ascending sorted order. When
 formatting X, the choice will be the i, where
 limit[i] &amp;lt;= X &amp;lt; limit[i+1].
 If the limit array is not in ascending order, the results of formatting
 will be incorrect.</description>
					</attribute>
					<attribute name="@param">
						<description>formats are the formats you want to use for each limit.
 They can be either Format objects or Strings.
 When formatting with object Y,
 if the object is a NumberFormat, then ((NumberFormat) Y).format(X)
 is called. Otherwise Y.toString() is called.</description>
					</attribute>
				</comment>
				<params>
					<param name="limits" comment="contains the top value that you want
 parsed with that format,and should be in ascending sorted order. When
 formatting X, the choice will be the i, where
 limit[i] &amp;lt;= X &amp;lt; limit[i+1].
 If the limit array is not in ascending order, the results of formatting
 will be incorrect." fulltype="double[]" type="double" />
					<param name="formats" comment="are the formats you want to use for each limit.
 They can be either Format objects or Strings.
 When formatting with object Y,
 if the object is a NumberFormat, then ((NumberFormat) Y).format(X)
 is called. Otherwise Y.toString() is called." fulltype="java.lang.String[]" type="String" />
				</params>
			</method>
			<method visibility="public" name="getLimits" returncomment="the limits." fulltype="double[]" type="double">
				<comment>
					<description>Get the limits passed in the constructor.</description>
					<attribute name="@return">
						<description>the limits.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getFormats" returncomment="the formats." fulltype="java.lang.Object[]" type="Object">
				<comment>
					<description>Get the formats passed in the constructor.</description>
					<attribute name="@return">
						<description>the formats.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="format" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Specialization of format. This method really calls
 &lt;code&gt;format(double, StringBuffer, FieldPosition)&lt;/code&gt;
 thus the range of longs that are supported is only equal to
 the range that can be stored by double. This will never be
 a practical limitation.</description>
				</comment>
				<params>
					<param name="number" fulltype="long" type="long" />
					<param name="toAppendTo" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="status" fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method visibility="public" name="format" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Returns pattern with formatted double.</description>
					<attribute name="@param">
						<description>number number to be formatted &amp; substituted.</description>
					</attribute>
					<attribute name="@param">
						<description>toAppendTo where text is appended.</description>
					</attribute>
					<attribute name="@param">
						<description>status ignore no useful status is returned.</description>
					</attribute>
				</comment>
				<params>
					<param name="number" comment="number to be formatted &amp; substituted." fulltype="double" type="double" />
					<param name="toAppendTo" comment="where text is appended." fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="status" comment="ignore no useful status is returned." fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method visibility="public" name="parse" returncomment="A Number representing the value of the number parsed." fulltype="java.lang.Number" type="Number">
				<comment>
					<description>Parses a Number from the input text.</description>
					<attribute name="@param">
						<description>text the source text.</description>
					</attribute>
					<attribute name="@param">
						<description>status an input-output parameter.  On input, the
 status.index field indicates the first character of the
 source text that should be parsed.  On exit, if no error
 occured, status.index is set to the first unparsed character
 in the source text.  On exit, if an error did occur,
 status.index is unchanged and status.errorIndex is set to the
 first index of the character that caused the parse to fail.</description>
					</attribute>
					<attribute name="@return">
						<description>A Number representing the value of the number parsed.</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="the source text." fulltype="java.lang.String" type="String" />
					<param name="status" comment="an input-output parameter.  On input, the
 status.index field indicates the first character of the
 source text that should be parsed.  On exit, if no error
 occured, status.index is set to the first unparsed character
 in the source text.  On exit, if an error did occur,
 status.index is unchanged and status.errorIndex is set to the
 first index of the character that caused the parse to fail." fulltype="java.text.ParsePosition" type="ParsePosition" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="nextDouble" fulltype="double" type="double">
				<comment>
					<description>Finds the least double greater than d.
 If NaN, returns same value.
 &lt;p&gt;Used to make half-open intervals.</description>
					<attribute name="@see">
						<description>#previousDouble</description>
					</attribute>
				</comment>
				<params>
					<param name="d" fulltype="double" type="double" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="previousDouble" fulltype="double" type="double">
				<comment>
					<description>Finds the greatest double less than d.
 If NaN, returns same value.</description>
					<attribute name="@see">
						<description>#nextDouble</description>
					</attribute>
				</comment>
				<params>
					<param name="d" fulltype="double" type="double" />
				</params>
			</method>
			<method visibility="public" name="clone" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Overrides Cloneable</description>
				</comment>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Generates a hash code for the message format object.</description>
				</comment>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Equality comparision between two</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<comment>
					<description>After reading an object from the input stream, do a simple verification
 to maintain class invariants.</description>
					<attribute name="@throws">
						<description>InvalidObjectException if the objects read from the stream is invalid.</description>
					</attribute>
				</comment>
				<params>
					<param name="in" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method static="true" visibility="public" name="nextDouble" fulltype="double" type="double">
				<comment>
					<description>Finds the least double greater than d (if positive == true),
 or the greatest double less than d (if positive == false).
 If NaN, returns same value.

 Does not affect floating-point flags,
 provided these member functions do not:
          Double.longBitsToDouble(long)
          Double.doubleToLongBits(double)
          Double.isNaN(double)</description>
				</comment>
				<params>
					<param name="d" fulltype="double" type="double" />
					<param name="positive" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method static="true" visibility="private" name="doubleArraySize" fulltype="double[]" type="double">
				<params>
					<param name="array" fulltype="double[]" type="double" />
				</params>
			</method>
			<method visibility="private" name="doubleArraySize" fulltype="java.lang.String[]" type="String">
				<params>
					<param name="array" fulltype="java.lang.String[]" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.BreakIterator" type="BreakIterator">
		<implements>
			<interface fulltype="java.lang.Cloneable" type="Cloneable" />
		</implements>
		<comment>
			<description>The &lt;code&gt;BreakIterator&lt;/code&gt; class implements methods for finding
 the location of boundaries in text. Instances of &lt;code&gt;BreakIterator&lt;/code&gt;
 maintain a current position and scan over text
 returning the index of characters where boundaries occur.
 Internally, &lt;code&gt;BreakIterator&lt;/code&gt; scans text using a
 &lt;code&gt;CharacterIterator&lt;/code&gt;, and is thus able to scan text held
 by any object implementing that protocol. A &lt;code&gt;StringCharacterIterator&lt;/code&gt;
 is used to scan &lt;code&gt;String&lt;/code&gt; objects passed to &lt;code&gt;setText&lt;/code&gt;.

 &lt;p&gt;
 You use the factory methods provided by this class to create
 instances of various types of break iterators. In particular,
 use &lt;code&gt;getWordInstance&lt;/code&gt;, &lt;code&gt;getLineInstance&lt;/code&gt;,
 &lt;code&gt;getSentenceInstance&lt;/code&gt;, and &lt;code&gt;getCharacterInstance&lt;/code&gt;
 to create &lt;code&gt;BreakIterator&lt;/code&gt;s that perform
 word, line, sentence, and character boundary analysis respectively.
 A single &lt;code&gt;BreakIterator&lt;/code&gt; can work only on one unit
 (word, line, sentence, and so on). You must use a different iterator
 for each unit boundary analysis you wish to perform.

 &lt;p&gt;&lt;a name=&quot;line&quot;&gt;&lt;/a&gt;
 Line boundary analysis determines where a text string can be
 broken when line-wrapping. The mechanism correctly handles
 punctuation and hyphenated words. Actual line breaking needs
 to also consider the available line width and is handled by
 higher-level software.

 &lt;p&gt;&lt;a name=&quot;sentence&quot;&gt;&lt;/a&gt;
 Sentence boundary analysis allows selection with correct interpretation
 of periods within numbers and abbreviations, and trailing punctuation
 marks such as quotation marks and parentheses.

 &lt;p&gt;&lt;a name=&quot;word&quot;&gt;&lt;/a&gt;
 Word boundary analysis is used by search and replace functions, as
 well as within text editing applications that allow the user to
 select words with a double click. Word selection provides correct
 interpretation of punctuation marks within and following
 words. Characters that are not part of a word, such as symbols
 or punctuation marks, have word-breaks on both sides.

 &lt;p&gt;&lt;a name=&quot;character&quot;&gt;&lt;/a&gt;
 Character boundary analysis allows users to interact with characters
 as they expect to, for example, when moving the cursor through a text
 string. Character boundary analysis provides correct navigation
 through character strings, regardless of how the character is stored.
 The boundaries returned may be those of supplementary characters,
 combining character sequences, or ligature clusters.
 For example, an accented character might be stored as a base character
 and a diacritical mark. What users consider to be a character can
 differ between languages.

 &lt;p&gt;
 The &lt;code&gt;BreakIterator&lt;/code&gt; instances returned by the factory methods
 of this class are intended for use with natural languages only, not for
 programming language text. It is however possible to define subclasses
 that tokenize a programming language.

 &lt;P&gt;
 &lt;strong&gt;Examples&lt;/strong&gt;:&lt;P&gt;
 Creating and using text boundaries:
 &lt;blockquote&gt;
 &lt;pre&gt;
 public static void main(String args[]) {
      if (args.length == 1) {
          String stringToExamine = args[0];
          //print each word in order
          BreakIterator boundary = BreakIterator.getWordInstance();
          boundary.setText(stringToExamine);
          printEachForward(boundary, stringToExamine);
          //print each sentence in reverse order
          boundary = BreakIterator.getSentenceInstance(Locale.US);
          boundary.setText(stringToExamine);
          printEachBackward(boundary, stringToExamine);
          printFirst(boundary, stringToExamine);
          printLast(boundary, stringToExamine);
      }
 }
 &lt;/pre&gt;
 &lt;/blockquote&gt;

 Print each element in order:
 &lt;blockquote&gt;
 &lt;pre&gt;
 public static void printEachForward(BreakIterator boundary, String source) {
     int start = boundary.first();
     for (int end = boundary.next();
          end != BreakIterator.DONE;
          start = end, end = boundary.next()) {
          System.out.println(source.substring(start,end));
     }
 }
 &lt;/pre&gt;
 &lt;/blockquote&gt;

 Print each element in reverse order:
 &lt;blockquote&gt;
 &lt;pre&gt;
 public static void printEachBackward(BreakIterator boundary, String source) {
     int end = boundary.last();
     for (int start = boundary.previous();
          start != BreakIterator.DONE;
          end = start, start = boundary.previous()) {
         System.out.println(source.substring(start,end));
     }
 }
 &lt;/pre&gt;
 &lt;/blockquote&gt;

 Print first element:
 &lt;blockquote&gt;
 &lt;pre&gt;
 public static void printFirst(BreakIterator boundary, String source) {
     int start = boundary.first();
     int end = boundary.next();
     System.out.println(source.substring(start,end));
 }
 &lt;/pre&gt;
 &lt;/blockquote&gt;

 Print last element:
 &lt;blockquote&gt;
 &lt;pre&gt;
 public static void printLast(BreakIterator boundary, String source) {
     int end = boundary.last();
     int start = boundary.previous();
     System.out.println(source.substring(start,end));
 }
 &lt;/pre&gt;
 &lt;/blockquote&gt;

 Print the element at a specified position:
 &lt;blockquote&gt;
 &lt;pre&gt;
 public static void printAt(BreakIterator boundary, int pos, String source) {
     int end = boundary.following(pos);
     int start = boundary.previous();
     System.out.println(source.substring(start,end));
 }
 &lt;/pre&gt;
 &lt;/blockquote&gt;

 Find the next word:
 &lt;blockquote&gt;
 &lt;pre&gt;
 public static int nextWordStartAfter(int pos, String text) {
     BreakIterator wb = BreakIterator.getWordInstance();
     wb.setText(text);
     int last = wb.following(pos);
     int current = wb.next();
     while (current != BreakIterator.DONE) {
         for (int p = last; p &lt; current; p++) {
             if (Character.isLetter(text.codePointAt(p)))
                 return last;
         }
         last = current;
         current = wb.next();
     }
     return BreakIterator.DONE;
 }
 &lt;/pre&gt;
 (The iterator returned by BreakIterator.getWordInstance() is unique in that
 the break positions it returns don&apos;t represent both the start and end of the
 thing being iterated over.  That is, a sentence-break iterator returns breaks
 that each represent the end of one sentence and the beginning of the next.
 With the word-break iterator, the characters between two boundaries might be a
 word, or they might be the punctuation or whitespace between two words.  The
 above code uses a simple heuristic to determine which boundary is the beginning
 of a word: If the characters between this boundary and the next boundary
 include at least one letter (this can be an alphabetical letter, a CJK ideograph,
 a Hangul syllable, a Kana character, etc.), then the text between this boundary
 and the next is a word; otherwise, it&apos;s the material between words.)
 &lt;/blockquote&gt;</description>
			<attribute name="@see">
				<description>CharacterIterator</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-1" visibility="public" name="DONE" constexpr="-1" fulltype="int" type="int">
				<comment>
					<description>DONE is returned by previous(), next(), next(int), preceding(int)
 and following(int) when either the first or last text boundary has been
 reached.</description>
				</comment>
			</field>
			<field final="true" static="true" const="0" visibility="private" name="CHARACTER_INDEX" constexpr="0" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="private" name="WORD_INDEX" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="2" visibility="private" name="LINE_INDEX" constexpr="2" fulltype="int" type="int" />
			<field final="true" static="true" const="3" visibility="private" name="SENTENCE_INDEX" constexpr="3" fulltype="int" type="int" />
			<field final="true" static="true" visibility="private" name="iterCache" fulltype="java.lang.ref.SoftReference[]" type="SoftReference" />
		</fields>
		<methods>
			<constructor visibility="protected" name="BreakIterator">
				<comment>
					<description>Constructor. BreakIterator is stateless and has no default behavior.</description>
				</comment>
			</constructor>
			<method visibility="public" name="clone" returncomment="A copy of this" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Create a copy of this iterator</description>
					<attribute name="@return">
						<description>A copy of this</description>
					</attribute>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="first" returncomment="The character index of the first text boundary." fulltype="int" type="int">
				<comment>
					<description>Returns the first boundary. The iterator&apos;s current position is set
 to the first text boundary.</description>
					<attribute name="@return">
						<description>The character index of the first text boundary.</description>
					</attribute>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="last" returncomment="The character index of the last text boundary." fulltype="int" type="int">
				<comment>
					<description>Returns the last boundary. The iterator&apos;s current position is set
 to the last text boundary.</description>
					<attribute name="@return">
						<description>The character index of the last text boundary.</description>
					</attribute>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="next" returncomment="The character index of the nth boundary from the current position
 or &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if either first or last text boundary
 has been reached." fulltype="int" type="int">
				<comment>
					<description>Returns the nth boundary from the current boundary. If either
 the first or last text boundary has been reached, it returns
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and the current position is set to either
 the first or last text boundary depending on which one is reached. Otherwise,
 the iterator&apos;s current position is set to the new boundary.
 For example, if the iterator&apos;s current position is the mth text boundary
 and three more boundaries exist from the current boundary to the last text
 boundary, the next(2) call will return m + 2. The new text position is set
 to the (m + 2)th text boundary. A next(4) call would return
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and the last text boundary would become the
 new text position.</description>
					<attribute name="@param">
						<description>n which boundary to return.  A value of 0
 does nothing.  Negative values move to previous boundaries
 and positive values move to later boundaries.</description>
					</attribute>
					<attribute name="@return">
						<description>The character index of the nth boundary from the current position
 or &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if either first or last text boundary
 has been reached.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="which boundary to return.  A value of 0
 does nothing.  Negative values move to previous boundaries
 and positive values move to later boundaries." fulltype="int" type="int" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="next" returncomment="The character index of the next text boundary or
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the current boundary is the last text
 boundary.
 Equivalent to next(1)." fulltype="int" type="int">
				<comment>
					<description>Returns the boundary following the current boundary. If the current boundary
 is the last text boundary, it returns &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and
 the iterator&apos;s current position is unchanged. Otherwise, the iterator&apos;s
 current position is set to the boundary following the current boundary.</description>
					<attribute name="@return">
						<description>The character index of the next text boundary or
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the current boundary is the last text
 boundary.
 Equivalent to next(1).</description>
					</attribute>
					<attribute name="@see">
						<description>#next(int)</description>
					</attribute>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="previous" returncomment="The character index of the previous text boundary or
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the current boundary is the first text
 boundary." fulltype="int" type="int">
				<comment>
					<description>Returns the boundary preceding the current boundary. If the current boundary
 is the first text boundary, it returns &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and
 the iterator&apos;s current position is unchanged. Otherwise, the iterator&apos;s
 current position is set to the boundary preceding the current boundary.</description>
					<attribute name="@return">
						<description>The character index of the previous text boundary or
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the current boundary is the first text
 boundary.</description>
					</attribute>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="following" returncomment="The first boundary after the specified offset or
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the last text boundary is passed in
 as the offset." fulltype="int" type="int">
				<comment>
					<description>Returns the first boundary following the specified character offset. If the
 specified offset equals to the last text boundary, it returns
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and the iterator&apos;s current position is unchanged.
 Otherwise, the iterator&apos;s current position is set to the returned boundary.
 The value returned is always greater than the offset or the value
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>offset the character offset to begin scanning.</description>
					</attribute>
					<attribute name="@return">
						<description>The first boundary after the specified offset or
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the last text boundary is passed in
 as the offset.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the specified offset is less than
 the first text boundary or greater than the last text boundary.</description>
					</attribute>
				</comment>
				<params>
					<param name="offset" comment="the character offset to begin scanning." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="preceding" returncomment="The last boundary before the specified offset or
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the first text boundary is passed in
 as the offset." fulltype="int" type="int">
				<comment>
					<description>Returns the last boundary preceding the specified character offset. If the
 specified offset equals to the first text boundary, it returns
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and the iterator&apos;s current position is unchanged.
 Otherwise, the iterator&apos;s current position is set to the returned boundary.
 The value returned is always less than the offset or the value
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>offset the characater offset to begin scanning.</description>
					</attribute>
					<attribute name="@return">
						<description>The last boundary before the specified offset or
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the first text boundary is passed in
 as the offset.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the specified offset is less than
 the first text boundary or greater than the last text boundary.</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="offset" comment="the characater offset to begin scanning." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="isBoundary" returncomment="&lt;code&gt;true&lt;/code&gt; if &quot;offset&quot; is a boundary position,
 &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if the specified character offset is a text boundary.</description>
					<attribute name="@param">
						<description>offset the character offset to check.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if &quot;offset&quot; is a boundary position,
 &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="offset" comment="the character offset to check." fulltype="int" type="int" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="current" returncomment="The text boundary returned from the above methods, first or last
 text boundary." fulltype="int" type="int">
				<comment>
					<description>Returns character index of the text boundary that was most
 recently returned by next(), next(int), previous(), first(), last(),
 following(int) or preceding(int). If any of these methods returns
 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; because either first or last text boundary
 has been reached, it returns the first or last text boundary depending on
 which one is reached.</description>
					<attribute name="@return">
						<description>The text boundary returned from the above methods, first or last
 text boundary.</description>
					</attribute>
					<attribute name="@see">
						<description>#next()</description>
					</attribute>
					<attribute name="@see">
						<description>#next(int)</description>
					</attribute>
					<attribute name="@see">
						<description>#previous()</description>
					</attribute>
					<attribute name="@see">
						<description>#first()</description>
					</attribute>
					<attribute name="@see">
						<description>#last()</description>
					</attribute>
					<attribute name="@see">
						<description>#following(int)</description>
					</attribute>
					<attribute name="@see">
						<description>#preceding(int)</description>
					</attribute>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="getText" returncomment="the text being scanned" fulltype="java.text.CharacterIterator" type="CharacterIterator">
				<comment>
					<description>Get the text being scanned</description>
					<attribute name="@return">
						<description>the text being scanned</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setText" fulltype="void" type="void">
				<comment>
					<description>Set a new text string to be scanned.  The current scan
 position is reset to first().</description>
					<attribute name="@param">
						<description>newText new text to scan.</description>
					</attribute>
				</comment>
				<params>
					<param name="newText" comment="new text to scan." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="setText" fulltype="void" type="void">
				<comment>
					<description>Set a new text for scanning.  The current scan
 position is reset to first().</description>
					<attribute name="@param">
						<description>newText new text to scan.</description>
					</attribute>
				</comment>
				<params>
					<param name="newText" comment="new text to scan." fulltype="java.text.CharacterIterator" type="CharacterIterator" />
				</params>
			</method>
			<method static="true" visibility="public" name="getWordInstance" returncomment="A break iterator for word breaks" fulltype="java.text.BreakIterator" type="BreakIterator">
				<comment>
					<description>Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
 for &lt;a href=&quot;#word&quot;&gt;word breaks&lt;/a&gt;
 for the {@linkplain Locale#getDefault() default locale}.</description>
					<attribute name="@return">
						<description>A break iterator for word breaks</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="public" name="getWordInstance" returncomment="A break iterator for word breaks" fulltype="java.text.BreakIterator" type="BreakIterator">
				<comment>
					<description>Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
 for &lt;a href=&quot;#word&quot;&gt;word breaks&lt;/a&gt;
 for the given locale.</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@return">
						<description>A break iterator for word breaks</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method static="true" visibility="public" name="getLineInstance" returncomment="A break iterator for line breaks" fulltype="java.text.BreakIterator" type="BreakIterator">
				<comment>
					<description>Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
 for &lt;a href=&quot;#line&quot;&gt;line breaks&lt;/a&gt;
 for the {@linkplain Locale#getDefault() default locale}.</description>
					<attribute name="@return">
						<description>A break iterator for line breaks</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="public" name="getLineInstance" returncomment="A break iterator for line breaks" fulltype="java.text.BreakIterator" type="BreakIterator">
				<comment>
					<description>Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
 for &lt;a href=&quot;#line&quot;&gt;line breaks&lt;/a&gt;
 for the given locale.</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@return">
						<description>A break iterator for line breaks</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method static="true" visibility="public" name="getCharacterInstance" returncomment="A break iterator for character breaks" fulltype="java.text.BreakIterator" type="BreakIterator">
				<comment>
					<description>Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
 for &lt;a href=&quot;#character&quot;&gt;character breaks&lt;/a&gt;
 for the {@linkplain Locale#getDefault() default locale}.</description>
					<attribute name="@return">
						<description>A break iterator for character breaks</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="public" name="getCharacterInstance" returncomment="A break iterator for character breaks" fulltype="java.text.BreakIterator" type="BreakIterator">
				<comment>
					<description>Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
 for &lt;a href=&quot;#character&quot;&gt;character breaks&lt;/a&gt;
 for the given locale.</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@return">
						<description>A break iterator for character breaks</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method static="true" visibility="public" name="getSentenceInstance" returncomment="A break iterator for sentence breaks" fulltype="java.text.BreakIterator" type="BreakIterator">
				<comment>
					<description>Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
 for &lt;a href=&quot;#sentence&quot;&gt;sentence breaks&lt;/a&gt;
 for the {@linkplain Locale#getDefault() default locale}.</description>
					<attribute name="@return">
						<description>A break iterator for sentence breaks</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="public" name="getSentenceInstance" returncomment="A break iterator for sentence breaks" fulltype="java.text.BreakIterator" type="BreakIterator">
				<comment>
					<description>Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
 for &lt;a href=&quot;#sentence&quot;&gt;sentence breaks&lt;/a&gt;
 for the given locale.</description>
					<attribute name="@param">
						<description>locale the desired locale</description>
					</attribute>
					<attribute name="@return">
						<description>A break iterator for sentence breaks</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method static="true" visibility="private" name="getBreakInstance" fulltype="java.text.BreakIterator" type="BreakIterator">
				<params>
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
					<param name="type" fulltype="int" type="int" />
					<param name="dataName" fulltype="java.lang.String" type="String" />
					<param name="dictionaryName" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="getBundle" fulltype="java.util.ResourceBundle" type="ResourceBundle">
				<params>
					<param name="baseName" fulltype="java.lang.String" type="String" />
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method static="true" visibility="private" name="createBreakInstance" fulltype="java.text.BreakIterator" type="BreakIterator">
				<params>
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
					<param name="type" fulltype="int" type="int" />
					<param name="dataName" fulltype="java.lang.String" type="String" />
					<param name="dictionaryName" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" synchronized="true" visibility="public" name="getAvailableLocales" returncomment="An array of locales for which localized
         &lt;code&gt;BreakIterator&lt;/code&gt; instances are available." fulltype="java.util.Locale[]" type="Locale">
				<comment>
					<description>Returns an array of all locales for which the
 &lt;code&gt;get*Instance&lt;/code&gt; methods of this class can return
 localized instances.
 The returned array represents the union of locales supported by the Java
 runtime and by installed
 {@link java.text.spi.BreakIteratorProvider BreakIteratorProvider} implementations.
 It must contain at least a &lt;code&gt;Locale&lt;/code&gt;
 instance equal to {@link java.util.Locale#US Locale.US}.</description>
					<attribute name="@return">
						<description>An array of locales for which localized
         &lt;code&gt;BreakIterator&lt;/code&gt; instances are available.</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="package-private" name="getLong" fulltype="long" type="long">
				<params>
					<param name="buf" fulltype="byte[]" type="byte" />
					<param name="offset" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="getInt" fulltype="int" type="int">
				<params>
					<param name="buf" fulltype="byte[]" type="byte" />
					<param name="offset" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="getShort" fulltype="short" type="short">
				<params>
					<param name="buf" fulltype="byte[]" type="byte" />
					<param name="offset" fulltype="int" type="int" />
				</params>
			</method>
		</methods>
		<jelclass final="true" superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.BreakIterator.BreakIteratorCache" type="BreakIterator.BreakIteratorCache">
			<fields>
				<field visibility="private" name="iter" fulltype="java.text.BreakIterator" type="BreakIterator" />
				<field visibility="private" name="locale" fulltype="java.util.Locale" type="Locale" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="BreakIterator.BreakIteratorCache">
					<params>
						<param name="locale" fulltype="java.util.Locale" type="Locale" />
						<param name="iter" fulltype="java.text.BreakIterator" type="BreakIterator" />
					</params>
				</constructor>
				<method visibility="package-private" name="getLocale" fulltype="java.util.Locale" type="Locale" />
				<method visibility="package-private" name="createBreakInstance" fulltype="java.text.BreakIterator" type="BreakIterator" />
			</methods>
		</jelclass>
		<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.BreakIterator.BreakIteratorGetter" type="BreakIterator.BreakIteratorGetter">
			<implements>
				<interface fulltype="sun.util.LocaleServiceProviderPool.LocalizedObjectGetter" type="LocaleServiceProviderPool.LocalizedObjectGetter" />
			</implements>
			<comment>
				<description>Obtains a BreakIterator instance from a BreakIteratorProvider
 implementation.</description>
			</comment>
			<fields>
				<field final="true" static="true" visibility="private" name="INSTANCE" fulltype="java.text.BreakIterator.BreakIteratorGetter" type="BreakIterator.BreakIteratorGetter" />
			</fields>
			<methods>
				<constructor visibility="private" name="BreakIterator.BreakIteratorGetter" />
				<method visibility="public" name="getObject" fulltype="java.text.BreakIterator" type="BreakIterator">
					<params>
						<param name="breakIteratorProvider" fulltype="java.text.spi.BreakIteratorProvider" type="BreakIteratorProvider" />
						<param name="locale" fulltype="java.util.Locale" type="Locale" />
						<param name="key" fulltype="java.lang.String" type="String" />
						<param name="params" fulltype="java.lang.Object[]" type="Object" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.BreakIterator.BreakIteratorCache" type="BreakIterator.BreakIteratorCache">
		<fields>
			<field visibility="private" name="iter" fulltype="java.text.BreakIterator" type="BreakIterator" />
			<field visibility="private" name="locale" fulltype="java.util.Locale" type="Locale" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="BreakIterator.BreakIteratorCache">
				<params>
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
					<param name="iter" fulltype="java.text.BreakIterator" type="BreakIterator" />
				</params>
			</constructor>
			<method visibility="package-private" name="getLocale" fulltype="java.util.Locale" type="Locale" />
			<method visibility="package-private" name="createBreakInstance" fulltype="java.text.BreakIterator" type="BreakIterator" />
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.BreakIterator.BreakIteratorGetter" type="BreakIterator.BreakIteratorGetter">
		<implements>
			<interface fulltype="sun.util.LocaleServiceProviderPool.LocalizedObjectGetter" type="LocaleServiceProviderPool.LocalizedObjectGetter" />
		</implements>
		<comment>
			<description>Obtains a BreakIterator instance from a BreakIteratorProvider
 implementation.</description>
		</comment>
		<fields>
			<field final="true" static="true" visibility="private" name="INSTANCE" fulltype="java.text.BreakIterator.BreakIteratorGetter" type="BreakIterator.BreakIteratorGetter" />
		</fields>
		<methods>
			<constructor visibility="private" name="BreakIterator.BreakIteratorGetter" />
			<method visibility="public" name="getObject" fulltype="java.text.BreakIterator" type="BreakIterator">
				<params>
					<param name="breakIteratorProvider" fulltype="java.text.spi.BreakIteratorProvider" type="BreakIteratorProvider" />
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
					<param name="key" fulltype="java.lang.String" type="String" />
					<param name="params" fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.text" serializable="true" superclassfulltype="java.lang.Object" fulltype="java.text.DecimalFormatSymbols" type="DecimalFormatSymbols">
		<implements>
			<interface fulltype="java.lang.Cloneable" type="Cloneable" />
			<interface fulltype="java.io.Serializable" type="Serializable" />
		</implements>
		<comment>
			<description>This class represents the set of symbols (such as the decimal separator,
 the grouping separator, and so on) needed by &lt;code&gt;DecimalFormat&lt;/code&gt;
 to format numbers. &lt;code&gt;DecimalFormat&lt;/code&gt; creates for itself an instance of
 &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; from its locale data.  If you need to change any
 of these symbols, you can get the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object from
 your &lt;code&gt;DecimalFormat&lt;/code&gt; and modify it.</description>
			<attribute name="@see">
				<description>java.util.Locale</description>
			</attribute>
			<attribute name="@see">
				<description>DecimalFormat</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Davis</description>
			</attribute>
			<attribute name="@author">
				<description>Alan Liu</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="zeroDigit" fulltype="char" type="char">
				<comment>
					<description>Character used for zero.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getZeroDigit</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="groupingSeparator" fulltype="char" type="char">
				<comment>
					<description>Character used for thousands separator.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getGroupingSeparator</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="decimalSeparator" fulltype="char" type="char">
				<comment>
					<description>Character used for decimal sign.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getDecimalSeparator</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="perMill" fulltype="char" type="char">
				<comment>
					<description>Character used for per mille sign.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getPerMill</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="percent" fulltype="char" type="char">
				<comment>
					<description>Character used for percent sign.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getPercent</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="digit" fulltype="char" type="char">
				<comment>
					<description>Character used for a digit in a pattern.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getDigit</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="patternSeparator" fulltype="char" type="char">
				<comment>
					<description>Character used to separate positive and negative subpatterns
 in a pattern.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getPatternSeparator</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="infinity" fulltype="java.lang.String" type="String">
				<comment>
					<description>String used to represent infinity.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getInfinity</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="NaN" fulltype="java.lang.String" type="String">
				<comment>
					<description>String used to represent &quot;not a number&quot;.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getNaN</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="minusSign" fulltype="char" type="char">
				<comment>
					<description>Character used to represent minus sign.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getMinusSign</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="currencySymbol" fulltype="java.lang.String" type="String">
				<comment>
					<description>String denoting the local currency, e.g. &quot;$&quot;.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getCurrencySymbol</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="intlCurrencySymbol" fulltype="java.lang.String" type="String">
				<comment>
					<description>ISO 4217 currency code denoting the local currency, e.g. &quot;USD&quot;.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>#getInternationalCurrencySymbol</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="monetarySeparator" fulltype="char" type="char">
				<comment>
					<description>The decimal separator used when formatting currency values.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>JDK 1.1.6</description>
					</attribute>
					<attribute name="@see">
						<description>#getMonetaryDecimalSeparator</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="exponential" fulltype="char" type="char">
				<comment>
					<description>The character used to distinguish the exponent in a number formatted
 in exponential notation, e.g. &apos;E&apos; for a number such as &quot;1.23E45&quot;.
 &lt;p&gt;
 Note that the public API provides no way to set this field,
 even though it is supported by the implementation and the stream format.
 The intent is that this will be added to the API in the future.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>JDK 1.1.6</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="exponentialSeparator" fulltype="java.lang.String" type="String">
				<comment>
					<description>The string used to separate the mantissa from the exponent.
 Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
 &lt;p&gt;
 If both &lt;code&gt;exponential&lt;/code&gt; and &lt;code&gt;exponentialSeparator&lt;/code&gt;
 exist, this &lt;code&gt;exponentialSeparator&lt;/code&gt; has the precedence.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="locale" fulltype="java.util.Locale" type="Locale">
				<comment>
					<description>The locale of these currency format symbols.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" transient="true" name="currency" fulltype="java.util.Currency" type="Currency" />
			<field final="true" static="true" const="5772796243397350300" visibility="package-private" name="serialVersionUID" constexpr="5772796243397350300L" fulltype="long" type="long" />
			<field final="true" static="true" const="3" visibility="private" name="currentSerialVersion" constexpr="3" fulltype="int" type="int" />
			<field visibility="private" name="serialVersionOnStream" fulltype="int" type="int">
				<comment>
					<description>Describes the version of &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; present on the stream.
 Possible values are:
 &lt;ul&gt;
 &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (or uninitialized): versions prior to JDK 1.1.6.

 &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: Versions written by JDK 1.1.6 or later, which include
      two new fields: &lt;code&gt;monetarySeparator&lt;/code&gt; and &lt;code&gt;exponential&lt;/code&gt;.
 &lt;li&gt;&lt;b&gt;2&lt;/b&gt;: Versions written by J2SE 1.4 or later, which include a
      new &lt;code&gt;locale&lt;/code&gt; field.
 &lt;li&gt;&lt;b&gt;3&lt;/b&gt;: Versions written by J2SE 1.6 or later, which include a
      new &lt;code&gt;exponentialSeparator&lt;/code&gt; field.
 &lt;/ul&gt;
 When streaming out a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt;, the most recent format
 (corresponding to the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;)
 is always written.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>JDK 1.1.6</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="cachedLocaleData" fulltype="java.util.Hashtable" type="Hashtable">
				<comment>
					<description>cache to hold the NumberElements and the Currency
 of a Locale.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="DecimalFormatSymbols">
				<comment>
					<description>Create a DecimalFormatSymbols object for the default locale.
 This constructor can only construct instances for the locales
 supported by the Java runtime environment, not for those
 supported by installed
 {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
 implementations. For full locale coverage, use the
 {@link #getInstance(Locale) getInstance} method.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="DecimalFormatSymbols">
				<comment>
					<description>Create a DecimalFormatSymbols object for the given locale.
 This constructor can only construct instances for the locales
 supported by the Java runtime environment, not for those
 supported by installed
 {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
 implementations. For full locale coverage, use the
 {@link #getInstance(Locale) getInstance} method.</description>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</constructor>
			<method static="true" visibility="public" name="getAvailableLocales" returncomment="An array of locales for which localized
         &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instances are available." fulltype="java.util.Locale[]" type="Locale">
				<comment>
					<description>Returns an array of all locales for which the
 &lt;code&gt;getInstance&lt;/code&gt; methods of this class can return
 localized instances.
 The returned array represents the union of locales supported by the Java
 runtime and by installed
 {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
 implementations.  It must contain at least a &lt;code&gt;Locale&lt;/code&gt;
 instance equal to {@link java.util.Locale#US Locale.US}.</description>
					<attribute name="@return">
						<description>An array of locales for which localized
         &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instances are available.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method final="true" static="true" visibility="public" name="getInstance" returncomment="a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance." fulltype="java.text.DecimalFormatSymbols" type="DecimalFormatSymbols">
				<comment>
					<description>Gets the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance for the default
 locale.  This method provides access to &lt;code&gt;DecimalFormatSymbols&lt;/code&gt;
 instances for locales supported by the Java runtime itself as well
 as for those supported by installed
 {@link java.text.spi.DecimalFormatSymbolsProvider
 DecimalFormatSymbolsProvider} implementations.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method final="true" static="true" visibility="public" name="getInstance" returncomment="a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance." fulltype="java.text.DecimalFormatSymbols" type="DecimalFormatSymbols">
				<comment>
					<description>Gets the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance for the specified
 locale.  This method provides access to &lt;code&gt;DecimalFormatSymbols&lt;/code&gt;
 instances for locales supported by the Java runtime itself as well
 as for those supported by installed
 {@link java.text.spi.DecimalFormatSymbolsProvider
 DecimalFormatSymbolsProvider} implementations.</description>
					<attribute name="@param">
						<description>locale the desired locale.</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the desired locale." fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method visibility="public" name="getZeroDigit" fulltype="char" type="char">
				<comment>
					<description>Gets the character used for zero. Different for Arabic, etc.</description>
				</comment>
			</method>
			<method visibility="public" name="setZeroDigit" fulltype="void" type="void">
				<comment>
					<description>Sets the character used for zero. Different for Arabic, etc.</description>
				</comment>
				<params>
					<param name="zeroDigit" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="getGroupingSeparator" fulltype="char" type="char">
				<comment>
					<description>Gets the character used for thousands separator. Different for French, etc.</description>
				</comment>
			</method>
			<method visibility="public" name="setGroupingSeparator" fulltype="void" type="void">
				<comment>
					<description>Sets the character used for thousands separator. Different for French, etc.</description>
				</comment>
				<params>
					<param name="groupingSeparator" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="getDecimalSeparator" fulltype="char" type="char">
				<comment>
					<description>Gets the character used for decimal sign. Different for French, etc.</description>
				</comment>
			</method>
			<method visibility="public" name="setDecimalSeparator" fulltype="void" type="void">
				<comment>
					<description>Sets the character used for decimal sign. Different for French, etc.</description>
				</comment>
				<params>
					<param name="decimalSeparator" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="getPerMill" fulltype="char" type="char">
				<comment>
					<description>Gets the character used for per mille sign. Different for Arabic, etc.</description>
				</comment>
			</method>
			<method visibility="public" name="setPerMill" fulltype="void" type="void">
				<comment>
					<description>Sets the character used for per mille sign. Different for Arabic, etc.</description>
				</comment>
				<params>
					<param name="perMill" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="getPercent" fulltype="char" type="char">
				<comment>
					<description>Gets the character used for percent sign. Different for Arabic, etc.</description>
				</comment>
			</method>
			<method visibility="public" name="setPercent" fulltype="void" type="void">
				<comment>
					<description>Sets the character used for percent sign. Different for Arabic, etc.</description>
				</comment>
				<params>
					<param name="percent" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="getDigit" fulltype="char" type="char">
				<comment>
					<description>Gets the character used for a digit in a pattern.</description>
				</comment>
			</method>
			<method visibility="public" name="setDigit" fulltype="void" type="void">
				<comment>
					<description>Sets the character used for a digit in a pattern.</description>
				</comment>
				<params>
					<param name="digit" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="getPatternSeparator" fulltype="char" type="char">
				<comment>
					<description>Gets the character used to separate positive and negative subpatterns
 in a pattern.</description>
				</comment>
			</method>
			<method visibility="public" name="setPatternSeparator" fulltype="void" type="void">
				<comment>
					<description>Sets the character used to separate positive and negative subpatterns
 in a pattern.</description>
				</comment>
				<params>
					<param name="patternSeparator" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="getInfinity" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the string used to represent infinity. Almost always left
 unchanged.</description>
				</comment>
			</method>
			<method visibility="public" name="setInfinity" fulltype="void" type="void">
				<comment>
					<description>Sets the string used to represent infinity. Almost always left
 unchanged.</description>
				</comment>
				<params>
					<param name="infinity" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getNaN" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the string used to represent &quot;not a number&quot;. Almost always left
 unchanged.</description>
				</comment>
			</method>
			<method visibility="public" name="setNaN" fulltype="void" type="void">
				<comment>
					<description>Sets the string used to represent &quot;not a number&quot;. Almost always left
 unchanged.</description>
				</comment>
				<params>
					<param name="NaN" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getMinusSign" fulltype="char" type="char">
				<comment>
					<description>Gets the character used to represent minus sign. If no explicit
 negative format is specified, one is formed by prefixing
 minusSign to the positive format.</description>
				</comment>
			</method>
			<method visibility="public" name="setMinusSign" fulltype="void" type="void">
				<comment>
					<description>Sets the character used to represent minus sign. If no explicit
 negative format is specified, one is formed by prefixing
 minusSign to the positive format.</description>
				</comment>
				<params>
					<param name="minusSign" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="getCurrencySymbol" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the currency symbol for the currency of these
 DecimalFormatSymbols in their locale.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setCurrencySymbol" fulltype="void" type="void">
				<comment>
					<description>Sets the currency symbol for the currency of these
 DecimalFormatSymbols in their locale.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="currency" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getInternationalCurrencySymbol" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the ISO 4217 currency code of the currency of these
 DecimalFormatSymbols.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setInternationalCurrencySymbol" fulltype="void" type="void">
				<comment>
					<description>Sets the ISO 4217 currency code of the currency of these
 DecimalFormatSymbols.
 If the currency code is valid (as defined by
 {@link java.util.Currency#getInstance(java.lang.String) Currency.getInstance}),
 this also sets the currency attribute to the corresponding Currency
 instance and the currency symbol attribute to the currency&apos;s symbol
 in the DecimalFormatSymbols&apos; locale. If the currency code is not valid,
 then the currency attribute is set to null and the currency symbol
 attribute is not modified.</description>
					<attribute name="@see">
						<description>#setCurrency</description>
					</attribute>
					<attribute name="@see">
						<description>#setCurrencySymbol</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="currencyCode" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getCurrency" returncomment="the currency used, or null" fulltype="java.util.Currency" type="Currency">
				<comment>
					<description>Gets the currency of these DecimalFormatSymbols. May be null if the
 currency symbol attribute was previously set to a value that&apos;s not
 a valid ISO 4217 currency code.</description>
					<attribute name="@return">
						<description>the currency used, or null</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setCurrency" fulltype="void" type="void">
				<comment>
					<description>Sets the currency of these DecimalFormatSymbols.
 This also sets the currency symbol attribute to the currency&apos;s symbol
 in the DecimalFormatSymbols&apos; locale, and the international currency
 symbol attribute to the currency&apos;s ISO 4217 currency code.</description>
					<attribute name="@param">
						<description>currency the new currency to be used</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;currency&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#setCurrencySymbol</description>
					</attribute>
					<attribute name="@see">
						<description>#setInternationalCurrencySymbol</description>
					</attribute>
				</comment>
				<params>
					<param name="currency" comment="the new currency to be used" fulltype="java.util.Currency" type="Currency" />
				</params>
			</method>
			<method visibility="public" name="getMonetaryDecimalSeparator" fulltype="char" type="char">
				<comment>
					<description>Returns the monetary decimal separator.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setMonetaryDecimalSeparator" fulltype="void" type="void">
				<comment>
					<description>Sets the monetary decimal separator.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="sep" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="package-private" name="getExponentialSymbol" fulltype="char" type="char">
				<comment>
					<description>Returns the character used to separate the mantissa from the exponent.</description>
				</comment>
			</method>
			<method visibility="public" name="getExponentSeparator" returncomment="the exponent separator string" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the string used to separate the mantissa from the exponent.
 Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.</description>
					<attribute name="@return">
						<description>the exponent separator string</description>
					</attribute>
					<attribute name="@see">
						<description>#setExponentSeparator(java.lang.String)</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method visibility="package-private" name="setExponentialSymbol" fulltype="void" type="void">
				<comment>
					<description>Sets the character used to separate the mantissa from the exponent.</description>
				</comment>
				<params>
					<param name="exp" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="setExponentSeparator" fulltype="void" type="void">
				<comment>
					<description>Sets the string used to separate the mantissa from the exponent.
 Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.</description>
					<attribute name="@param">
						<description>exp the exponent separator string</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;exp&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@see">
						<description>#getExponentSeparator()</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="exp" comment="the exponent separator string" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="clone" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Standard override.</description>
				</comment>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Override equals.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Override hashCode.</description>
				</comment>
			</method>
			<method visibility="private" name="initialize" fulltype="void" type="void">
				<comment>
					<description>Initializes the symbols from the FormatData resource bundle.</description>
				</comment>
				<params>
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<comment>
					<description>Reads the default serializable fields, provides default values for objects
 in older serial versions, and initializes non-serializable fields.
 If &lt;code&gt;serialVersionOnStream&lt;/code&gt;
 is less than 1, initializes &lt;code&gt;monetarySeparator&lt;/code&gt; to be
 the same as &lt;code&gt;decimalSeparator&lt;/code&gt; and &lt;code&gt;exponential&lt;/code&gt;
 to be &apos;E&apos;.
 If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 2,
 initializes &lt;code&gt;locale&lt;/code&gt;to the root locale, and initializes
 If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 3, it initializes
 &lt;code&gt;exponentialSeparator&lt;/code&gt; using &lt;code&gt;exponential&lt;/code&gt;.
 Sets &lt;code&gt;serialVersionOnStream&lt;/code&gt; back to the maximum allowed value so that
 default serialization will work properly if this object is streamed out again.
 Initializes the currency from the intlCurrencySymbol field.</description>
					<attribute name="@since">
						<description>JDK 1.1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="stream" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.DecimalFormatSymbols.DecimalFormatSymbolsGetter" type="DecimalFormatSymbols.DecimalFormatSymbolsGetter">
			<implements>
				<interface fulltype="sun.util.LocaleServiceProviderPool.LocalizedObjectGetter" type="LocaleServiceProviderPool.LocalizedObjectGetter" />
			</implements>
			<comment>
				<description>Obtains a DecimalFormatSymbols instance from a DecimalFormatSymbolsProvider
 implementation.</description>
			</comment>
			<fields>
				<field final="true" static="true" visibility="private" name="INSTANCE" fulltype="java.text.DecimalFormatSymbols.DecimalFormatSymbolsGetter" type="DecimalFormatSymbols.DecimalFormatSymbolsGetter" />
			</fields>
			<methods>
				<constructor visibility="private" name="DecimalFormatSymbols.DecimalFormatSymbolsGetter" />
				<method visibility="public" name="getObject" fulltype="java.text.DecimalFormatSymbols" type="DecimalFormatSymbols">
					<params>
						<param name="decimalFormatSymbolsProvider" fulltype="java.text.spi.DecimalFormatSymbolsProvider" type="DecimalFormatSymbolsProvider" />
						<param name="locale" fulltype="java.util.Locale" type="Locale" />
						<param name="key" fulltype="java.lang.String" type="String" />
						<param name="params" fulltype="java.lang.Object[]" type="Object" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.DecimalFormatSymbols.DecimalFormatSymbolsGetter" type="DecimalFormatSymbols.DecimalFormatSymbolsGetter">
		<implements>
			<interface fulltype="sun.util.LocaleServiceProviderPool.LocalizedObjectGetter" type="LocaleServiceProviderPool.LocalizedObjectGetter" />
		</implements>
		<comment>
			<description>Obtains a DecimalFormatSymbols instance from a DecimalFormatSymbolsProvider
 implementation.</description>
		</comment>
		<fields>
			<field final="true" static="true" visibility="private" name="INSTANCE" fulltype="java.text.DecimalFormatSymbols.DecimalFormatSymbolsGetter" type="DecimalFormatSymbols.DecimalFormatSymbolsGetter" />
		</fields>
		<methods>
			<constructor visibility="private" name="DecimalFormatSymbols.DecimalFormatSymbolsGetter" />
			<method visibility="public" name="getObject" fulltype="java.text.DecimalFormatSymbols" type="DecimalFormatSymbols">
				<params>
					<param name="decimalFormatSymbolsProvider" fulltype="java.text.spi.DecimalFormatSymbolsProvider" type="DecimalFormatSymbolsProvider" />
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
					<param name="key" fulltype="java.lang.String" type="String" />
					<param name="params" fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.DigitList" type="DigitList">
		<implements>
			<interface fulltype="java.lang.Cloneable" type="Cloneable" />
		</implements>
		<comment>
			<description>Digit List. Private to DecimalFormat.
 Handles the transcoding
 between numeric values and strings of characters.  Only handles
 non-negative numbers.  The division of labor between DigitList and
 DecimalFormat is that DigitList handles the radix 10 representation
 issues; DecimalFormat handles the locale-specific issues such as
 positive/negative, grouping, decimal point, currency, and so on.

 A DigitList is really a representation of a floating point value.
 It may be an integer value; we assume that a double has sufficient
 precision to represent all digits of a long.

 The DigitList representation consists of a string of characters,
 which are the digits radix 10, from &apos;0&apos; to &apos;9&apos;.  It also has a radix
 10 exponent associated with it.  The value represented by a DigitList
 object can be computed by mulitplying the fraction f, where 0 &lt;= f &lt; 1,
 derived by placing all the digits of the list to the right of the
 decimal point, by 10^exponent.</description>
			<attribute name="@see">
				<description>Locale</description>
			</attribute>
			<attribute name="@see">
				<description>Format</description>
			</attribute>
			<attribute name="@see">
				<description>NumberFormat</description>
			</attribute>
			<attribute name="@see">
				<description>DecimalFormat</description>
			</attribute>
			<attribute name="@see">
				<description>ChoiceFormat</description>
			</attribute>
			<attribute name="@see">
				<description>MessageFormat</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Davis, Alan Liu</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="19" visibility="public" name="MAX_COUNT" constexpr="19" fulltype="int" type="int">
				<comment>
					<description>The maximum number of significant digits in an IEEE 754 double, that
 is, in a Java double.  This must not be increased, or garbage digits
 will be generated, and should not be decreased, or accuracy will be lost.</description>
				</comment>
			</field>
			<field visibility="public" name="decimalAt" fulltype="int" type="int">
				<comment>
					<description>These data members are intentionally public and can be set directly.

 The value represented is given by placing the decimal point before
 digits[decimalAt].  If decimalAt is &lt; 0, then leading zeros between
 the decimal point and the first nonzero digit are implied.  If decimalAt
 is &gt; count, then trailing zeros between the digits[count-1] and the
 decimal point are implied.

 Equivalently, the represented value is given by f * 10^decimalAt.  Here
 f is a value 0.1 &lt;= f &lt; 1 arrived at by placing the digits in Digits to
 the right of the decimal.

 DigitList is normalized, so if it is non-zero, figits[0] is non-zero.  We
 don&apos;t allow denormalized numbers because our exponent is effectively of
 unlimited magnitude.  The count value contains the number of significant
 digits present in digits[].

 Zero is represented by any DigitList with count == 0 or with each digits[i]
 for all i &lt;= count == &apos;0&apos;.</description>
				</comment>
			</field>
			<field visibility="public" name="count" fulltype="int" type="int" />
			<field visibility="public" name="digits" fulltype="char[]" type="char" />
			<field visibility="private" name="data" fulltype="char[]" type="char" />
			<field visibility="private" name="roundingMode" fulltype="java.math.RoundingMode" type="RoundingMode" />
			<field visibility="private" name="isNegative" fulltype="boolean" type="boolean" />
			<field final="true" static="true" visibility="private" name="LONG_MIN_REP" fulltype="char[]" type="char" />
			<field visibility="private" name="tempBuffer" fulltype="java.lang.StringBuffer" type="StringBuffer" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="DigitList" />
			<method visibility="package-private" name="isZero" fulltype="boolean" type="boolean">
				<comment>
					<description>Return true if the represented number is zero.</description>
				</comment>
			</method>
			<method visibility="package-private" name="setRoundingMode" fulltype="void" type="void">
				<comment>
					<description>Set the rounding mode</description>
				</comment>
				<params>
					<param name="r" fulltype="java.math.RoundingMode" type="RoundingMode" />
				</params>
			</method>
			<method visibility="public" name="clear" fulltype="void" type="void">
				<comment>
					<description>Clears out the digits.
 Use before appending them.
 Typically, you set a series of digits with append, then at the point
 you hit the decimal point, you set myDigitList.decimalAt = myDigitList.count;
 then go on appending digits.</description>
				</comment>
			</method>
			<method visibility="public" name="append" fulltype="void" type="void">
				<comment>
					<description>Appends a digit to the list, extending the list when necessary.</description>
				</comment>
				<params>
					<param name="digit" fulltype="char" type="char" />
				</params>
			</method>
			<method final="true" visibility="public" name="getDouble" fulltype="double" type="double">
				<comment>
					<description>Utility routine to get the value of the digit list
 If (count == 0) this throws a NumberFormatException, which
 mimics Long.parseLong().</description>
				</comment>
			</method>
			<method final="true" visibility="public" name="getLong" fulltype="long" type="long">
				<comment>
					<description>Utility routine to get the value of the digit list.
 If (count == 0) this returns 0, unlike Long.parseLong().</description>
				</comment>
			</method>
			<method final="true" visibility="public" name="getBigDecimal" fulltype="java.math.BigDecimal" type="BigDecimal" />
			<method visibility="package-private" name="fitsIntoLong" returncomment="true if this number fits into a Java long" fulltype="boolean" type="boolean">
				<comment>
					<description>Return true if the number represented by this object can fit into
 a long.</description>
					<attribute name="@param">
						<description>isPositive true if this number should be regarded as positive</description>
					</attribute>
					<attribute name="@param">
						<description>ignoreNegativeZero true if -0 should be regarded as identical to
 +0; otherwise they are considered distinct</description>
					</attribute>
					<attribute name="@return">
						<description>true if this number fits into a Java long</description>
					</attribute>
				</comment>
				<params>
					<param name="isPositive" comment="true if this number should be regarded as positive" fulltype="boolean" type="boolean" />
					<param name="ignoreNegativeZero" comment="true if -0 should be regarded as identical to
 +0; otherwise they are considered distinct" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method final="true" visibility="public" name="set" fulltype="void" type="void">
				<comment>
					<description>Set the digit list to a representation of the given double value.
 This method supports fixed-point notation.</description>
					<attribute name="@param">
						<description>isNegative Boolean value indicating whether the number is negative.</description>
					</attribute>
					<attribute name="@param">
						<description>source Value to be converted; must not be Inf, -Inf, Nan,
 or a value &lt;= 0.</description>
					</attribute>
					<attribute name="@param">
						<description>maximumFractionDigits The most fractional digits which should
 be converted.</description>
					</attribute>
				</comment>
				<params>
					<param name="isNegative" comment="Boolean value indicating whether the number is negative." fulltype="boolean" type="boolean" />
					<param name="source" comment="Value to be converted; must not be Inf, -Inf, Nan,
 or a value &lt;= 0." fulltype="double" type="double" />
					<param name="maximumFractionDigits" comment="The most fractional digits which should
 be converted." fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="package-private" name="set" fulltype="void" type="void">
				<comment>
					<description>Set the digit list to a representation of the given double value.
 This method supports both fixed-point and exponential notation.</description>
					<attribute name="@param">
						<description>isNegative Boolean value indicating whether the number is negative.</description>
					</attribute>
					<attribute name="@param">
						<description>source Value to be converted; must not be Inf, -Inf, Nan,
 or a value &lt;= 0.</description>
					</attribute>
					<attribute name="@param">
						<description>maximumDigits The most fractional or total digits which should
 be converted.</description>
					</attribute>
					<attribute name="@param">
						<description>fixedPoint If true, then maximumDigits is the maximum
 fractional digits to be converted.  If false, total digits.</description>
					</attribute>
				</comment>
				<params>
					<param name="isNegative" comment="Boolean value indicating whether the number is negative." fulltype="boolean" type="boolean" />
					<param name="source" comment="Value to be converted; must not be Inf, -Inf, Nan,
 or a value &lt;= 0." fulltype="double" type="double" />
					<param name="maximumDigits" comment="The most fractional or total digits which should
 be converted." fulltype="int" type="int" />
					<param name="fixedPoint" comment="If true, then maximumDigits is the maximum
 fractional digits to be converted.  If false, total digits." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method final="true" visibility="package-private" name="set" fulltype="void" type="void">
				<comment>
					<description>Generate a representation of the form DDDDD, DDDDD.DDDDD, or
 DDDDDE+/-DDDDD.</description>
				</comment>
				<params>
					<param name="isNegative" fulltype="boolean" type="boolean" />
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="maximumDigits" fulltype="int" type="int" />
					<param name="fixedPoint" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method final="true" visibility="private" name="round" fulltype="void" type="void">
				<comment>
					<description>Round the representation to the given number of digits.</description>
					<attribute name="@param">
						<description>maximumDigits The maximum number of digits to be shown.
 Upon return, count will be less than or equal to maximumDigits.</description>
					</attribute>
				</comment>
				<params>
					<param name="maximumDigits" comment="The maximum number of digits to be shown.
 Upon return, count will be less than or equal to maximumDigits." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="shouldRoundUp" returncomment="true if digit &lt;code&gt;maximumDigits-1&lt;/code&gt; should be
 incremented" fulltype="boolean" type="boolean">
				<comment>
					<description>Return true if truncating the representation to the given number
 of digits will result in an increment to the last digit.  This
 method implements the rounding modes defined in the
 java.math.RoundingMode class.
 [bnf]</description>
					<attribute name="@param">
						<description>maximumDigits the number of digits to keep, from 0 to
 &lt;code&gt;count-1&lt;/code&gt;.  If 0, then all digits are rounded away, and
 this method returns true if a one should be generated (e.g., formatting
 0.09 with &quot;#.#&quot;).</description>
					</attribute>
					<attribute name="@exception">
						<description>ArithmeticException if rounding is needed with rounding
            mode being set to RoundingMode.UNNECESSARY</description>
					</attribute>
					<attribute name="@return">
						<description>true if digit &lt;code&gt;maximumDigits-1&lt;/code&gt; should be
 incremented</description>
					</attribute>
				</comment>
				<params>
					<param name="maximumDigits" comment="the number of digits to keep, from 0 to
 &lt;code&gt;count-1&lt;/code&gt;.  If 0, then all digits are rounded away, and
 this method returns true if a one should be generated (e.g., formatting
 0.09 with &quot;#.#&quot;)." fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="public" name="set" fulltype="void" type="void">
				<comment>
					<description>Utility routine to set the value of the digit list from a long</description>
				</comment>
				<params>
					<param name="isNegative" fulltype="boolean" type="boolean" />
					<param name="source" fulltype="long" type="long" />
				</params>
			</method>
			<method final="true" visibility="public" name="set" fulltype="void" type="void">
				<comment>
					<description>Set the digit list to a representation of the given long value.</description>
					<attribute name="@param">
						<description>isNegative Boolean value indicating whether the number is negative.</description>
					</attribute>
					<attribute name="@param">
						<description>source Value to be converted; must be &gt;= 0 or ==
 Long.MIN_VALUE.</description>
					</attribute>
					<attribute name="@param">
						<description>maximumDigits The most digits which should be converted.
 If maximumDigits is lower than the number of significant digits
 in source, the representation will be rounded.  Ignored if &lt;= 0.</description>
					</attribute>
				</comment>
				<params>
					<param name="isNegative" comment="Boolean value indicating whether the number is negative." fulltype="boolean" type="boolean" />
					<param name="source" comment="Value to be converted; must be &gt;= 0 or ==
 Long.MIN_VALUE." fulltype="long" type="long" />
					<param name="maximumDigits" comment="The most digits which should be converted.
 If maximumDigits is lower than the number of significant digits
 in source, the representation will be rounded.  Ignored if &lt;= 0." fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="package-private" name="set" fulltype="void" type="void">
				<comment>
					<description>Set the digit list to a representation of the given BigDecimal value.
 This method supports both fixed-point and exponential notation.</description>
					<attribute name="@param">
						<description>isNegative Boolean value indicating whether the number is negative.</description>
					</attribute>
					<attribute name="@param">
						<description>source Value to be converted; must not be a value &lt;= 0.</description>
					</attribute>
					<attribute name="@param">
						<description>maximumDigits The most fractional or total digits which should
 be converted.</description>
					</attribute>
					<attribute name="@param">
						<description>fixedPoint If true, then maximumDigits is the maximum
 fractional digits to be converted.  If false, total digits.</description>
					</attribute>
				</comment>
				<params>
					<param name="isNegative" comment="Boolean value indicating whether the number is negative." fulltype="boolean" type="boolean" />
					<param name="source" comment="Value to be converted; must not be a value &lt;= 0." fulltype="java.math.BigDecimal" type="BigDecimal" />
					<param name="maximumDigits" comment="The most fractional or total digits which should
 be converted." fulltype="int" type="int" />
					<param name="fixedPoint" comment="If true, then maximumDigits is the maximum
 fractional digits to be converted.  If false, total digits." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method final="true" visibility="package-private" name="set" fulltype="void" type="void">
				<comment>
					<description>Set the digit list to a representation of the given BigInteger value.</description>
					<attribute name="@param">
						<description>isNegative Boolean value indicating whether the number is negative.</description>
					</attribute>
					<attribute name="@param">
						<description>source Value to be converted; must be &gt;= 0.</description>
					</attribute>
					<attribute name="@param">
						<description>maximumDigits The most digits which should be converted.
 If maximumDigits is lower than the number of significant digits
 in source, the representation will be rounded.  Ignored if &lt;= 0.</description>
					</attribute>
				</comment>
				<params>
					<param name="isNegative" comment="Boolean value indicating whether the number is negative." fulltype="boolean" type="boolean" />
					<param name="source" comment="Value to be converted; must be &gt;= 0." fulltype="java.math.BigInteger" type="BigInteger" />
					<param name="maximumDigits" comment="The most digits which should be converted.
 If maximumDigits is lower than the number of significant digits
 in source, the representation will be rounded.  Ignored if &lt;= 0." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>equality test between two digit lists.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Generates the hash code for the digit list.</description>
				</comment>
			</method>
			<method visibility="public" name="clone" returncomment="a clone of this instance." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Creates a copy of this object.</description>
					<attribute name="@return">
						<description>a clone of this instance.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="private" name="isLongMIN_VALUE" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if this DigitList represents Long.MIN_VALUE;
 false, otherwise.  This is required so that getLong() works.</description>
				</comment>
			</method>
			<method final="true" static="true" visibility="private" name="parseInt" fulltype="int" type="int">
				<params>
					<param name="str" fulltype="char[]" type="char" />
					<param name="offset" fulltype="int" type="int" />
					<param name="strLen" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="toString" fulltype="java.lang.String" type="String" />
			<method visibility="private" name="getStringBuffer" fulltype="java.lang.StringBuffer" type="StringBuffer" />
			<method visibility="private" name="extendDigits" fulltype="void" type="void">
				<params>
					<param name="len" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="private" name="getDataChars" fulltype="char[]" type="char">
				<params>
					<param name="length" fulltype="int" type="int" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="CollationKey" visibility="package-private" package="java.text" superclassfulltype="java.text.CollationKey" fulltype="java.text.RuleBasedCollationKey" type="RuleBasedCollationKey">
		<comment>
			<description>A RuleBasedCollationKey is a concrete implementation of CollationKey class.
 The RuleBasedCollationKey class is used by the RuleBasedCollator class.</description>
		</comment>
		<fields>
			<field visibility="private" name="key" fulltype="java.lang.String" type="String" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="RuleBasedCollationKey">
				<comment>
					<description>A RuleBasedCollationKey can only be generated by Collator objects.</description>
				</comment>
				<params>
					<param name="source" fulltype="java.lang.String" type="String" />
					<param name="key" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method visibility="public" name="compareTo" returncomment="Returns an integer value. Value is less than zero if this is less
 than target, value is zero if this and target are equal and value is greater than
 zero if this is greater than target." fulltype="int" type="int">
				<comment>
					<description>Compare this RuleBasedCollationKey to target. The collation rules of the
 Collator object which created these keys are applied. &lt;strong&gt;Note:&lt;/strong&gt;
 RuleBasedCollationKeys created by different Collators can not be compared.</description>
					<attribute name="@param">
						<description>target target RuleBasedCollationKey</description>
					</attribute>
					<attribute name="@return">
						<description>Returns an integer value. Value is less than zero if this is less
 than target, value is zero if this and target are equal and value is greater than
 zero if this is greater than target.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#compare</description>
					</attribute>
				</comment>
				<params>
					<param name="target" comment="target RuleBasedCollationKey" fulltype="java.text.CollationKey" type="CollationKey" />
				</params>
			</method>
			<method visibility="public" name="equals" returncomment="Returns true if two objects are equal, false otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compare this RuleBasedCollationKey and the target for equality.
 The collation rules of the Collator object which created these keys are applied.
 &lt;strong&gt;Note:&lt;/strong&gt; RuleBasedCollationKeys created by different Collators can not be
 compared.</description>
					<attribute name="@param">
						<description>target the RuleBasedCollationKey to compare to.</description>
					</attribute>
					<attribute name="@return">
						<description>Returns true if two objects are equal, false otherwise.</description>
					</attribute>
				</comment>
				<params>
					<param name="target" comment="the RuleBasedCollationKey to compare to." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" returncomment="the hash value based on the string&apos;s collation order." fulltype="int" type="int">
				<comment>
					<description>Creates a hash code for this RuleBasedCollationKey. The hash value is calculated on the
 key itself, not the String from which the key was created.  Thus
 if x and y are RuleBasedCollationKeys, then x.hashCode(x) == y.hashCode() if
 x.equals(y) is true.  This allows language-sensitive comparison in a hash table.
 See the CollatinKey class description for an example.</description>
					<attribute name="@return">
						<description>the hash value based on the string&apos;s collation order.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toByteArray" fulltype="byte[]" type="byte">
				<comment>
					<description>Converts the RuleBasedCollationKey to a sequence of bits. If two RuleBasedCollationKeys
 could be legitimately compared, then one could compare the byte arrays
 for each of those keys to obtain the same result.  Byte arrays are
 organized most significant byte first.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="DateFormat" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.DateFormat" fulltype="java.text.SimpleDateFormat" type="SimpleDateFormat">
		<comment>
			<description>&lt;code&gt;SimpleDateFormat&lt;/code&gt; is a concrete class for formatting and
 parsing dates in a locale-sensitive manner. It allows for formatting
 (date -&gt; text), parsing (text -&gt; date), and normalization.

 &lt;p&gt;
 &lt;code&gt;SimpleDateFormat&lt;/code&gt; allows you to start by choosing
 any user-defined patterns for date-time formatting. However, you
 are encouraged to create a date-time formatter with either
 &lt;code&gt;getTimeInstance&lt;/code&gt;, &lt;code&gt;getDateInstance&lt;/code&gt;, or
 &lt;code&gt;getDateTimeInstance&lt;/code&gt; in &lt;code&gt;DateFormat&lt;/code&gt;. Each
 of these class methods can return a date/time formatter initialized
 with a default format pattern. You may modify the format pattern
 using the &lt;code&gt;applyPattern&lt;/code&gt; methods as desired.
 For more information on using these methods, see
 {@link DateFormat}.

 &lt;h4&gt;Date and Time Patterns&lt;/h4&gt;
 &lt;p&gt;
 Date and time formats are specified by &lt;em&gt;date and time pattern&lt;/em&gt;
 strings.
 Within date and time pattern strings, unquoted letters from
 &lt;code&gt;&apos;A&apos;&lt;/code&gt; to &lt;code&gt;&apos;Z&apos;&lt;/code&gt; and from &lt;code&gt;&apos;a&apos;&lt;/code&gt; to
 &lt;code&gt;&apos;z&apos;&lt;/code&gt; are interpreted as pattern letters representing the
 components of a date or time string.
 Text can be quoted using single quotes (&lt;code&gt;&apos;&lt;/code&gt;) to avoid
 interpretation.
 &lt;code&gt;&quot;&apos;&apos;&quot;&lt;/code&gt; represents a single quote.
 All other characters are not interpreted; they&apos;re simply copied into the
 output string during formatting or matched against the input string
 during parsing.
 &lt;p&gt;
 The following pattern letters are defined (all other characters from
 &lt;code&gt;&apos;A&apos;&lt;/code&gt; to &lt;code&gt;&apos;Z&apos;&lt;/code&gt; and from &lt;code&gt;&apos;a&apos;&lt;/code&gt; to
 &lt;code&gt;&apos;z&apos;&lt;/code&gt; are reserved):
 &lt;blockquote&gt;
 &lt;table border=0 cellspacing=3 cellpadding=0 summary=&quot;Chart shows pattern letters, date/time component, presentation, and examples.&quot;&gt;
     &lt;tr bgcolor=&quot;#ccccff&quot;&gt;
         &lt;th align=left&gt;Letter
         &lt;th align=left&gt;Date or Time Component
         &lt;th align=left&gt;Presentation
         &lt;th align=left&gt;Examples
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;G&lt;/code&gt;
         &lt;td&gt;Era designator
         &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;AD&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;y&lt;/code&gt;
         &lt;td&gt;Year
         &lt;td&gt;&lt;a href=&quot;#year&quot;&gt;Year&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;1996&lt;/code&gt;; &lt;code&gt;96&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;M&lt;/code&gt;
         &lt;td&gt;Month in year
         &lt;td&gt;&lt;a href=&quot;#month&quot;&gt;Month&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;July&lt;/code&gt;; &lt;code&gt;Jul&lt;/code&gt;; &lt;code&gt;07&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;w&lt;/code&gt;
         &lt;td&gt;Week in year
         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;27&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;W&lt;/code&gt;
         &lt;td&gt;Week in month
         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;2&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;D&lt;/code&gt;
         &lt;td&gt;Day in year
         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;189&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;d&lt;/code&gt;
         &lt;td&gt;Day in month
         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;10&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;F&lt;/code&gt;
         &lt;td&gt;Day of week in month
         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;2&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;E&lt;/code&gt;
         &lt;td&gt;Day in week
         &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;Tuesday&lt;/code&gt;; &lt;code&gt;Tue&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;a&lt;/code&gt;
         &lt;td&gt;Am/pm marker
         &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;PM&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;H&lt;/code&gt;
         &lt;td&gt;Hour in day (0-23)
         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;k&lt;/code&gt;
         &lt;td&gt;Hour in day (1-24)
         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;24&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;K&lt;/code&gt;
         &lt;td&gt;Hour in am/pm (0-11)
         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;h&lt;/code&gt;
         &lt;td&gt;Hour in am/pm (1-12)
         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;12&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;m&lt;/code&gt;
         &lt;td&gt;Minute in hour
         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;30&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;s&lt;/code&gt;
         &lt;td&gt;Second in minute
         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;55&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;S&lt;/code&gt;
         &lt;td&gt;Millisecond
         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;978&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;z&lt;/code&gt;
         &lt;td&gt;Time zone
         &lt;td&gt;&lt;a href=&quot;#timezone&quot;&gt;General time zone&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;Pacific Standard Time&lt;/code&gt;; &lt;code&gt;PST&lt;/code&gt;; &lt;code&gt;GMT-08:00&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;Z&lt;/code&gt;
         &lt;td&gt;Time zone
         &lt;td&gt;&lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zone&lt;/a&gt;
         &lt;td&gt;&lt;code&gt;-0800&lt;/code&gt;
 &lt;/table&gt;
 &lt;/blockquote&gt;
 Pattern letters are usually repeated, as their number determines the
 exact presentation:
 &lt;ul&gt;
 &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;text&quot;&gt;Text:&lt;/a&gt;&lt;/strong&gt;
     For formatting, if the number of pattern letters is 4 or more,
     the full form is used; otherwise a short or abbreviated form
     is used if available.
     For parsing, both forms are accepted, independent of the number
     of pattern letters.
 &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;number&quot;&gt;Number:&lt;/a&gt;&lt;/strong&gt;
     For formatting, the number of pattern letters is the minimum
     number of digits, and shorter numbers are zero-padded to this amount.
     For parsing, the number of pattern letters is ignored unless
     it&apos;s needed to separate two adjacent fields.
 &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;year&quot;&gt;Year:&lt;/a&gt;&lt;/strong&gt;
     If the formatter&apos;s {@link #getCalendar() Calendar} is the Gregorian
     calendar, the following rules are applied.&lt;br&gt;
     &lt;ul&gt;
     &lt;li&gt;For formatting, if the number of pattern letters is 2, the year
         is truncated to 2 digits; otherwise it is interpreted as a
         &lt;a href=&quot;#number&quot;&gt;number&lt;/a&gt;.
     &lt;li&gt;For parsing, if the number of pattern letters is more than 2,
         the year is interpreted literally, regardless of the number of
         digits. So using the pattern &quot;MM/dd/yyyy&quot;, &quot;01/11/12&quot; parses to
         Jan 11, 12 A.D.
     &lt;li&gt;For parsing with the abbreviated year pattern (&quot;y&quot; or &quot;yy&quot;),
         &lt;code&gt;SimpleDateFormat&lt;/code&gt; must interpret the abbreviated year
         relative to some century.  It does this by adjusting dates to be
         within 80 years before and 20 years after the time the &lt;code&gt;SimpleDateFormat&lt;/code&gt;
         instance is created. For example, using a pattern of &quot;MM/dd/yy&quot; and a
         &lt;code&gt;SimpleDateFormat&lt;/code&gt; instance created on Jan 1, 1997,  the string
         &quot;01/11/12&quot; would be interpreted as Jan 11, 2012 while the string &quot;05/04/64&quot;
         would be interpreted as May 4, 1964.
         During parsing, only strings consisting of exactly two digits, as defined by
         {@link Character#isDigit(char)}, will be parsed into the default century.
         Any other numeric string, such as a one digit string, a three or more digit
         string, or a two digit string that isn&apos;t all digits (for example, &quot;-1&quot;), is
         interpreted literally.  So &quot;01/02/3&quot; or &quot;01/02/003&quot; are parsed, using the
         same pattern, as Jan 2, 3 AD.  Likewise, &quot;01/02/-3&quot; is parsed as Jan 2, 4 BC.
     &lt;/ul&gt;
     Otherwise, calendar system specific forms are applied.
     For both formatting and parsing, if the number of pattern
     letters is 4 or more, a calendar specific {@linkplain
     Calendar#LONG long form} is used. Otherwise, a calendar
     specific {@linkplain Calendar#SHORT short or abbreviated form}
     is used.
 &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;month&quot;&gt;Month:&lt;/a&gt;&lt;/strong&gt;
     If the number of pattern letters is 3 or more, the month is
     interpreted as &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;; otherwise,
     it is interpreted as a &lt;a href=&quot;#number&quot;&gt;number&lt;/a&gt;.
 &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;timezone&quot;&gt;General time zone:&lt;/a&gt;&lt;/strong&gt;
     Time zones are interpreted as &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; if they have
     names. For time zones representing a GMT offset value, the
     following syntax is used:
     &lt;pre&gt;
     &lt;a name=&quot;GMTOffsetTimeZone&quot;&gt;&lt;i&gt;GMTOffsetTimeZone:&lt;/i&gt;&lt;/a&gt;
             &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; &lt;code&gt;:&lt;/code&gt; &lt;i&gt;Minutes&lt;/i&gt;
     &lt;i&gt;Sign:&lt;/i&gt; one of
             &lt;code&gt;+ -&lt;/code&gt;
     &lt;i&gt;Hours:&lt;/i&gt;
             &lt;i&gt;Digit&lt;/i&gt;
             &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
     &lt;i&gt;Minutes:&lt;/i&gt;
             &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
     &lt;i&gt;Digit:&lt;/i&gt; one of
             &lt;code&gt;0 1 2 3 4 5 6 7 8 9&lt;/code&gt;&lt;/pre&gt;
     &lt;i&gt;Hours&lt;/i&gt; must be between 0 and 23, and &lt;i&gt;Minutes&lt;/i&gt; must be between
     00 and 59. The format is locale independent and digits must be taken
     from the Basic Latin block of the Unicode standard.
     &lt;p&gt;For parsing, &lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zones&lt;/a&gt; are also
     accepted.
 &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;rfc822timezone&quot;&gt;RFC 822 time zone:&lt;/a&gt;&lt;/strong&gt;
     For formatting, the RFC 822 4-digit time zone format is used:
     &lt;pre&gt;
     &lt;i&gt;RFC822TimeZone:&lt;/i&gt;
             &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;
     &lt;i&gt;TwoDigitHours:&lt;/i&gt;
             &lt;i&gt;Digit Digit&lt;/i&gt;&lt;/pre&gt;
     &lt;i&gt;TwoDigitHours&lt;/i&gt; must be between 00 and 23. Other definitions
     are as for &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt;.
     &lt;p&gt;For parsing, &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt; are also
     accepted.
 &lt;/ul&gt;
 &lt;code&gt;SimpleDateFormat&lt;/code&gt; also supports &lt;em&gt;localized date and time
 pattern&lt;/em&gt; strings. In these strings, the pattern letters described above
 may be replaced with other, locale dependent, pattern letters.
 &lt;code&gt;SimpleDateFormat&lt;/code&gt; does not deal with the localization of text
 other than the pattern letters; that&apos;s up to the client of the class.
 &lt;p&gt;

 &lt;h4&gt;Examples&lt;/h4&gt;

 The following examples show how date and time patterns are interpreted in
 the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time
 in the U.S. Pacific Time time zone.
 &lt;blockquote&gt;
 &lt;table border=0 cellspacing=3 cellpadding=0 summary=&quot;Examples of date and time patterns interpreted in the U.S. locale&quot;&gt;
     &lt;tr bgcolor=&quot;#ccccff&quot;&gt;
         &lt;th align=left&gt;Date and Time Pattern
         &lt;th align=left&gt;Result
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;&quot;yyyy.MM.dd G &apos;at&apos; HH:mm:ss z&quot;&lt;/code&gt;
         &lt;td&gt;&lt;code&gt;2001.07.04 AD at 12:08:56 PDT&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;&quot;EEE, MMM d, &apos;&apos;yy&quot;&lt;/code&gt;
         &lt;td&gt;&lt;code&gt;Wed, Jul 4, &apos;01&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;&quot;h:mm a&quot;&lt;/code&gt;
         &lt;td&gt;&lt;code&gt;12:08 PM&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;&quot;hh &apos;o&apos;&apos;clock&apos; a, zzzz&quot;&lt;/code&gt;
         &lt;td&gt;&lt;code&gt;12 o&apos;clock PM, Pacific Daylight Time&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;&quot;K:mm a, z&quot;&lt;/code&gt;
         &lt;td&gt;&lt;code&gt;0:08 PM, PDT&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;&lt;/code&gt;
         &lt;td&gt;&lt;code&gt;02001.July.04 AD 12:08 PM&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;&quot;EEE, d MMM yyyy HH:mm:ss Z&quot;&lt;/code&gt;
         &lt;td&gt;&lt;code&gt;Wed, 4 Jul 2001 12:08:56 -0700&lt;/code&gt;
     &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
         &lt;td&gt;&lt;code&gt;&quot;yyMMddHHmmssZ&quot;&lt;/code&gt;
         &lt;td&gt;&lt;code&gt;010704120856-0700&lt;/code&gt;
     &lt;tr&gt;
         &lt;td&gt;&lt;code&gt;&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSSZ&quot;&lt;/code&gt;
         &lt;td&gt;&lt;code&gt;2001-07-04T12:08:56.235-0700&lt;/code&gt;
 &lt;/table&gt;
 &lt;/blockquote&gt;

 &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;

 &lt;p&gt;
 Date formats are not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently, it must be synchronized
 externally.</description>
			<attribute name="@see">
				<description>&lt;a href=&quot;http://java.sun.com/docs/books/tutorial/i18n/format/simpleDateFormat.html&quot;&gt;Java Tutorial&lt;/a&gt;</description>
			</attribute>
			<attribute name="@see">
				<description>java.util.Calendar</description>
			</attribute>
			<attribute name="@see">
				<description>java.util.TimeZone</description>
			</attribute>
			<attribute name="@see">
				<description>DateFormat</description>
			</attribute>
			<attribute name="@see">
				<description>DateFormatSymbols</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Davis, Chen-Lieh Huang, Alan Liu</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="4774881970558875024" visibility="package-private" name="serialVersionUID" constexpr="4774881970558875024L" fulltype="long" type="long" />
			<field final="true" static="true" const="1" visibility="package-private" name="currentSerialVersion" constexpr="1" fulltype="int" type="int" />
			<field visibility="private" name="serialVersionOnStream" fulltype="int" type="int">
				<comment>
					<description>The version of the serialized data on the stream.  Possible values:
 &lt;ul&gt;
 &lt;li&gt;&lt;b&gt;0&lt;/b&gt; or not present on stream: JDK 1.1.3.  This version
 has no &lt;code&gt;defaultCenturyStart&lt;/code&gt; on stream.
 &lt;li&gt;&lt;b&gt;1&lt;/b&gt; JDK 1.1.4 or later.  This version adds
 &lt;code&gt;defaultCenturyStart&lt;/code&gt;.
 &lt;/ul&gt;
 When streaming out this class, the most recent format
 and the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;
 is written.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>JDK1.1.4</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="pattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>The pattern string of this formatter.  This is always a non-localized
 pattern.  May not be null.  See class documentation for details.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" transient="true" name="compiledPattern" fulltype="char[]" type="char">
				<comment>
					<description>The compiled pattern.</description>
				</comment>
			</field>
			<field final="true" static="true" const="100" visibility="private" name="TAG_QUOTE_ASCII_CHAR" constexpr="100" fulltype="int" type="int">
				<comment>
					<description>Tags for the compiled pattern.</description>
				</comment>
			</field>
			<field final="true" static="true" const="101" visibility="private" name="TAG_QUOTE_CHARS" constexpr="101" fulltype="int" type="int" />
			<field visibility="private" transient="true" name="zeroDigit" fulltype="char" type="char">
				<comment>
					<description>Locale dependent digit zero.</description>
					<attribute name="@see">
						<description>#zeroPaddingNumber</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DecimalFormatSymbols#getZeroDigit</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="formatData" fulltype="java.text.DateFormatSymbols" type="DateFormatSymbols">
				<comment>
					<description>The symbols used by this formatter for week names, month names,
 etc.  May not be null.</description>
					<attribute name="@serial" />
					<attribute name="@see">
						<description>java.text.DateFormatSymbols</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="defaultCenturyStart" fulltype="java.util.Date" type="Date">
				<comment>
					<description>We map dates with two-digit years into the century starting at
 &lt;code&gt;defaultCenturyStart&lt;/code&gt;, which may be any date.  May
 not be null.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>JDK1.1.4</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" transient="true" name="defaultCenturyStartYear" fulltype="int" type="int" />
			<field final="true" static="true" const="3600000" visibility="private" name="millisPerHour" constexpr="3600000" fulltype="int" type="int" />
			<field final="true" static="true" const="60000" visibility="private" name="millisPerMinute" constexpr="60000" fulltype="int" type="int" />
			<field final="true" static="true" const="GMT" visibility="private" name="GMT" constexpr="&quot;GMT&quot;" fulltype="java.lang.String" type="String" />
			<field static="true" visibility="private" name="cachedLocaleData" fulltype="java.util.Hashtable" type="Hashtable">
				<comment>
					<description>Cache to hold the DateTimePatterns of a Locale.</description>
				</comment>
			</field>
			<field static="true" visibility="private" name="cachedNumberFormatData" fulltype="java.util.Hashtable" type="Hashtable">
				<comment>
					<description>Cache NumberFormat instances with Locale key.</description>
				</comment>
			</field>
			<field visibility="private" name="locale" fulltype="java.util.Locale" type="Locale">
				<comment>
					<description>The Locale used to instantiate this
 &lt;code&gt;SimpleDateFormat&lt;/code&gt;. The value may be null if this object
 has been created by an older &lt;code&gt;SimpleDateFormat&lt;/code&gt; and
 deserialized.</description>
					<attribute name="@serial" />
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</field>
			<field visibility="package-private" transient="true" name="useDateFormatSymbols" fulltype="boolean" type="boolean">
				<comment>
					<description>Indicates whether this &lt;code&gt;SimpleDateFormat&lt;/code&gt; should use
 the DateFormatSymbols. If true, the format and parse methods
 use the DateFormatSymbols values. If false, the format and
 parse methods call Calendar.getDisplayName or
 Calendar.getDisplayNames.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="PATTERN_INDEX_TO_CALENDAR_FIELD" fulltype="int[]" type="int" />
			<field final="true" static="true" visibility="private" name="PATTERN_INDEX_TO_DATE_FORMAT_FIELD" fulltype="int[]" type="int" />
			<field final="true" static="true" visibility="private" name="PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID" fulltype="java.text.DateFormat.Field[]" type="DateFormat.Field" />
		</fields>
		<methods>
			<constructor visibility="public" name="SimpleDateFormat">
				<comment>
					<description>Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the default pattern and
 date format symbols for the default locale.
 &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
 For full coverage, use the factory methods in the {@link DateFormat}
 class.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="SimpleDateFormat">
				<comment>
					<description>Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and
 the default date format symbols for the default locale.
 &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
 For full coverage, use the factory methods in the {@link DateFormat}
 class.</description>
					<attribute name="@param">
						<description>pattern the pattern describing the date and time format</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if the given pattern is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the given pattern is invalid</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="the pattern describing the date and time format" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="SimpleDateFormat">
				<comment>
					<description>Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and
 the default date format symbols for the given locale.
 &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
 For full coverage, use the factory methods in the {@link DateFormat}
 class.</description>
					<attribute name="@param">
						<description>pattern the pattern describing the date and time format</description>
					</attribute>
					<attribute name="@param">
						<description>locale the locale whose date format symbols should be used</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if the given pattern or locale is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the given pattern is invalid</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="the pattern describing the date and time format" fulltype="java.lang.String" type="String" />
					<param name="locale" comment="the locale whose date format symbols should be used" fulltype="java.util.Locale" type="Locale" />
				</params>
			</constructor>
			<constructor visibility="public" name="SimpleDateFormat">
				<comment>
					<description>Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and
 date format symbols.</description>
					<attribute name="@param">
						<description>pattern the pattern describing the date and time format</description>
					</attribute>
					<attribute name="@param">
						<description>formatSymbols the date format symbols to be used for formatting</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if the given pattern or formatSymbols is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the given pattern is invalid</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="the pattern describing the date and time format" fulltype="java.lang.String" type="String" />
					<param name="formatSymbols" comment="the date format symbols to be used for formatting" fulltype="java.text.DateFormatSymbols" type="DateFormatSymbols" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="SimpleDateFormat">
				<params>
					<param name="timeStyle" fulltype="int" type="int" />
					<param name="dateStyle" fulltype="int" type="int" />
					<param name="loc" fulltype="java.util.Locale" type="Locale" />
				</params>
			</constructor>
			<method visibility="private" name="initialize" fulltype="void" type="void">
				<params>
					<param name="loc" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method visibility="private" name="initializeCalendar" fulltype="void" type="void">
				<params>
					<param name="loc" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method visibility="private" name="getKey" fulltype="java.lang.String" type="String" />
			<method visibility="private" name="compile" fulltype="char[]" type="char">
				<comment>
					<description>Returns the compiled form of the given pattern. The syntax of
 the compiled pattern is:
 &lt;blockquote&gt;
 CompiledPattern:
     EntryList
 EntryList:
     Entry
     EntryList Entry
 Entry:
     TagField
     TagField data
 TagField:
     Tag Length
     TaggedData
 Tag:
     pattern_char_index
     TAG_QUOTE_CHARS
 Length:
     short_length
     long_length
 TaggedData:
     TAG_QUOTE_ASCII_CHAR ascii_char

 &lt;/blockquote&gt;

 where `short_length&apos; is an 8-bit unsigned integer between 0 and
 254.  `long_length&apos; is a sequence of an 8-bit integer 255 and a
 32-bit signed integer value which is split into upper and lower
 16-bit fields in two char&apos;s. `pattern_char_index&apos; is an 8-bit
 integer between 0 and 18. `ascii_char&apos; is an 7-bit ASCII
 character value. `data&apos; depends on its Tag value.
 &lt;p&gt;
 If Length is short_length, Tag and short_length are packed in a
 single char, as illustrated below.
 &lt;blockquote&gt;
     char[0] = (Tag &lt;&lt; 8) | short_length;
 &lt;/blockquote&gt;

 If Length is long_length, Tag and 255 are packed in the first
 char and a 32-bit integer, as illustrated below.
 &lt;blockquote&gt;
     char[0] = (Tag &lt;&lt; 8) | 255;
     char[1] = (char) (long_length &gt;&gt;&gt; 16);
     char[2] = (char) (long_length &amp; 0xffff);
 &lt;/blockquote&gt;
 &lt;p&gt;
 If Tag is a pattern_char_index, its Length is the number of
 pattern characters. For example, if the given pattern is
 &quot;yyyy&quot;, Tag is 1 and Length is 4, followed by no data.
 &lt;p&gt;
 If Tag is TAG_QUOTE_CHARS, its Length is the number of char&apos;s
 following the TagField. For example, if the given pattern is
 &quot;&apos;o&apos;&apos;clock&apos;&quot;, Length is 7 followed by a char sequence of
 &lt;code&gt;o&amp;nbs;&apos;&amp;nbs;c&amp;nbs;l&amp;nbs;o&amp;nbs;c&amp;nbs;k&lt;/code&gt;.
 &lt;p&gt;
 TAG_QUOTE_ASCII_CHAR is a special tag and has an ASCII
 character in place of Length. For example, if the given pattern
 is &quot;&apos;o&apos;&quot;, the TaggedData entry is
 &lt;code&gt;((TAG_QUOTE_ASCII_CHAR&amp;nbs;&lt;&lt;&amp;nbs;8)&amp;nbs;|&amp;nbs;&apos;o&apos;)&lt;/code&gt;.</description>
					<attribute name="@exception">
						<description>NullPointerException if the given pattern is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the given pattern is invalid</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method final="true" static="true" visibility="private" name="encode" fulltype="void" type="void">
				<comment>
					<description>Encodes the given tag and length and puts encoded char(s) into buffer.</description>
				</comment>
				<params>
					<param name="tag" fulltype="int" type="int" />
					<param name="length" fulltype="int" type="int" />
					<param name="buffer" fulltype="java.lang.StringBuilder" type="StringBuilder" />
				</params>
			</method>
			<method visibility="private" name="initializeDefaultCentury" fulltype="void" type="void" />
			<method visibility="private" name="parseAmbiguousDatesAsAfter" fulltype="void" type="void">
				<params>
					<param name="startDate" fulltype="java.util.Date" type="Date" />
				</params>
			</method>
			<method visibility="public" name="set2DigitYearStart" fulltype="void" type="void">
				<comment>
					<description>Sets the 100-year period 2-digit years will be interpreted as being in
 to begin on the date the user specifies.</description>
					<attribute name="@param">
						<description>startDate During parsing, two digit years will be placed in the range
 &lt;code&gt;startDate&lt;/code&gt; to &lt;code&gt;startDate + 100 years&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@see">
						<description>#get2DigitYearStart</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="startDate" comment="During parsing, two digit years will be placed in the range
 &lt;code&gt;startDate&lt;/code&gt; to &lt;code&gt;startDate + 100 years&lt;/code&gt;." fulltype="java.util.Date" type="Date" />
				</params>
			</method>
			<method visibility="public" name="get2DigitYearStart" returncomment="the start of the 100-year period into which two digit years are
 parsed" fulltype="java.util.Date" type="Date">
				<comment>
					<description>Returns the beginning date of the 100-year period 2-digit years are interpreted
 as being within.</description>
					<attribute name="@return">
						<description>the start of the 100-year period into which two digit years are
 parsed</description>
					</attribute>
					<attribute name="@see">
						<description>#set2DigitYearStart</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="format" returncomment="the formatted date-time string." fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Formats the given &lt;code&gt;Date&lt;/code&gt; into a date/time string and appends
 the result to the given &lt;code&gt;StringBuffer&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>date the date-time value to be formatted into a date-time string.</description>
					</attribute>
					<attribute name="@param">
						<description>toAppendTo where the new date-time text is to be appended.</description>
					</attribute>
					<attribute name="@param">
						<description>pos the formatting position. On input: an alignment field,
 if desired. On output: the offsets of the alignment field.</description>
					</attribute>
					<attribute name="@return">
						<description>the formatted date-time string.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if the given date is null</description>
					</attribute>
				</comment>
				<params>
					<param name="date" comment="the date-time value to be formatted into a date-time string." fulltype="java.util.Date" type="Date" />
					<param name="toAppendTo" comment="where the new date-time text is to be appended." fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="pos" comment="the formatting position. On input: an alignment field,
 if desired. On output: the offsets of the alignment field." fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method visibility="private" name="format" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<params>
					<param name="date" fulltype="java.util.Date" type="Date" />
					<param name="toAppendTo" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="delegate" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
				</params>
			</method>
			<method visibility="public" name="formatToCharacterIterator" returncomment="AttributedCharacterIterator describing the formatted value." fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
				<comment>
					<description>Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
 You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
 to build the resulting String, as well as to determine information
 about the resulting String.
 &lt;p&gt;
 Each attribute key of the AttributedCharacterIterator will be of type
 &lt;code&gt;DateFormat.Field&lt;/code&gt;, with the corresponding attribute value
 being the same as the attribute key.</description>
					<attribute name="@exception">
						<description>NullPointerException if obj is null.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the Format cannot format the
            given object, or if the Format&apos;s pattern string is invalid.</description>
					</attribute>
					<attribute name="@param">
						<description>obj The object to format</description>
					</attribute>
					<attribute name="@return">
						<description>AttributedCharacterIterator describing the formatted value.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="The object to format" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="private" name="subFormat" fulltype="void" type="void">
				<comment>
					<description>Private member function that does the real date/time formatting.</description>
				</comment>
				<params>
					<param name="patternCharIndex" fulltype="int" type="int" />
					<param name="count" fulltype="int" type="int" />
					<param name="delegate" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
					<param name="buffer" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="useDateFormatSymbols" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method final="true" visibility="private" name="zeroPaddingNumber" fulltype="void" type="void">
				<comment>
					<description>Formats a number with the specified minimum and maximum number of digits.</description>
				</comment>
				<params>
					<param name="value" fulltype="int" type="int" />
					<param name="minDigits" fulltype="int" type="int" />
					<param name="maxDigits" fulltype="int" type="int" />
					<param name="buffer" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
			<method visibility="public" name="parse" returncomment="A &lt;code&gt;Date&lt;/code&gt; parsed from the string. In case of
         error, returns null." fulltype="java.util.Date" type="Date">
				<comment>
					<description>Parses text from a string to produce a &lt;code&gt;Date&lt;/code&gt;.
 &lt;p&gt;
 The method attempts to parse text starting at the index given by
 &lt;code&gt;pos&lt;/code&gt;.
 If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
 to the index after the last character used (parsing does not necessarily
 use all characters up to the end of the string), and the parsed
 date is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
 indicate the starting point for the next call to this method.
 If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
 changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
 the character where the error occurred, and null is returned.</description>
					<attribute name="@param">
						<description>text  A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</description>
					</attribute>
					<attribute name="@param">
						<description>pos   A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
              index information as described above.</description>
					</attribute>
					<attribute name="@return">
						<description>A &lt;code&gt;Date&lt;/code&gt; parsed from the string. In case of
         error, returns null.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;pos&lt;/code&gt; is null.</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed." fulltype="java.lang.String" type="String" />
					<param name="pos" comment="A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
              index information as described above." fulltype="java.text.ParsePosition" type="ParsePosition" />
				</params>
			</method>
			<method visibility="private" name="matchString" returncomment="the new start position if matching succeeded; a negative number
 indicating matching failure, otherwise." fulltype="int" type="int">
				<comment>
					<description>Private code-size reduction function used by subParse.</description>
					<attribute name="@param">
						<description>text the time text being parsed.</description>
					</attribute>
					<attribute name="@param">
						<description>start where to start parsing.</description>
					</attribute>
					<attribute name="@param">
						<description>field the date field being parsed.</description>
					</attribute>
					<attribute name="@param">
						<description>data the string array to parsed.</description>
					</attribute>
					<attribute name="@return">
						<description>the new start position if matching succeeded; a negative number
 indicating matching failure, otherwise.</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="the time text being parsed." fulltype="java.lang.String" type="String" />
					<param name="start" comment="where to start parsing." fulltype="int" type="int" />
					<param name="field" comment="the date field being parsed." fulltype="int" type="int" />
					<param name="data" comment="the string array to parsed." fulltype="java.lang.String[]" type="String" />
				</params>
			</method>
			<method visibility="private" name="matchString" fulltype="int" type="int">
				<comment>
					<description>Performs the same thing as matchString(String, int, int,
 String[]). This method takes a Map&lt;String, Integer&gt; instead of
 String[].</description>
				</comment>
				<params>
					<param name="text" fulltype="java.lang.String" type="String" />
					<param name="start" fulltype="int" type="int" />
					<param name="field" fulltype="int" type="int" />
					<param name="data" fulltype="java.util.Map" type="Map" />
				</params>
			</method>
			<method visibility="private" name="matchZoneString" fulltype="int" type="int">
				<params>
					<param name="text" fulltype="java.lang.String" type="String" />
					<param name="start" fulltype="int" type="int" />
					<param name="zoneIndex" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="matchDSTString" fulltype="boolean" type="boolean">
				<params>
					<param name="text" fulltype="java.lang.String" type="String" />
					<param name="start" fulltype="int" type="int" />
					<param name="zoneIndex" fulltype="int" type="int" />
					<param name="standardIndex" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="subParseZoneString" fulltype="int" type="int">
				<comment>
					<description>find time zone &apos;text&apos; matched zoneStrings and set to internal
 calendar.</description>
				</comment>
				<params>
					<param name="text" fulltype="java.lang.String" type="String" />
					<param name="start" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="subParse" returncomment="the new start position if matching succeeded; -1 indicating
 matching failure, otherwise. In case matching failure occurred,
 an error index is set to origPos.errorIndex." fulltype="int" type="int">
				<comment>
					<description>Private member function that converts the parsed date strings into
 timeFields. Returns -start (for ParsePosition) if failed.</description>
					<attribute name="@param">
						<description>text the time text to be parsed.</description>
					</attribute>
					<attribute name="@param">
						<description>start where to start parsing.</description>
					</attribute>
					<attribute name="@param">
						<description>ch the pattern character for the date field text to be parsed.</description>
					</attribute>
					<attribute name="@param">
						<description>count the count of a pattern character.</description>
					</attribute>
					<attribute name="@param">
						<description>obeyCount if true, then the next field directly abuts this one,
 and we should use the count to know when to stop parsing.</description>
					</attribute>
					<attribute name="@param">
						<description>ambiguousYear return parameter; upon return, if ambiguousYear[0]
 is true, then a two-digit year was parsed and may need to be readjusted.</description>
					</attribute>
					<attribute name="@param">
						<description>origPos origPos.errorIndex is used to return an error index
 at which a parse error occurred, if matching failure occurs.</description>
					</attribute>
					<attribute name="@return">
						<description>the new start position if matching succeeded; -1 indicating
 matching failure, otherwise. In case matching failure occurred,
 an error index is set to origPos.errorIndex.</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="the time text to be parsed." fulltype="java.lang.String" type="String" />
					<param name="start" comment="where to start parsing." fulltype="int" type="int" />
					<param name="patternCharIndex" fulltype="int" type="int" />
					<param name="count" comment="the count of a pattern character." fulltype="int" type="int" />
					<param name="obeyCount" comment="if true, then the next field directly abuts this one,
 and we should use the count to know when to stop parsing." fulltype="boolean" type="boolean" />
					<param name="ambiguousYear" comment="return parameter; upon return, if ambiguousYear[0]
 is true, then a two-digit year was parsed and may need to be readjusted." fulltype="boolean[]" type="boolean" />
					<param name="origPos" comment="origPos.errorIndex is used to return an error index
 at which a parse error occurred, if matching failure occurs." fulltype="java.text.ParsePosition" type="ParsePosition" />
				</params>
			</method>
			<method final="true" visibility="private" name="getCalendarName" fulltype="java.lang.String" type="String" />
			<method visibility="private" name="useDateFormatSymbols" fulltype="boolean" type="boolean" />
			<method visibility="private" name="isGregorianCalendar" fulltype="boolean" type="boolean" />
			<method visibility="private" name="translatePattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>Translates a pattern, mapping each character in the from string to the
 corresponding character in the to string.</description>
					<attribute name="@exception">
						<description>IllegalArgumentException if the given pattern is invalid</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" fulltype="java.lang.String" type="String" />
					<param name="from" fulltype="java.lang.String" type="String" />
					<param name="to" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="toPattern" returncomment="a pattern string describing this date format." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns a pattern string describing this date format.</description>
					<attribute name="@return">
						<description>a pattern string describing this date format.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toLocalizedPattern" returncomment="a localized pattern string describing this date format." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns a localized pattern string describing this date format.</description>
					<attribute name="@return">
						<description>a localized pattern string describing this date format.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="applyPattern" fulltype="void" type="void">
				<comment>
					<description>Applies the given pattern string to this date format.</description>
					<attribute name="@param">
						<description>pattern the new date and time pattern for this date format</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if the given pattern is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the given pattern is invalid</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="the new date and time pattern for this date format" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="applyLocalizedPattern" fulltype="void" type="void">
				<comment>
					<description>Applies the given localized pattern string to this date format.</description>
					<attribute name="@param">
						<description>pattern a String to be mapped to the new date and time format
        pattern for this format</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if the given pattern is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the given pattern is invalid</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="a String to be mapped to the new date and time format
        pattern for this format" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getDateFormatSymbols" returncomment="the date and time format symbols of this date format" fulltype="java.text.DateFormatSymbols" type="DateFormatSymbols">
				<comment>
					<description>Gets a copy of the date and time format symbols of this date format.</description>
					<attribute name="@return">
						<description>the date and time format symbols of this date format</description>
					</attribute>
					<attribute name="@see">
						<description>#setDateFormatSymbols</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setDateFormatSymbols" fulltype="void" type="void">
				<comment>
					<description>Sets the date and time format symbols of this date format.</description>
					<attribute name="@param">
						<description>newFormatSymbols the new date and time format symbols</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if the given newFormatSymbols is null</description>
					</attribute>
					<attribute name="@see">
						<description>#getDateFormatSymbols</description>
					</attribute>
				</comment>
				<params>
					<param name="newFormatSymbols" comment="the new date and time format symbols" fulltype="java.text.DateFormatSymbols" type="DateFormatSymbols" />
				</params>
			</method>
			<method visibility="public" name="clone" returncomment="a clone of this &lt;code&gt;SimpleDateFormat&lt;/code&gt;" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Creates a copy of this &lt;code&gt;SimpleDateFormat&lt;/code&gt;. This also
 clones the format&apos;s date format symbols.</description>
					<attribute name="@return">
						<description>a clone of this &lt;code&gt;SimpleDateFormat&lt;/code&gt;</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="hashCode" returncomment="the hash code value for this &lt;code&gt;SimpleDateFormat&lt;/code&gt; object." fulltype="int" type="int">
				<comment>
					<description>Returns the hash code value for this &lt;code&gt;SimpleDateFormat&lt;/code&gt; object.</description>
					<attribute name="@return">
						<description>the hash code value for this &lt;code&gt;SimpleDateFormat&lt;/code&gt; object.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="equals" returncomment="true if the given object is equal to this
 &lt;code&gt;SimpleDateFormat&lt;/code&gt;" fulltype="boolean" type="boolean">
				<comment>
					<description>Compares the given object with this &lt;code&gt;SimpleDateFormat&lt;/code&gt; for
 equality.</description>
					<attribute name="@return">
						<description>true if the given object is equal to this
 &lt;code&gt;SimpleDateFormat&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<comment>
					<description>After reading an object from the input stream, the format
 pattern in the object is verified.
 &lt;p&gt;</description>
					<attribute name="@exception">
						<description>InvalidObjectException if the pattern is invalid</description>
					</attribute>
				</comment>
				<params>
					<param name="stream" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="public" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.Bidi" type="Bidi">
		<comment>
			<description>This class implements the Unicode Bidirectional Algorithm.
 &lt;p&gt;
 A Bidi object provides information on the bidirectional reordering of the text
 used to create it.  This is required, for example, to properly display Arabic
 or Hebrew text.  These languages are inherently mixed directional, as they order
 numbers from left-to-right while ordering most other text from right-to-left.
 &lt;p&gt;
 Once created, a Bidi object can be queried to see if the text it represents is
 all left-to-right or all right-to-left.  Such objects are very lightweight and
 this text is relatively easy to process.
 &lt;p&gt;
 If there are multiple runs of text, information about the runs can be accessed
 by indexing to get the start, limit, and level of a run.  The level represents
 both the direction and the &apos;nesting level&apos; of a directional run.  Odd levels
 are right-to-left, while even levels are left-to-right.  So for example level
 0 represents left-to-right text, while level 1 represents right-to-left text, and
 level 2 represents left-to-right text embedded in a right-to-left run.</description>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="dir" fulltype="byte" type="byte" />
			<field visibility="package-private" name="baselevel" fulltype="byte" type="byte" />
			<field visibility="package-private" name="length" fulltype="int" type="int" />
			<field visibility="package-private" name="runs" fulltype="int[]" type="int" />
			<field visibility="package-private" name="cws" fulltype="int[]" type="int" />
			<field final="true" static="true" const="0" visibility="public" name="DIRECTION_LEFT_TO_RIGHT" constexpr="0" fulltype="int" type="int">
				<comment>
					<description>Constant indicating base direction is left-to-right.</description>
				</comment>
			</field>
			<field final="true" static="true" const="1" visibility="public" name="DIRECTION_RIGHT_TO_LEFT" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>Constant indicating base direction is right-to-left.</description>
				</comment>
			</field>
			<field final="true" static="true" const="-2" visibility="public" name="DIRECTION_DEFAULT_LEFT_TO_RIGHT" constexpr="-2" fulltype="int" type="int">
				<comment>
					<description>Constant indicating that the base direction depends on the first strong
 directional character in the text according to the Unicode
 Bidirectional Algorithm.  If no strong directional character is present,
 the base direction is left-to-right.</description>
				</comment>
			</field>
			<field final="true" static="true" const="-1" visibility="public" name="DIRECTION_DEFAULT_RIGHT_TO_LEFT" constexpr="-1" fulltype="int" type="int">
				<comment>
					<description>Constant indicating that the base direction depends on the first strong
 directional character in the text according to the Unicode
 Bidirectional Algorithm.  If no strong directional character is present,
 the base direction is right-to-left.</description>
				</comment>
			</field>
			<field final="true" static="true" const="2" visibility="private" name="DIR_MIXED" constexpr="2" fulltype="int" type="int" />
			<field final="true" static="true" const="62" visibility="private" name="NUMLEVELS" constexpr="62" fulltype="char" type="char" />
			<field final="true" static="true" const="57378" visibility="private" name="RMASK" constexpr="57378" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="public" name="Bidi">
				<comment>
					<description>Create Bidi from the given paragraph of text and base direction.</description>
					<attribute name="@param">
						<description>paragraph a paragraph of text</description>
					</attribute>
					<attribute name="@param">
						<description>flags a collection of flags that control the algorithm.  The
 algorithm understands the flags DIRECTION_LEFT_TO_RIGHT, DIRECTION_RIGHT_TO_LEFT,
 DIRECTION_DEFAULT_LEFT_TO_RIGHT, and DIRECTION_DEFAULT_RIGHT_TO_LEFT.
 Other values are reserved.</description>
					</attribute>
				</comment>
				<params>
					<param name="paragraph" comment="a paragraph of text" fulltype="java.lang.String" type="String" />
					<param name="flags" comment="a collection of flags that control the algorithm.  The
 algorithm understands the flags DIRECTION_LEFT_TO_RIGHT, DIRECTION_RIGHT_TO_LEFT,
 DIRECTION_DEFAULT_LEFT_TO_RIGHT, and DIRECTION_DEFAULT_RIGHT_TO_LEFT.
 Other values are reserved." fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="Bidi">
				<comment>
					<description>Create Bidi from the given paragraph of text.
 &lt;p&gt;
 The RUN_DIRECTION attribute in the text, if present, determines the base
 direction (left-to-right or right-to-left).  If not present, the base
 direction is computes using the Unicode Bidirectional Algorithm, defaulting to left-to-right
 if there are no strong directional characters in the text.  This attribute, if
 present, must be applied to all the text in the paragraph.
 &lt;p&gt;
 The BIDI_EMBEDDING attribute in the text, if present, represents embedding level
 information.  Negative values from -1 to -62 indicate overrides at the absolute value
 of the level.  Positive values from 1 to 62 indicate embeddings.  Where values are
 zero or not defined, the base embedding level as determined by the base direction
 is assumed.
 &lt;p&gt;
 The NUMERIC_SHAPING attribute in the text, if present, converts European digits to
 other decimal digits before running the bidi algorithm.  This attribute, if present,
 must be applied to all the text in the paragraph.</description>
					<attribute name="@param">
						<description>paragraph a paragraph of text with optional character and paragraph attribute information</description>
					</attribute>
					<attribute name="@see">
						<description>java.awt.font.TextAttribute#BIDI_EMBEDDING</description>
					</attribute>
					<attribute name="@see">
						<description>java.awt.font.TextAttribute#NUMERIC_SHAPING</description>
					</attribute>
					<attribute name="@see">
						<description>java.awt.font.TextAttribute#RUN_DIRECTION</description>
					</attribute>
				</comment>
				<params>
					<param name="paragraph" comment="a paragraph of text with optional character and paragraph attribute information" fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator" />
				</params>
			</constructor>
			<constructor visibility="public" name="Bidi">
				<comment>
					<description>Create Bidi from the given text, embedding, and direction information.
 The embeddings array may be null.  If present, the values represent embedding level
 information.  Negative values from -1 to -61 indicate overrides at the absolute value
 of the level.  Positive values from 1 to 61 indicate embeddings.  Where values are
 zero, the base embedding level as determined by the base direction is assumed.</description>
					<attribute name="@param">
						<description>text an array containing the paragraph of text to process.</description>
					</attribute>
					<attribute name="@param">
						<description>textStart the index into the text array of the start of the paragraph.</description>
					</attribute>
					<attribute name="@param">
						<description>embeddings an array containing embedding values for each character in the paragraph.
 This can be null, in which case it is assumed that there is no external embedding information.</description>
					</attribute>
					<attribute name="@param">
						<description>embStart the index into the embedding array of the start of the paragraph.</description>
					</attribute>
					<attribute name="@param">
						<description>paragraphLength the length of the paragraph in the text and embeddings arrays.</description>
					</attribute>
					<attribute name="@param">
						<description>flags a collection of flags that control the algorithm.  The
 algorithm understands the flags DIRECTION_LEFT_TO_RIGHT, DIRECTION_RIGHT_TO_LEFT,
 DIRECTION_DEFAULT_LEFT_TO_RIGHT, and DIRECTION_DEFAULT_RIGHT_TO_LEFT.
 Other values are reserved.</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="an array containing the paragraph of text to process." fulltype="char[]" type="char" />
					<param name="textStart" comment="the index into the text array of the start of the paragraph." fulltype="int" type="int" />
					<param name="embeddings" comment="an array containing embedding values for each character in the paragraph.
 This can be null, in which case it is assumed that there is no external embedding information." fulltype="byte[]" type="byte" />
					<param name="embStart" comment="the index into the embedding array of the start of the paragraph." fulltype="int" type="int" />
					<param name="paragraphLength" comment="the length of the paragraph in the text and embeddings arrays." fulltype="int" type="int" />
					<param name="flags" comment="a collection of flags that control the algorithm.  The
 algorithm understands the flags DIRECTION_LEFT_TO_RIGHT, DIRECTION_RIGHT_TO_LEFT,
 DIRECTION_DEFAULT_LEFT_TO_RIGHT, and DIRECTION_DEFAULT_RIGHT_TO_LEFT.
 Other values are reserved." fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="private" name="Bidi">
				<comment>
					<description>Private constructor used by line bidi.</description>
				</comment>
				<params>
					<param name="dir" fulltype="int" type="int" />
					<param name="baseLevel" fulltype="int" type="int" />
					<param name="length" fulltype="int" type="int" />
					<param name="data" fulltype="int[]" type="int" />
					<param name="cws" fulltype="int[]" type="int" />
				</params>
			</constructor>
			<method visibility="private" name="reset" fulltype="void" type="void">
				<comment>
					<description>Private mutator used by native code.</description>
				</comment>
				<params>
					<param name="dir" fulltype="int" type="int" />
					<param name="baselevel" fulltype="int" type="int" />
					<param name="length" fulltype="int" type="int" />
					<param name="data" fulltype="int[]" type="int" />
					<param name="cws" fulltype="int[]" type="int" />
				</params>
			</method>
			<method visibility="public" name="createLineBidi" fulltype="java.text.Bidi" type="Bidi">
				<comment>
					<description>Create a Bidi object representing the bidi information on a line of text within
 the paragraph represented by the current Bidi.  This call is not required if the
 entire paragraph fits on one line.</description>
					<attribute name="@param">
						<description>lineStart the offset from the start of the paragraph to the start of the line.</description>
					</attribute>
					<attribute name="@param">
						<description>lineLimit the offset from the start of the paragraph to the limit of the line.</description>
					</attribute>
				</comment>
				<params>
					<param name="lineStart" comment="the offset from the start of the paragraph to the start of the line." fulltype="int" type="int" />
					<param name="lineLimit" comment="the offset from the start of the paragraph to the limit of the line." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="isMixed" returncomment="true if the line is not left-to-right or right-to-left." fulltype="boolean" type="boolean">
				<comment>
					<description>Return true if the line is not left-to-right or right-to-left.  This means it either has mixed runs of left-to-right
 and right-to-left text, or the base direction differs from the direction of the only run of text.</description>
					<attribute name="@return">
						<description>true if the line is not left-to-right or right-to-left.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isLeftToRight" returncomment="true if the line is all left-to-right text and the base direction is left-to-right" fulltype="boolean" type="boolean">
				<comment>
					<description>Return true if the line is all left-to-right text and the base direction is left-to-right.</description>
					<attribute name="@return">
						<description>true if the line is all left-to-right text and the base direction is left-to-right</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isRightToLeft" returncomment="true if the line is all right-to-left text, and the base direction is right-to-left" fulltype="boolean" type="boolean">
				<comment>
					<description>Return true if the line is all right-to-left text, and the base direction is right-to-left.</description>
					<attribute name="@return">
						<description>true if the line is all right-to-left text, and the base direction is right-to-left</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getLength" returncomment="the length of text in the line" fulltype="int" type="int">
				<comment>
					<description>Return the length of text in the line.</description>
					<attribute name="@return">
						<description>the length of text in the line</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="baseIsLeftToRight" returncomment="true if the base direction is left-to-right" fulltype="boolean" type="boolean">
				<comment>
					<description>Return true if the base direction is left-to-right.</description>
					<attribute name="@return">
						<description>true if the base direction is left-to-right</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getBaseLevel" returncomment="the base level" fulltype="int" type="int">
				<comment>
					<description>Return the base level (0 if left-to-right, 1 if right-to-left).</description>
					<attribute name="@return">
						<description>the base level</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getLevelAt" returncomment="the resolved level of the character at offset" fulltype="int" type="int">
				<comment>
					<description>Return the resolved level of the character at offset.  If offset is &lt;0 or &gt;=
 the length of the line, return the base direction level.</description>
					<attribute name="@param">
						<description>offset the index of the character for which to return the level</description>
					</attribute>
					<attribute name="@return">
						<description>the resolved level of the character at offset</description>
					</attribute>
				</comment>
				<params>
					<param name="offset" comment="the index of the character for which to return the level" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getRunCount" returncomment="the number of level runs" fulltype="int" type="int">
				<comment>
					<description>Return the number of level runs.</description>
					<attribute name="@return">
						<description>the number of level runs</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getRunLevel" returncomment="the level of the run" fulltype="int" type="int">
				<comment>
					<description>Return the level of the nth logical run in this line.</description>
					<attribute name="@param">
						<description>run the index of the run, between 0 and &lt;code&gt;getRunCount()&lt;/code&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>the level of the run</description>
					</attribute>
				</comment>
				<params>
					<param name="run" comment="the index of the run, between 0 and &lt;code&gt;getRunCount()&lt;/code&gt;" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getRunStart" returncomment="the start of the run" fulltype="int" type="int">
				<comment>
					<description>Return the index of the character at the start of the nth logical run in this line, as
 an offset from the start of the line.</description>
					<attribute name="@param">
						<description>run the index of the run, between 0 and &lt;code&gt;getRunCount()&lt;/code&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>the start of the run</description>
					</attribute>
				</comment>
				<params>
					<param name="run" comment="the index of the run, between 0 and &lt;code&gt;getRunCount()&lt;/code&gt;" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getRunLimit" returncomment="limit the limit of the run" fulltype="int" type="int">
				<comment>
					<description>Return the index of the character past the end of the nth logical run in this line, as
 an offset from the start of the line.  For example, this will return the length
 of the line for the last run on the line.</description>
					<attribute name="@param">
						<description>run the index of the run, between 0 and &lt;code&gt;getRunCount()&lt;/code&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>limit the limit of the run</description>
					</attribute>
				</comment>
				<params>
					<param name="run" comment="the index of the run, between 0 and &lt;code&gt;getRunCount()&lt;/code&gt;" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="public" name="requiresBidi" returncomment="true if the range of characters requires bidi analysis" fulltype="boolean" type="boolean">
				<comment>
					<description>Return true if the specified text requires bidi analysis.  If this returns false,
 the text will display left-to-right.  Clients can then avoid constructing a Bidi object.
 Text in the Arabic Presentation Forms area of Unicode is presumed to already be shaped
 and ordered for display, and so will not cause this function to return true.</description>
					<attribute name="@param">
						<description>text the text containing the characters to test</description>
					</attribute>
					<attribute name="@param">
						<description>start the start of the range of characters to test</description>
					</attribute>
					<attribute name="@param">
						<description>limit the limit of the range of characters to test</description>
					</attribute>
					<attribute name="@return">
						<description>true if the range of characters requires bidi analysis</description>
					</attribute>
				</comment>
				<params>
					<param name="text" comment="the text containing the characters to test" fulltype="char[]" type="char" />
					<param name="start" comment="the start of the range of characters to test" fulltype="int" type="int" />
					<param name="limit" comment="the limit of the range of characters to test" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="public" name="reorderVisually" fulltype="void" type="void">
				<comment>
					<description>Reorder the objects in the array into visual order based on their levels.
 This is a utility function to use when you have a collection of objects
 representing runs of text in logical order, each run containing text
 at a single level.  The elements at &lt;code&gt;index&lt;/code&gt; from
 &lt;code&gt;objectStart&lt;/code&gt; up to &lt;code&gt;objectStart + count&lt;/code&gt;
 in the objects array will be reordered into visual order assuming
 each run of text has the level indicated by the corresponding element
 in the levels array (at &lt;code&gt;index - objectStart + levelStart&lt;/code&gt;).</description>
					<attribute name="@param">
						<description>levels an array representing the bidi level of each object</description>
					</attribute>
					<attribute name="@param">
						<description>levelStart the start position in the levels array</description>
					</attribute>
					<attribute name="@param">
						<description>objects the array of objects to be reordered into visual order</description>
					</attribute>
					<attribute name="@param">
						<description>objectStart the start position in the objects array</description>
					</attribute>
					<attribute name="@param">
						<description>count the number of objects to reorder</description>
					</attribute>
				</comment>
				<params>
					<param name="levels" comment="an array representing the bidi level of each object" fulltype="byte[]" type="byte" />
					<param name="levelStart" comment="the start position in the levels array" fulltype="int" type="int" />
					<param name="objects" comment="the array of objects to be reordered into visual order" fulltype="java.lang.Object[]" type="Object" />
					<param name="objectStart" comment="the start position in the objects array" fulltype="int" type="int" />
					<param name="count" comment="the number of objects to reorder" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="nativeGetDirectionCode" fulltype="int" type="int">
				<comment>
					<description>Access native bidi implementation.</description>
				</comment>
				<params>
					<param name="cp" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" synchronized="true" visibility="private" name="nativeBidiChars" fulltype="void" type="void">
				<comment>
					<description>Access native bidi implementation.</description>
				</comment>
				<params>
					<param name="bidi" fulltype="java.text.Bidi" type="Bidi" />
					<param name="text" fulltype="char[]" type="char" />
					<param name="textStart" fulltype="int" type="int" />
					<param name="embeddings" fulltype="byte[]" type="byte" />
					<param name="embeddingStart" fulltype="int" type="int" />
					<param name="length" fulltype="int" type="int" />
					<param name="flags" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="toString" fulltype="java.lang.String" type="String">
				<comment>
					<description>Display the bidi internal state, used in debugging.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="public" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.Normalizer" type="Normalizer">
		<comment>
			<description>This class provides the method &lt;code&gt;normalize&lt;/code&gt; which transforms Unicode
 text into an equivalent composed or decomposed form, allowing for easier
 sorting and searching of text.
 The &lt;code&gt;normalize&lt;/code&gt; method supports the standard normalization forms
 described in
 &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr15/tr15-23.html&quot;&gt;
 Unicode Standard Annex #15 &amp;mdash; Unicode Normalization Forms&lt;/a&gt;.
 &lt;p&gt;
 Characters with accents or other adornments can be encoded in
 several different ways in Unicode.  For example, take the character A-acute.
 In Unicode, this can be encoded as a single character (the &quot;composed&quot; form):

 &lt;p&gt;&lt;pre&gt;
      U+00C1    LATIN CAPITAL LETTER A WITH ACUTE&lt;/pre&gt;
 &lt;/p&gt;

 or as two separate characters (the &quot;decomposed&quot; form):

 &lt;p&gt;&lt;pre&gt;
      U+0041    LATIN CAPITAL LETTER A
      U+0301    COMBINING ACUTE ACCENT&lt;/pre&gt;
 &lt;/p&gt;

 To a user of your program, however, both of these sequences should be
 treated as the same &quot;user-level&quot; character &quot;A with acute accent&quot;.  When you
 are searching or comparing text, you must ensure that these two sequences are
 treated as equivalent.  In addition, you must handle characters with more than
 one accent. Sometimes the order of a character&apos;s combining accents is
 significant, while in other cases accent sequences in different orders are
 really equivalent.
 &lt;p&gt;
 Similarly, the string &quot;ffi&quot; can be encoded as three separate letters:

 &lt;p&gt;&lt;pre&gt;
      U+0066    LATIN SMALL LETTER F
      U+0066    LATIN SMALL LETTER F
      U+0069    LATIN SMALL LETTER I&lt;/pre&gt;
 &lt;/p&gt;

 or as the single character

 &lt;p&gt;&lt;pre&gt;
      U+FB03    LATIN SMALL LIGATURE FFI&lt;/pre&gt;
 &lt;/p&gt;

 The ffi ligature is not a distinct semantic character, and strictly speaking
 it shouldn&apos;t be in Unicode at all, but it was included for compatibility
 with existing character sets that already provided it.  The Unicode standard
 identifies such characters by giving them &quot;compatibility&quot; decompositions
 into the corresponding semantic characters.  When sorting and searching, you
 will often want to use these mappings.
 &lt;p&gt;
 The &lt;code&gt;normalize&lt;/code&gt; method helps solve these problems by transforming
 text into the canonical composed and decomposed forms as shown in the first
 example above. In addition, you can have it perform compatibility
 decompositions so that you can treat compatibility characters the same as
 their equivalents.
 Finally, the &lt;code&gt;normalize&lt;/code&gt; method rearranges accents into the
 proper canonical order, so that you do not have to worry about accent
 rearrangement on your own.
 &lt;p&gt;
 The W3C generally recommends to exchange texts in NFC.
 Note also that most legacy character encodings use only precomposed forms and
 often do not encode any combining marks by themselves. For conversion to such
 character encodings the Unicode text needs to be normalized to NFC.
 For more usage examples, see the Unicode Standard Annex.</description>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="private" name="Normalizer" />
			<method static="true" visibility="public" name="normalize" returncomment="The normalized String" fulltype="java.lang.String" type="String">
				<comment>
					<description>Normalize a sequence of char values.
 The sequence will be normalized according to the specified normalization
 from.</description>
					<attribute name="@param">
						<description>src        The sequence of char values to normalize.</description>
					</attribute>
					<attribute name="@param">
						<description>form       The normalization form; one of
                   {@link java.text.Normalizer.Form#NFC},
                   {@link java.text.Normalizer.Form#NFD},
                   {@link java.text.Normalizer.Form#NFKC},
                   {@link java.text.Normalizer.Form#NFKD}</description>
					</attribute>
					<attribute name="@return">
						<description>The normalized String</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException If &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;form&lt;/code&gt;
 is null.</description>
					</attribute>
				</comment>
				<params>
					<param name="src" comment="The sequence of char values to normalize." fulltype="java.lang.CharSequence" type="CharSequence" />
					<param name="form" comment="The normalization form; one of
                   {@link java.text.Normalizer.Form#NFC},
                   {@link java.text.Normalizer.Form#NFD},
                   {@link java.text.Normalizer.Form#NFKC},
                   {@link java.text.Normalizer.Form#NFKD}" fulltype="java.text.Normalizer.Form" type="Normalizer.Form" />
				</params>
			</method>
			<method static="true" visibility="public" name="isNormalized" returncomment="true if the sequence of char values is normalized;
 false otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Determines if the given sequence of char values is normalized.</description>
					<attribute name="@param">
						<description>src        The sequence of char values to be checked.</description>
					</attribute>
					<attribute name="@param">
						<description>form       The normalization form; one of
                   {@link java.text.Normalizer.Form#NFC},
                   {@link java.text.Normalizer.Form#NFD},
                   {@link java.text.Normalizer.Form#NFKC},
                   {@link java.text.Normalizer.Form#NFKD}</description>
					</attribute>
					<attribute name="@return">
						<description>true if the sequence of char values is normalized;
 false otherwise.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException If &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;form&lt;/code&gt;
 is null.</description>
					</attribute>
				</comment>
				<params>
					<param name="src" comment="The sequence of char values to be checked." fulltype="java.lang.CharSequence" type="CharSequence" />
					<param name="form" comment="The normalization form; one of
                   {@link java.text.Normalizer.Form#NFC},
                   {@link java.text.Normalizer.Form#NFD},
                   {@link java.text.Normalizer.Form#NFKC},
                   {@link java.text.Normalizer.Form#NFKD}" fulltype="java.text.Normalizer.Form" type="Normalizer.Form" />
				</params>
			</method>
		</methods>
		<jelclass final="true" superclass="Enum" visibility="public" package="java.text" serializable="true" superclassfulltype="java.lang.Enum" fulltype="java.text.Normalizer.Form" type="Normalizer.Form">
			<comment>
				<description>This enum provides constants of the four Unicode normalization forms
 that are described in
 &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr15/tr15-23.html&quot;&gt;
 Unicode Standard Annex #15 &amp;mdash; Unicode Normalization Forms&lt;/a&gt;
 and two methods to access them.</description>
				<attribute name="@since">
					<description>1.6</description>
				</attribute>
			</comment>
			<fields>
				<field final="true" static="true" visibility="public" name="NFD" fulltype="java.text.Normalizer.Form" type="Normalizer.Form">
					<comment>
						<description>Canonical decomposition.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="NFC" fulltype="java.text.Normalizer.Form" type="Normalizer.Form">
					<comment>
						<description>Canonical decomposition, followed by canonical composition.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="NFKD" fulltype="java.text.Normalizer.Form" type="Normalizer.Form">
					<comment>
						<description>Compatibility decomposition.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="NFKC" fulltype="java.text.Normalizer.Form" type="Normalizer.Form">
					<comment>
						<description>Compatibility decomposition, followed by canonical composition.</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="private" name="Normalizer.Form" />
				<method static="true" visibility="public" name="values" fulltype="java.text.Normalizer.Form[]" type="Normalizer.Form" />
				<method static="true" visibility="public" name="valueOf" fulltype="java.text.Normalizer.Form" type="Normalizer.Form">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass final="true" superclass="Enum" visibility="public" package="java.text" serializable="true" superclassfulltype="java.lang.Enum" fulltype="java.text.Normalizer.Form" type="Normalizer.Form">
		<comment>
			<description>This enum provides constants of the four Unicode normalization forms
 that are described in
 &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr15/tr15-23.html&quot;&gt;
 Unicode Standard Annex #15 &amp;mdash; Unicode Normalization Forms&lt;/a&gt;
 and two methods to access them.</description>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" visibility="public" name="NFD" fulltype="java.text.Normalizer.Form" type="Normalizer.Form">
				<comment>
					<description>Canonical decomposition.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="NFC" fulltype="java.text.Normalizer.Form" type="Normalizer.Form">
				<comment>
					<description>Canonical decomposition, followed by canonical composition.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="NFKD" fulltype="java.text.Normalizer.Form" type="Normalizer.Form">
				<comment>
					<description>Compatibility decomposition.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="NFKC" fulltype="java.text.Normalizer.Form" type="Normalizer.Form">
				<comment>
					<description>Compatibility decomposition, followed by canonical composition.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="private" name="Normalizer.Form" />
			<method static="true" visibility="public" name="values" fulltype="java.text.Normalizer.Form[]" type="Normalizer.Form" />
			<method static="true" visibility="public" name="valueOf" fulltype="java.text.Normalizer.Form" type="Normalizer.Form">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.Annotation" type="Annotation">
		<comment>
			<description>An Annotation object is used as a wrapper for a text attribute value if
 the attribute has annotation characteristics. These characteristics are:
 &lt;ul&gt;
 &lt;li&gt;The text range that the attribute is applied to is critical to the
 semantics of the range. That means, the attribute cannot be applied to subranges
 of the text range that it applies to, and, if two adjacent text ranges have
 the same value for this attribute, the attribute still cannot be applied to
 the combined range as a whole with this value.
 &lt;li&gt;The attribute or its value usually do no longer apply if the underlying text is
 changed.
 &lt;/ul&gt;

 An example is grammatical information attached to a sentence:
 For the previous sentence, you can say that &quot;an example&quot;
 is the subject, but you cannot say the same about &quot;an&quot;, &quot;example&quot;, or &quot;exam&quot;.
 When the text is changed, the grammatical information typically becomes invalid.
 Another example is Japanese reading information (yomi).

 &lt;p&gt;
 Wrapping the attribute value into an Annotation object guarantees that
 adjacent text runs don&apos;t get merged even if the attribute values are equal,
 and indicates to text containers that the attribute should be discarded if
 the underlying text is modified.</description>
			<attribute name="@see">
				<description>AttributedCharacterIterator</description>
			</attribute>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="value" fulltype="java.lang.Object" type="Object" />
		</fields>
		<methods>
			<constructor visibility="public" name="Annotation">
				<comment>
					<description>Constructs an annotation record with the given value, which
 may be null.</description>
					<attribute name="@param">
						<description>value The value of the attribute</description>
					</attribute>
				</comment>
				<params>
					<param name="value" comment="The value of the attribute" fulltype="java.lang.Object" type="Object" />
				</params>
			</constructor>
			<method visibility="public" name="getValue" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Returns the value of the attribute, which may be null.</description>
				</comment>
			</method>
			<method visibility="public" name="toString" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the String representation of this Annotation.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.CollationRules" type="CollationRules">
		<comment>
			<description>CollationRules contains the default en_US collation rules as a base
 for building other collation tables.
 &lt;p&gt;Note that decompositions are done before these rules are used,
 so they do not have to contain accented characters, such as A-grave.</description>
			<attribute name="@see">
				<description>RuleBasedCollator</description>
			</attribute>
			<attribute name="@see">
				<description>LocaleElements</description>
			</attribute>
			<attribute name="@author">
				<description>Helena Shih, Mark Davis</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" visibility="package-private" name="DEFAULTRULES" fulltype="java.lang.String" type="String" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="CollationRules" />
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.text" serializable="true" superclassfulltype="java.lang.Object" fulltype="java.text.Format" type="Format">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
			<interface fulltype="java.lang.Cloneable" type="Cloneable" />
		</implements>
		<comment>
			<description>&lt;code&gt;Format&lt;/code&gt; is an abstract base class for formatting locale-sensitive
 information such as dates, messages, and numbers.

 &lt;p&gt;
 &lt;code&gt;Format&lt;/code&gt; defines the programming interface for formatting
 locale-sensitive objects into &lt;code&gt;String&lt;/code&gt;s (the
 &lt;code&gt;format&lt;/code&gt; method) and for parsing &lt;code&gt;String&lt;/code&gt;s back
 into objects (the &lt;code&gt;parseObject&lt;/code&gt; method).

 &lt;p&gt;
 Generally, a format&apos;s &lt;code&gt;parseObject&lt;/code&gt; method must be able to parse
 any string formatted by its &lt;code&gt;format&lt;/code&gt; method. However, there may
 be exceptional cases where this is not possible. For example, a
 &lt;code&gt;format&lt;/code&gt; method might create two adjacent integer numbers with
 no separator in between, and in this case the &lt;code&gt;parseObject&lt;/code&gt; could
 not tell which digits belong to which number.

 &lt;h4&gt;Subclassing&lt;/h4&gt;

 &lt;p&gt;
 The Java Platform provides three specialized subclasses of &lt;code&gt;Format&lt;/code&gt;--
 &lt;code&gt;DateFormat&lt;/code&gt;, &lt;code&gt;MessageFormat&lt;/code&gt;, and
 &lt;code&gt;NumberFormat&lt;/code&gt;--for formatting dates, messages, and numbers,
 respectively.
 &lt;p&gt;
 Concrete subclasses must implement three methods:
 &lt;ol&gt;
 &lt;li&gt; &lt;code&gt;format(Object obj, StringBuffer toAppendTo, FieldPosition pos)&lt;/code&gt;
 &lt;li&gt; &lt;code&gt;formatToCharacterIterator(Object obj)&lt;/code&gt;
 &lt;li&gt; &lt;code&gt;parseObject(String source, ParsePosition pos)&lt;/code&gt;
 &lt;/ol&gt;
 These general methods allow polymorphic parsing and formatting of objects
 and are used, for example, by &lt;code&gt;MessageFormat&lt;/code&gt;.
 Subclasses often also provide additional &lt;code&gt;format&lt;/code&gt; methods for
 specific input types as well as &lt;code&gt;parse&lt;/code&gt; methods for specific
 result types. Any &lt;code&gt;parse&lt;/code&gt; method that does not take a
 &lt;code&gt;ParsePosition&lt;/code&gt; argument should throw &lt;code&gt;ParseException&lt;/code&gt;
 when no text in the required format is at the beginning of the input text.

 &lt;p&gt;
 Most subclasses will also implement the following factory methods:
 &lt;ol&gt;
 &lt;li&gt;
 &lt;code&gt;getInstance&lt;/code&gt; for getting a useful format object appropriate
 for the current locale
 &lt;li&gt;
 &lt;code&gt;getInstance(Locale)&lt;/code&gt; for getting a useful format
 object appropriate for the specified locale
 &lt;/ol&gt;
 In addition, some subclasses may also implement other
 &lt;code&gt;getXxxxInstance&lt;/code&gt; methods for more specialized control. For
 example, the &lt;code&gt;NumberFormat&lt;/code&gt; class provides
 &lt;code&gt;getPercentInstance&lt;/code&gt; and &lt;code&gt;getCurrencyInstance&lt;/code&gt;
 methods for getting specialized number formatters.

 &lt;p&gt;
 Subclasses of &lt;code&gt;Format&lt;/code&gt; that allow programmers to create objects
 for locales (with &lt;code&gt;getInstance(Locale)&lt;/code&gt; for example)
 must also implement the following class method:
 &lt;blockquote&gt;
 &lt;pre&gt;
 public static Locale[] getAvailableLocales()
 &lt;/pre&gt;
 &lt;/blockquote&gt;

 &lt;p&gt;
 And finally subclasses may define a set of constants to identify the various
 fields in the formatted output. These constants are used to create a FieldPosition
 object which identifies what information is contained in the field and its
 position in the formatted result. These constants should be named
 &lt;code&gt;&lt;em&gt;item&lt;/em&gt;_FIELD&lt;/code&gt; where &lt;code&gt;&lt;em&gt;item&lt;/em&gt;&lt;/code&gt; identifies
 the field. For examples of these constants, see &lt;code&gt;ERA_FIELD&lt;/code&gt; and its
 friends in {@link DateFormat}.

 &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;

 &lt;p&gt;
 Formats are generally not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently, it must be synchronized
 externally.</description>
			<attribute name="@see">
				<description>java.text.ParsePosition</description>
			</attribute>
			<attribute name="@see">
				<description>java.text.FieldPosition</description>
			</attribute>
			<attribute name="@see">
				<description>java.text.NumberFormat</description>
			</attribute>
			<attribute name="@see">
				<description>java.text.DateFormat</description>
			</attribute>
			<attribute name="@see">
				<description>java.text.MessageFormat</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Davis</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-299282585814624189" visibility="private" name="serialVersionUID" constexpr="-299282585814624189L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="protected" name="Format">
				<comment>
					<description>Sole constructor.  (For invocation by subclass constructors, typically
 implicit.)</description>
				</comment>
			</constructor>
			<method final="true" visibility="public" name="format" returncomment="Formatted string." fulltype="java.lang.String" type="String">
				<comment>
					<description>Formats an object to produce a string. This is equivalent to
 &lt;blockquote&gt;
 {@link #format(Object, StringBuffer, FieldPosition) format}&lt;code&gt;(obj,
         new StringBuffer(), new FieldPosition(0)).toString();&lt;/code&gt;
 &lt;/blockquote&gt;</description>
					<attribute name="@param">
						<description>obj    The object to format</description>
					</attribute>
					<attribute name="@return">
						<description>Formatted string.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the Format cannot format the given
            object</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="The object to format" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="format" returncomment="the string buffer passed in as &lt;code&gt;toAppendTo&lt;/code&gt;,
               with formatted text appended" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Formats an object and appends the resulting text to a given string
 buffer.
 If the &lt;code&gt;pos&lt;/code&gt; argument identifies a field used by the format,
 then its indices are set to the beginning and end of the first such
 field encountered.</description>
					<attribute name="@param">
						<description>obj    The object to format</description>
					</attribute>
					<attribute name="@param">
						<description>toAppendTo    where the text is to be appended</description>
					</attribute>
					<attribute name="@param">
						<description>pos    A &lt;code&gt;FieldPosition&lt;/code&gt; identifying a field
               in the formatted text</description>
					</attribute>
					<attribute name="@return">
						<description>the string buffer passed in as &lt;code&gt;toAppendTo&lt;/code&gt;,
               with formatted text appended</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or
            &lt;code&gt;pos&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the Format cannot format the given
            object</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="The object to format" fulltype="java.lang.Object" type="Object" />
					<param name="toAppendTo" comment="where the text is to be appended" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="pos" comment="A &lt;code&gt;FieldPosition&lt;/code&gt; identifying a field
               in the formatted text" fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method visibility="public" name="formatToCharacterIterator" returncomment="AttributedCharacterIterator describing the formatted value." fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
				<comment>
					<description>Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
 You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
 to build the resulting String, as well as to determine information
 about the resulting String.
 &lt;p&gt;
 Each attribute key of the AttributedCharacterIterator will be of type
 &lt;code&gt;Field&lt;/code&gt;. It is up to each &lt;code&gt;Format&lt;/code&gt; implementation
 to define what the legal values are for each attribute in the
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;, but typically the attribute
 key is also used as the attribute value.
 &lt;p&gt;The default implementation creates an
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with no attributes. Subclasses
 that support fields should override this and create an
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with meaningful attributes.</description>
					<attribute name="@exception">
						<description>NullPointerException if obj is null.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException when the Format cannot format the
            given object.</description>
					</attribute>
					<attribute name="@param">
						<description>obj The object to format</description>
					</attribute>
					<attribute name="@return">
						<description>AttributedCharacterIterator describing the formatted value.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="The object to format" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="parseObject" returncomment="An &lt;code&gt;Object&lt;/code&gt; parsed from the string. In case of
         error, returns null." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Parses text from a string to produce an object.
 &lt;p&gt;
 The method attempts to parse text starting at the index given by
 &lt;code&gt;pos&lt;/code&gt;.
 If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
 to the index after the last character used (parsing does not necessarily
 use all characters up to the end of the string), and the parsed
 object is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
 indicate the starting point for the next call to this method.
 If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
 changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
 the character where the error occurred, and null is returned.</description>
					<attribute name="@param">
						<description>source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</description>
					</attribute>
					<attribute name="@param">
						<description>pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
            index information as described above.</description>
					</attribute>
					<attribute name="@return">
						<description>An &lt;code&gt;Object&lt;/code&gt; parsed from the string. In case of
         error, returns null.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;pos&lt;/code&gt; is null.</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed." fulltype="java.lang.String" type="String" />
					<param name="pos" comment="A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
            index information as described above." fulltype="java.text.ParsePosition" type="ParsePosition" />
				</params>
			</method>
			<method visibility="public" name="parseObject" returncomment="An &lt;code&gt;Object&lt;/code&gt; parsed from the string." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Parses text from the beginning of the given string to produce an object.
 The method may not use the entire text of the given string.</description>
					<attribute name="@param">
						<description>source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</description>
					</attribute>
					<attribute name="@return">
						<description>An &lt;code&gt;Object&lt;/code&gt; parsed from the string.</description>
					</attribute>
					<attribute name="@exception">
						<description>ParseException if the beginning of the specified string
            cannot be parsed.</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if the beginning of the specified string
            cannot be parsed." fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
			<method visibility="public" name="clone" returncomment="a clone of this instance." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Creates and returns a copy of this object.</description>
					<attribute name="@return">
						<description>a clone of this instance.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="package-private" name="createAttributedCharacterIterator" returncomment="AttributedCharacterIterator wrapping s" fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
				<comment>
					<description>Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; for the String
 &lt;code&gt;s&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>s String to create AttributedCharacterIterator from</description>
					</attribute>
					<attribute name="@return">
						<description>AttributedCharacterIterator wrapping s</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="String to create AttributedCharacterIterator from" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="package-private" name="createAttributedCharacterIterator" returncomment="AttributedCharacterIterator wrapping passed in
         AttributedCharacterIterators" fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
				<comment>
					<description>Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; containg the
 concatenated contents of the passed in
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;s.</description>
					<attribute name="@param">
						<description>iterators AttributedCharacterIterators used to create resulting
                  AttributedCharacterIterators</description>
					</attribute>
					<attribute name="@return">
						<description>AttributedCharacterIterator wrapping passed in
         AttributedCharacterIterators</description>
					</attribute>
				</comment>
				<params>
					<param name="iterators" comment="AttributedCharacterIterators used to create resulting
                  AttributedCharacterIterators" fulltype="java.text.AttributedCharacterIterator[]" type="AttributedCharacterIterator" />
				</params>
			</method>
			<method visibility="package-private" name="createAttributedCharacterIterator" returncomment="AttributedCharacterIterator wrapping args" fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
				<comment>
					<description>Returns an AttributedCharacterIterator with the String
 &lt;code&gt;string&lt;/code&gt; and additional key/value pair &lt;code&gt;key&lt;/code&gt;,
 &lt;code&gt;value&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>string String to create AttributedCharacterIterator from</description>
					</attribute>
					<attribute name="@param">
						<description>key Key for AttributedCharacterIterator</description>
					</attribute>
					<attribute name="@param">
						<description>value Value associated with key in AttributedCharacterIterator</description>
					</attribute>
					<attribute name="@return">
						<description>AttributedCharacterIterator wrapping args</description>
					</attribute>
				</comment>
				<params>
					<param name="string" comment="String to create AttributedCharacterIterator from" fulltype="java.lang.String" type="String" />
					<param name="key" comment="Key for AttributedCharacterIterator" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
					<param name="value" comment="Value associated with key in AttributedCharacterIterator" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="package-private" name="createAttributedCharacterIterator" returncomment="AttributedCharacterIterator wrapping args" fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
				<comment>
					<description>Creates an AttributedCharacterIterator with the contents of
 &lt;code&gt;iterator&lt;/code&gt; and the additional attribute &lt;code&gt;key&lt;/code&gt;
 &lt;code&gt;value&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>iterator Initial AttributedCharacterIterator to add arg to</description>
					</attribute>
					<attribute name="@param">
						<description>key Key for AttributedCharacterIterator</description>
					</attribute>
					<attribute name="@param">
						<description>value Value associated with key in AttributedCharacterIterator</description>
					</attribute>
					<attribute name="@return">
						<description>AttributedCharacterIterator wrapping args</description>
					</attribute>
				</comment>
				<params>
					<param name="iterator" comment="Initial AttributedCharacterIterator to add arg to" fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator" />
					<param name="key" comment="Key for AttributedCharacterIterator" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
					<param name="value" comment="Value associated with key in AttributedCharacterIterator" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
		</methods>
		<jelclass superclass="AttributedCharacterIterator.Attribute" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.AttributedCharacterIterator.Attribute" fulltype="java.text.Format.Field" type="Format.Field">
			<comment>
				<description>Defines constants that are used as attribute keys in the
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
 from &lt;code&gt;Format.formatToCharacterIterator&lt;/code&gt; and as
 field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.</description>
				<attribute name="@since">
					<description>1.4</description>
				</attribute>
			</comment>
			<fields>
				<field final="true" static="true" const="276966692217360283" visibility="private" name="serialVersionUID" constexpr="276966692217360283L" fulltype="long" type="long" />
			</fields>
			<methods>
				<constructor visibility="protected" name="Format.Field">
					<comment>
						<description>Creates a Field with the specified name.</description>
						<attribute name="@param">
							<description>name Name of the attribute</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="Name of the attribute" fulltype="java.lang.String" type="String" />
					</params>
				</constructor>
			</methods>
		</jelclass>
		<jelclass abstract="true" visibility="package-private" package="java.text" interface="true" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate">
			<comment>
				<description>FieldDelegate is notified by the various &lt;code&gt;Format&lt;/code&gt;
 implementations as they are formatting the Objects. This allows for
 storage of the individual sections of the formatted String for
 later use, such as in a &lt;code&gt;FieldPosition&lt;/code&gt; or for an
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
 &lt;p&gt;
 Delegates should NOT assume that the &lt;code&gt;Format&lt;/code&gt; will notify
 the delegate of fields in any particular order.</description>
				<attribute name="@see">
					<description>FieldPosition.Delegate</description>
				</attribute>
				<attribute name="@see">
					<description>CharacterIteratorFieldDelegate</description>
				</attribute>
			</comment>
			<methods>
				<method visibility="public" name="formatted" fulltype="void" type="void">
					<comment>
						<description>Notified when a particular region of the String is formatted. This
 method will be invoked if there is no corresponding integer field id
 matching &lt;code&gt;attr&lt;/code&gt;.</description>
						<attribute name="@param">
							<description>attr Identifies the field matched</description>
						</attribute>
						<attribute name="@param">
							<description>value Value associated with the field</description>
						</attribute>
						<attribute name="@param">
							<description>start Beginning location of the field, will be &gt;= 0</description>
						</attribute>
						<attribute name="@param">
							<description>end End of the field, will be &gt;= start and &lt;= buffer.length()</description>
						</attribute>
						<attribute name="@param">
							<description>buffer Contains current formatted value, receiver should
        NOT modify it.</description>
						</attribute>
					</comment>
					<params>
						<param name="attr" comment="Identifies the field matched" fulltype="java.text.Format.Field" type="Format.Field" />
						<param name="value" comment="Value associated with the field" fulltype="java.lang.Object" type="Object" />
						<param name="start" comment="Beginning location of the field, will be &gt;= 0" fulltype="int" type="int" />
						<param name="end" comment="End of the field, will be &gt;= start and &lt;= buffer.length()" fulltype="int" type="int" />
						<param name="buffer" comment="Contains current formatted value, receiver should
        NOT modify it." fulltype="java.lang.StringBuffer" type="StringBuffer" />
					</params>
				</method>
				<method visibility="public" name="formatted" fulltype="void" type="void">
					<comment>
						<description>Notified when a particular region of the String is formatted.</description>
						<attribute name="@param">
							<description>fieldID Identifies the field by integer</description>
						</attribute>
						<attribute name="@param">
							<description>attr Identifies the field matched</description>
						</attribute>
						<attribute name="@param">
							<description>value Value associated with the field</description>
						</attribute>
						<attribute name="@param">
							<description>start Beginning location of the field, will be &gt;= 0</description>
						</attribute>
						<attribute name="@param">
							<description>end End of the field, will be &gt;= start and &lt;= buffer.length()</description>
						</attribute>
						<attribute name="@param">
							<description>buffer Contains current formatted value, receiver should
        NOT modify it.</description>
						</attribute>
					</comment>
					<params>
						<param name="fieldID" comment="Identifies the field by integer" fulltype="int" type="int" />
						<param name="attr" comment="Identifies the field matched" fulltype="java.text.Format.Field" type="Format.Field" />
						<param name="value" comment="Value associated with the field" fulltype="java.lang.Object" type="Object" />
						<param name="start" comment="Beginning location of the field, will be &gt;= 0" fulltype="int" type="int" />
						<param name="end" comment="End of the field, will be &gt;= start and &lt;= buffer.length()" fulltype="int" type="int" />
						<param name="buffer" comment="Contains current formatted value, receiver should
        NOT modify it." fulltype="java.lang.StringBuffer" type="StringBuffer" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="AttributedCharacterIterator.Attribute" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.AttributedCharacterIterator.Attribute" fulltype="java.text.Format.Field" type="Format.Field">
		<comment>
			<description>Defines constants that are used as attribute keys in the
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
 from &lt;code&gt;Format.formatToCharacterIterator&lt;/code&gt; and as
 field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.</description>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="276966692217360283" visibility="private" name="serialVersionUID" constexpr="276966692217360283L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="protected" name="Format.Field">
				<comment>
					<description>Creates a Field with the specified name.</description>
					<attribute name="@param">
						<description>name Name of the attribute</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="Name of the attribute" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="package-private" package="java.text" interface="true" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate">
		<comment>
			<description>FieldDelegate is notified by the various &lt;code&gt;Format&lt;/code&gt;
 implementations as they are formatting the Objects. This allows for
 storage of the individual sections of the formatted String for
 later use, such as in a &lt;code&gt;FieldPosition&lt;/code&gt; or for an
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
 &lt;p&gt;
 Delegates should NOT assume that the &lt;code&gt;Format&lt;/code&gt; will notify
 the delegate of fields in any particular order.</description>
			<attribute name="@see">
				<description>FieldPosition.Delegate</description>
			</attribute>
			<attribute name="@see">
				<description>CharacterIteratorFieldDelegate</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="formatted" fulltype="void" type="void">
				<comment>
					<description>Notified when a particular region of the String is formatted. This
 method will be invoked if there is no corresponding integer field id
 matching &lt;code&gt;attr&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>attr Identifies the field matched</description>
					</attribute>
					<attribute name="@param">
						<description>value Value associated with the field</description>
					</attribute>
					<attribute name="@param">
						<description>start Beginning location of the field, will be &gt;= 0</description>
					</attribute>
					<attribute name="@param">
						<description>end End of the field, will be &gt;= start and &lt;= buffer.length()</description>
					</attribute>
					<attribute name="@param">
						<description>buffer Contains current formatted value, receiver should
        NOT modify it.</description>
					</attribute>
				</comment>
				<params>
					<param name="attr" comment="Identifies the field matched" fulltype="java.text.Format.Field" type="Format.Field" />
					<param name="value" comment="Value associated with the field" fulltype="java.lang.Object" type="Object" />
					<param name="start" comment="Beginning location of the field, will be &gt;= 0" fulltype="int" type="int" />
					<param name="end" comment="End of the field, will be &gt;= start and &lt;= buffer.length()" fulltype="int" type="int" />
					<param name="buffer" comment="Contains current formatted value, receiver should
        NOT modify it." fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
			<method visibility="public" name="formatted" fulltype="void" type="void">
				<comment>
					<description>Notified when a particular region of the String is formatted.</description>
					<attribute name="@param">
						<description>fieldID Identifies the field by integer</description>
					</attribute>
					<attribute name="@param">
						<description>attr Identifies the field matched</description>
					</attribute>
					<attribute name="@param">
						<description>value Value associated with the field</description>
					</attribute>
					<attribute name="@param">
						<description>start Beginning location of the field, will be &gt;= 0</description>
					</attribute>
					<attribute name="@param">
						<description>end End of the field, will be &gt;= start and &lt;= buffer.length()</description>
					</attribute>
					<attribute name="@param">
						<description>buffer Contains current formatted value, receiver should
        NOT modify it.</description>
					</attribute>
				</comment>
				<params>
					<param name="fieldID" comment="Identifies the field by integer" fulltype="int" type="int" />
					<param name="attr" comment="Identifies the field matched" fulltype="java.text.Format.Field" type="Format.Field" />
					<param name="value" comment="Value associated with the field" fulltype="java.lang.Object" type="Object" />
					<param name="start" comment="Beginning location of the field, will be &gt;= 0" fulltype="int" type="int" />
					<param name="end" comment="End of the field, will be &gt;= start and &lt;= buffer.length()" fulltype="int" type="int" />
					<param name="buffer" comment="Contains current formatted value, receiver should
        NOT modify it." fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.FieldPosition" type="FieldPosition">
		<comment>
			<description>&lt;code&gt;FieldPosition&lt;/code&gt; is a simple class used by &lt;code&gt;Format&lt;/code&gt;
 and its subclasses to identify fields in formatted output. Fields can
 be identified in two ways:
 &lt;ul&gt;
  &lt;li&gt;By an integer constant, whose names typically end with
      &lt;code&gt;_FIELD&lt;/code&gt;. The constants are defined in the various
      subclasses of &lt;code&gt;Format&lt;/code&gt;.
  &lt;li&gt;By a &lt;code&gt;Format.Field&lt;/code&gt; constant, see &lt;code&gt;ERA_FIELD&lt;/code&gt;
      and its friends in &lt;code&gt;DateFormat&lt;/code&gt; for an example.
 &lt;/ul&gt;
 &lt;p&gt;
 &lt;code&gt;FieldPosition&lt;/code&gt; keeps track of the position of the
 field within the formatted output with two indices: the index
 of the first character of the field and the index of the last
 character of the field.

 &lt;p&gt;
 One version of the &lt;code&gt;format&lt;/code&gt; method in the various
 &lt;code&gt;Format&lt;/code&gt; classes requires a &lt;code&gt;FieldPosition&lt;/code&gt;
 object as an argument. You use this &lt;code&gt;format&lt;/code&gt; method
 to perform partial formatting or to get information about the
 formatted output (such as the position of a field).

 &lt;p&gt;
 If you are interested in the positions of all attributes in the
 formatted string use the &lt;code&gt;Format&lt;/code&gt; method
 &lt;code&gt;formatToCharacterIterator&lt;/code&gt;.</description>
			<attribute name="@author">
				<description>Mark Davis</description>
			</attribute>
			<attribute name="@see">
				<description>java.text.Format</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="field" fulltype="int" type="int">
				<comment>
					<description>Input: Desired field to determine start and end offsets for.
 The meaning depends on the subclass of Format.</description>
				</comment>
			</field>
			<field visibility="package-private" name="endIndex" fulltype="int" type="int">
				<comment>
					<description>Output: End offset of field in text.
 If the field does not occur in the text, 0 is returned.</description>
				</comment>
			</field>
			<field visibility="package-private" name="beginIndex" fulltype="int" type="int">
				<comment>
					<description>Output: Start offset of field in text.
 If the field does not occur in the text, 0 is returned.</description>
				</comment>
			</field>
			<field visibility="private" name="attribute" fulltype="java.text.Format.Field" type="Format.Field">
				<comment>
					<description>Desired field this FieldPosition is for.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="FieldPosition">
				<comment>
					<description>Creates a FieldPosition object for the given field.  Fields are
 identified by constants, whose names typically end with _FIELD,
 in the various subclasses of Format.</description>
					<attribute name="@see">
						<description>java.text.NumberFormat#INTEGER_FIELD</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.NumberFormat#FRACTION_FIELD</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DateFormat#YEAR_FIELD</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.DateFormat#MONTH_FIELD</description>
					</attribute>
				</comment>
				<params>
					<param name="field" fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="FieldPosition">
				<comment>
					<description>Creates a FieldPosition object for the given field constant. Fields are
 identified by constants defined in the various &lt;code&gt;Format&lt;/code&gt;
 subclasses. This is equivalent to calling
 &lt;code&gt;new FieldPosition(attribute, -1)&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>attribute Format.Field constant identifying a field</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="attribute" comment="Format.Field constant identifying a field" fulltype="java.text.Format.Field" type="Format.Field" />
				</params>
			</constructor>
			<constructor visibility="public" name="FieldPosition">
				<comment>
					<description>Creates a &lt;code&gt;FieldPosition&lt;/code&gt; object for the given field.
 The field is identified by an attribute constant from one of the
 &lt;code&gt;Field&lt;/code&gt; subclasses as well as an integer field ID
 defined by the &lt;code&gt;Format&lt;/code&gt; subclasses. &lt;code&gt;Format&lt;/code&gt;
 subclasses that are aware of &lt;code&gt;Field&lt;/code&gt; should give precedence
 to &lt;code&gt;attribute&lt;/code&gt; and ignore &lt;code&gt;fieldID&lt;/code&gt; if
 &lt;code&gt;attribute&lt;/code&gt; is not null. However, older &lt;code&gt;Format&lt;/code&gt;
 subclasses may not be aware of &lt;code&gt;Field&lt;/code&gt; and rely on
 &lt;code&gt;fieldID&lt;/code&gt;. If the field has no corresponding integer
 constant, &lt;code&gt;fieldID&lt;/code&gt; should be -1.</description>
					<attribute name="@param">
						<description>attribute Format.Field constant identifying a field</description>
					</attribute>
					<attribute name="@param">
						<description>fieldID integer constantce identifying a field</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="attribute" comment="Format.Field constant identifying a field" fulltype="java.text.Format.Field" type="Format.Field" />
					<param name="fieldID" comment="integer constantce identifying a field" fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="public" name="getFieldAttribute" returncomment="Identifier for the field" fulltype="java.text.Format.Field" type="Format.Field">
				<comment>
					<description>Returns the field identifier as an attribute constant
 from one of the &lt;code&gt;Field&lt;/code&gt; subclasses. May return null if
 the field is specified only by an integer field ID.</description>
					<attribute name="@return">
						<description>Identifier for the field</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getField" fulltype="int" type="int">
				<comment>
					<description>Retrieves the field identifier.</description>
				</comment>
			</method>
			<method visibility="public" name="getBeginIndex" fulltype="int" type="int">
				<comment>
					<description>Retrieves the index of the first character in the requested field.</description>
				</comment>
			</method>
			<method visibility="public" name="getEndIndex" fulltype="int" type="int">
				<comment>
					<description>Retrieves the index of the character following the last character in the
 requested field.</description>
				</comment>
			</method>
			<method visibility="public" name="setBeginIndex" fulltype="void" type="void">
				<comment>
					<description>Sets the begin index.  For use by subclasses of Format.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="bi" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="setEndIndex" fulltype="void" type="void">
				<comment>
					<description>Sets the end index.  For use by subclasses of Format.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="ei" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="package-private" name="getFieldDelegate" fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate">
				<comment>
					<description>Returns a &lt;code&gt;Format.FieldDelegate&lt;/code&gt; instance that is associated
 with the FieldPosition. When the delegate is notified of the same
 field the FieldPosition is associated with, the begin/end will be
 adjusted.</description>
				</comment>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Overrides equals</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" returncomment="a hash code value for this object" fulltype="int" type="int">
				<comment>
					<description>Returns a hash code for this FieldPosition.</description>
					<attribute name="@return">
						<description>a hash code value for this object</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toString" returncomment="a string representation of this object" fulltype="java.lang.String" type="String">
				<comment>
					<description>Return a string representation of this FieldPosition.</description>
					<attribute name="@return">
						<description>a string representation of this object</description>
					</attribute>
				</comment>
			</method>
			<method visibility="private" name="matchesField" fulltype="boolean" type="boolean">
				<comment>
					<description>Return true if the receiver wants a &lt;code&gt;Format.Field&lt;/code&gt; value and
 &lt;code&gt;attribute&lt;/code&gt; is equal to it.</description>
				</comment>
				<params>
					<param name="attribute" fulltype="java.text.Format.Field" type="Format.Field" />
				</params>
			</method>
			<method visibility="private" name="matchesField" fulltype="boolean" type="boolean">
				<comment>
					<description>Return true if the receiver wants a &lt;code&gt;Format.Field&lt;/code&gt; value and
 &lt;code&gt;attribute&lt;/code&gt; is equal to it, or true if the receiver
 represents an inteter constant and &lt;code&gt;field&lt;/code&gt; equals it.</description>
				</comment>
				<params>
					<param name="attribute" fulltype="java.text.Format.Field" type="Format.Field" />
					<param name="field" fulltype="int" type="int" />
				</params>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.FieldPosition.Delegate" type="FieldPosition.Delegate">
			<implements>
				<interface fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
			</implements>
			<comment>
				<description>An implementation of FieldDelegate that will adjust the begin/end
 of the FieldPosition if the arguments match the field of
 the FieldPosition.</description>
			</comment>
			<fields>
				<field visibility="private" name="encounteredField" fulltype="boolean" type="boolean">
					<comment>
						<description>Indicates whether the field has been  encountered before. If this
 is true, and &lt;code&gt;formatted&lt;/code&gt; is invoked, the begin/end
 are not updated.</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="private" name="FieldPosition.Delegate" />
				<method visibility="public" name="formatted" fulltype="void" type="void">
					<params>
						<param name="attr" fulltype="java.text.Format.Field" type="Format.Field" />
						<param name="value" fulltype="java.lang.Object" type="Object" />
						<param name="start" fulltype="int" type="int" />
						<param name="end" fulltype="int" type="int" />
						<param name="buffer" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					</params>
				</method>
				<method visibility="public" name="formatted" fulltype="void" type="void">
					<params>
						<param name="fieldID" fulltype="int" type="int" />
						<param name="attr" fulltype="java.text.Format.Field" type="Format.Field" />
						<param name="value" fulltype="java.lang.Object" type="Object" />
						<param name="start" fulltype="int" type="int" />
						<param name="end" fulltype="int" type="int" />
						<param name="buffer" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.FieldPosition.Delegate" type="FieldPosition.Delegate">
		<implements>
			<interface fulltype="java.text.Format.FieldDelegate" type="Format.FieldDelegate" />
		</implements>
		<comment>
			<description>An implementation of FieldDelegate that will adjust the begin/end
 of the FieldPosition if the arguments match the field of
 the FieldPosition.</description>
		</comment>
		<fields>
			<field visibility="private" name="encounteredField" fulltype="boolean" type="boolean">
				<comment>
					<description>Indicates whether the field has been  encountered before. If this
 is true, and &lt;code&gt;formatted&lt;/code&gt; is invoked, the begin/end
 are not updated.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="private" name="FieldPosition.Delegate" />
			<method visibility="public" name="formatted" fulltype="void" type="void">
				<params>
					<param name="attr" fulltype="java.text.Format.Field" type="Format.Field" />
					<param name="value" fulltype="java.lang.Object" type="Object" />
					<param name="start" fulltype="int" type="int" />
					<param name="end" fulltype="int" type="int" />
					<param name="buffer" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
			<method visibility="public" name="formatted" fulltype="void" type="void">
				<params>
					<param name="fieldID" fulltype="int" type="int" />
					<param name="attr" fulltype="java.text.Format.Field" type="Format.Field" />
					<param name="value" fulltype="java.lang.Object" type="Object" />
					<param name="start" fulltype="int" type="int" />
					<param name="end" fulltype="int" type="int" />
					<param name="buffer" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Collator" visibility="public" package="java.text" superclassfulltype="java.text.Collator" fulltype="java.text.RuleBasedCollator" type="RuleBasedCollator">
		<comment>
			<description>The &lt;code&gt;RuleBasedCollator&lt;/code&gt; class is a concrete subclass of
 &lt;code&gt;Collator&lt;/code&gt; that provides a simple, data-driven, table
 collator.  With this class you can create a customized table-based
 &lt;code&gt;Collator&lt;/code&gt;.  &lt;code&gt;RuleBasedCollator&lt;/code&gt; maps
 characters to sort keys.

 &lt;p&gt;
 &lt;code&gt;RuleBasedCollator&lt;/code&gt; has the following restrictions
 for efficiency (other subclasses may be used for more complex languages) :
 &lt;ol&gt;
 &lt;li&gt;If a special collation rule controlled by a &amp;lt;modifier&amp;gt; is
      specified it applies to the whole collator object.
 &lt;li&gt;All non-mentioned characters are at the end of the
     collation order.
 &lt;/ol&gt;

 &lt;p&gt;
 The collation table is composed of a list of collation rules, where each
 rule is of one of three forms:
 &lt;pre&gt;
    &amp;lt;modifier&amp;gt;
    &amp;lt;relation&amp;gt; &amp;lt;text-argument&amp;gt;
    &amp;lt;reset&amp;gt; &amp;lt;text-argument&amp;gt;
 &lt;/pre&gt;
 The definitions of the rule elements is as follows:
 &lt;UL Type=disc&gt;
    &lt;LI&gt;&lt;strong&gt;Text-Argument&lt;/strong&gt;: A text-argument is any sequence of
        characters, excluding special characters (that is, common
        whitespace characters [0009-000D, 0020] and rule syntax characters
        [0021-002F, 003A-0040, 005B-0060, 007B-007E]). If those
        characters are desired, you can put them in single quotes
        (e.g. ampersand =&gt; &apos;&amp;&apos;). Note that unquoted white space characters
        are ignored; e.g. &lt;code&gt;b c&lt;/code&gt; is treated as &lt;code&gt;bc&lt;/code&gt;.
    &lt;LI&gt;&lt;strong&gt;Modifier&lt;/strong&gt;: There are currently two modifiers that
        turn on special collation rules.
        &lt;UL Type=square&gt;
            &lt;LI&gt;&apos;@&apos; : Turns on backwards sorting of accents (secondary
                      differences), as in French.
            &lt;LI&gt;&apos;!&apos; : Turns on Thai/Lao vowel-consonant swapping.  If this
                      rule is in force when a Thai vowel of the range
                      &amp;#92;U0E40-&amp;#92;U0E44 precedes a Thai consonant of the range
                      &amp;#92;U0E01-&amp;#92;U0E2E OR a Lao vowel of the range &amp;#92;U0EC0-&amp;#92;U0EC4
                      precedes a Lao consonant of the range &amp;#92;U0E81-&amp;#92;U0EAE then
                      the vowel is placed after the consonant for collation
                      purposes.
        &lt;/UL&gt;
        &lt;p&gt;&apos;@&apos; : Indicates that accents are sorted backwards, as in French.
    &lt;LI&gt;&lt;strong&gt;Relation&lt;/strong&gt;: The relations are the following:
        &lt;UL Type=square&gt;
            &lt;LI&gt;&apos;&amp;lt;&apos; : Greater, as a letter difference (primary)
            &lt;LI&gt;&apos;;&apos; : Greater, as an accent difference (secondary)
            &lt;LI&gt;&apos;,&apos; : Greater, as a case difference (tertiary)
            &lt;LI&gt;&apos;=&apos; : Equal
        &lt;/UL&gt;
    &lt;LI&gt;&lt;strong&gt;Reset&lt;/strong&gt;: There is a single reset
        which is used primarily for contractions and expansions, but which
        can also be used to add a modification at the end of a set of rules.
        &lt;p&gt;&apos;&amp;&apos; : Indicates that the next rule follows the position to where
            the reset text-argument would be sorted.
 &lt;/UL&gt;

 &lt;p&gt;
 This sounds more complicated than it is in practice. For example, the
 following are equivalent ways of expressing the same thing:
 &lt;blockquote&gt;
 &lt;pre&gt;
 a &amp;lt; b &amp;lt; c
 a &amp;lt; b &amp;amp; b &amp;lt; c
 a &amp;lt; c &amp;amp; a &amp;lt; b
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 Notice that the order is important, as the subsequent item goes immediately
 after the text-argument. The following are not equivalent:
 &lt;blockquote&gt;
 &lt;pre&gt;
 a &amp;lt; b &amp;amp; a &amp;lt; c
 a &amp;lt; c &amp;amp; a &amp;lt; b
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 Either the text-argument must already be present in the sequence, or some
 initial substring of the text-argument must be present. (e.g. &quot;a &amp;lt; b &amp;amp; ae &amp;lt;
 e&quot; is valid since &quot;a&quot; is present in the sequence before &quot;ae&quot; is reset). In
 this latter case, &quot;ae&quot; is not entered and treated as a single character;
 instead, &quot;e&quot; is sorted as if it were expanded to two characters: &quot;a&quot;
 followed by an &quot;e&quot;. This difference appears in natural languages: in
 traditional Spanish &quot;ch&quot; is treated as though it contracts to a single
 character (expressed as &quot;c &amp;lt; ch &amp;lt; d&quot;), while in traditional German
 a-umlaut is treated as though it expanded to two characters
 (expressed as &quot;a,A &amp;lt; b,B ... &amp;amp;ae;&amp;#92;u00e3&amp;amp;AE;&amp;#92;u00c3&quot;).
 [&amp;#92;u00e3 and &amp;#92;u00c3 are, of course, the escape sequences for a-umlaut.]
 &lt;p&gt;
 &lt;strong&gt;Ignorable Characters&lt;/strong&gt;
 &lt;p&gt;
 For ignorable characters, the first rule must start with a relation (the
 examples we have used above are really fragments; &quot;a &amp;lt; b&quot; really should be
 &quot;&amp;lt; a &amp;lt; b&quot;). If, however, the first relation is not &quot;&amp;lt;&quot;, then all the all
 text-arguments up to the first &quot;&amp;lt;&quot; are ignorable. For example, &quot;, - &amp;lt; a &amp;lt; b&quot;
 makes &quot;-&quot; an ignorable character, as we saw earlier in the word
 &quot;black-birds&quot;. In the samples for different languages, you see that most
 accents are ignorable.

 &lt;p&gt;&lt;strong&gt;Normalization and Accents&lt;/strong&gt;
 &lt;p&gt;
 &lt;code&gt;RuleBasedCollator&lt;/code&gt; automatically processes its rule table to
 include both pre-composed and combining-character versions of
 accented characters.  Even if the provided rule string contains only
 base characters and separate combining accent characters, the pre-composed
 accented characters matching all canonical combinations of characters from
 the rule string will be entered in the table.
 &lt;p&gt;
 This allows you to use a RuleBasedCollator to compare accented strings
 even when the collator is set to NO_DECOMPOSITION.  There are two caveats,
 however.  First, if the strings to be collated contain combining
 sequences that may not be in canonical order, you should set the collator to
 CANONICAL_DECOMPOSITION or FULL_DECOMPOSITION to enable sorting of
 combining sequences.  Second, if the strings contain characters with
 compatibility decompositions (such as full-width and half-width forms),
 you must use FULL_DECOMPOSITION, since the rule tables only include
 canonical mappings.

 &lt;p&gt;&lt;strong&gt;Errors&lt;/strong&gt;
 &lt;p&gt;
 The following are errors:
 &lt;UL Type=disc&gt;
     &lt;LI&gt;A text-argument contains unquoted punctuation symbols
        (e.g. &quot;a &amp;lt; b-c &amp;lt; d&quot;).
     &lt;LI&gt;A relation or reset character not followed by a text-argument
        (e.g. &quot;a &amp;lt; ,b&quot;).
     &lt;LI&gt;A reset where the text-argument (or an initial substring of the
         text-argument) is not already in the sequence.
         (e.g. &quot;a &amp;lt; b &amp;amp; e &amp;lt; f&quot;)
 &lt;/UL&gt;
 If you produce one of these errors, a &lt;code&gt;RuleBasedCollator&lt;/code&gt; throws
 a &lt;code&gt;ParseException&lt;/code&gt;.

 &lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;
 &lt;p&gt;Simple:     &quot;&amp;lt; a &amp;lt; b &amp;lt; c &amp;lt; d&quot;
 &lt;p&gt;Norwegian:  &quot;&amp;lt; a,A&amp;lt; b,B&amp;lt; c,C&amp;lt; d,D&amp;lt; e,E&amp;lt; f,F&amp;lt; g,G&amp;lt; h,H&amp;lt; i,I&amp;lt; j,J
                 &amp;lt; k,K&amp;lt; l,L&amp;lt; m,M&amp;lt; n,N&amp;lt; o,O&amp;lt; p,P&amp;lt; q,Q&amp;lt; r,R&amp;lt; s,S&amp;lt; t,T
                 &amp;lt; u,U&amp;lt; v,V&amp;lt; w,W&amp;lt; x,X&amp;lt; y,Y&amp;lt; z,Z
                 &amp;lt; &amp;#92;u00E5=a&amp;#92;u030A,&amp;#92;u00C5=A&amp;#92;u030A
                 ;aa,AA&amp;lt; &amp;#92;u00E6,&amp;#92;u00C6&amp;lt; &amp;#92;u00F8,&amp;#92;u00D8&quot;

 &lt;p&gt;
 To create a &lt;code&gt;RuleBasedCollator&lt;/code&gt; object with specialized
 rules tailored to your needs, you construct the &lt;code&gt;RuleBasedCollator&lt;/code&gt;
 with the rules contained in a &lt;code&gt;String&lt;/code&gt; object. For example:
 &lt;blockquote&gt;
 &lt;pre&gt;
 String simple = &quot;&amp;lt; a&amp;lt; b&amp;lt; c&amp;lt; d&quot;;
 RuleBasedCollator mySimple = new RuleBasedCollator(simple);
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 Or:
 &lt;blockquote&gt;
 &lt;pre&gt;
 String Norwegian = &quot;&amp;lt; a,A&amp;lt; b,B&amp;lt; c,C&amp;lt; d,D&amp;lt; e,E&amp;lt; f,F&amp;lt; g,G&amp;lt; h,H&amp;lt; i,I&amp;lt; j,J&quot; +
                 &quot;&amp;lt; k,K&amp;lt; l,L&amp;lt; m,M&amp;lt; n,N&amp;lt; o,O&amp;lt; p,P&amp;lt; q,Q&amp;lt; r,R&amp;lt; s,S&amp;lt; t,T&quot; +
                 &quot;&amp;lt; u,U&amp;lt; v,V&amp;lt; w,W&amp;lt; x,X&amp;lt; y,Y&amp;lt; z,Z&quot; +
                 &quot;&amp;lt; &amp;#92;u00E5=a&amp;#92;u030A,&amp;#92;u00C5=A&amp;#92;u030A&quot; +
                 &quot;;aa,AA&amp;lt; &amp;#92;u00E6,&amp;#92;u00C6&amp;lt; &amp;#92;u00F8,&amp;#92;u00D8&quot;;
 RuleBasedCollator myNorwegian = new RuleBasedCollator(Norwegian);
 &lt;/pre&gt;
 &lt;/blockquote&gt;

 &lt;p&gt;
 A new collation rules string can be created by concatenating rules
 strings. For example, the rules returned by {@link #getRules()} could
 be concatenated to combine multiple &lt;code&gt;RuleBasedCollator&lt;/code&gt;s.

 &lt;p&gt;
 The following example demonstrates how to change the order of
 non-spacing accents,
 &lt;blockquote&gt;
 &lt;pre&gt;
 // old rule
 String oldRules = &quot;=&amp;#92;u0301;&amp;#92;u0300;&amp;#92;u0302;&amp;#92;u0308&quot;    // main accents
                 + &quot;;&amp;#92;u0327;&amp;#92;u0303;&amp;#92;u0304;&amp;#92;u0305&quot;    // main accents
                 + &quot;;&amp;#92;u0306;&amp;#92;u0307;&amp;#92;u0309;&amp;#92;u030A&quot;    // main accents
                 + &quot;;&amp;#92;u030B;&amp;#92;u030C;&amp;#92;u030D;&amp;#92;u030E&quot;    // main accents
                 + &quot;;&amp;#92;u030F;&amp;#92;u0310;&amp;#92;u0311;&amp;#92;u0312&quot;    // main accents
                 + &quot;&amp;lt; a , A ; ae, AE ; &amp;#92;u00e6 , &amp;#92;u00c6&quot;
                 + &quot;&amp;lt; b , B &amp;lt; c, C &amp;lt; e, E &amp; C &amp;lt; d, D&quot;;
 // change the order of accent characters
 String addOn = &quot;&amp; &amp;#92;u0300 ; &amp;#92;u0308 ; &amp;#92;u0302&quot;;
 RuleBasedCollator myCollator = new RuleBasedCollator(oldRules + addOn);
 &lt;/pre&gt;
 &lt;/blockquote&gt;</description>
			<attribute name="@see">
				<description>Collator</description>
			</attribute>
			<attribute name="@see">
				<description>CollationElementIterator</description>
			</attribute>
			<attribute name="@author">
				<description>Helena Shih, Laura Werner, Richard Gillam</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="1879048192" visibility="package-private" name="CHARINDEX" constexpr="1879048192" fulltype="int" type="int" />
			<field final="true" static="true" const="2113929216" visibility="package-private" name="EXPANDCHARINDEX" constexpr="2113929216" fulltype="int" type="int" />
			<field final="true" static="true" const="2130706432" visibility="package-private" name="CONTRACTCHARINDEX" constexpr="2130706432" fulltype="int" type="int" />
			<field final="true" static="true" const="-1" visibility="package-private" name="UNMAPPED" constexpr="-1" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="private" name="COLLATIONKEYOFFSET" constexpr="1" fulltype="int" type="int" />
			<field visibility="private" name="tables" fulltype="java.text.RBCollationTables" type="RBCollationTables" />
			<field visibility="private" name="primResult" fulltype="java.lang.StringBuffer" type="StringBuffer" />
			<field visibility="private" name="secResult" fulltype="java.lang.StringBuffer" type="StringBuffer" />
			<field visibility="private" name="terResult" fulltype="java.lang.StringBuffer" type="StringBuffer" />
			<field visibility="private" name="sourceCursor" fulltype="java.text.CollationElementIterator" type="CollationElementIterator" />
			<field visibility="private" name="targetCursor" fulltype="java.text.CollationElementIterator" type="CollationElementIterator" />
		</fields>
		<methods>
			<constructor visibility="public" name="RuleBasedCollator">
				<comment>
					<description>RuleBasedCollator constructor.  This takes the table rules and builds
 a collation table out of them.  Please see RuleBasedCollator class
 description for more details on the collation rule syntax.</description>
					<attribute name="@see">
						<description>java.util.Locale</description>
					</attribute>
					<attribute name="@param">
						<description>rules the collation rules to build the collation table from.</description>
					</attribute>
					<attribute name="@exception">
						<description>ParseException A format exception
 will be thrown if the build process of the rules fails. For
 example, build rule &quot;a &lt; ? &lt; d&quot; will cause the constructor to
 throw the ParseException because the &apos;?&apos; is not quoted.</description>
					</attribute>
				</comment>
				<params>
					<param name="rules" comment="the collation rules to build the collation table from." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="A format exception
 will be thrown if the build process of the rules fails. For
 example, build rule &quot;a &lt; ? &lt; d&quot; will cause the constructor to
 throw the ParseException because the &apos;?&apos; is not quoted." fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</constructor>
			<constructor visibility="package-private" name="RuleBasedCollator">
				<comment>
					<description>RuleBasedCollator constructor.  This takes the table rules and builds
 a collation table out of them.  Please see RuleBasedCollator class
 description for more details on the collation rule syntax.</description>
					<attribute name="@see">
						<description>java.util.Locale</description>
					</attribute>
					<attribute name="@param">
						<description>rules the collation rules to build the collation table from.</description>
					</attribute>
					<attribute name="@param">
						<description>decomp the decomposition strength used to build the
 collation table and to perform comparisons.</description>
					</attribute>
					<attribute name="@exception">
						<description>ParseException A format exception
 will be thrown if the build process of the rules fails. For
 example, build rule &quot;a &lt; ? &lt; d&quot; will cause the constructor to
 throw the ParseException because the &apos;?&apos; is not quoted.</description>
					</attribute>
				</comment>
				<params>
					<param name="rules" comment="the collation rules to build the collation table from." fulltype="java.lang.String" type="String" />
					<param name="decomp" comment="the decomposition strength used to build the
 collation table and to perform comparisons." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="A format exception
 will be thrown if the build process of the rules fails. For
 example, build rule &quot;a &lt; ? &lt; d&quot; will cause the constructor to
 throw the ParseException because the &apos;?&apos; is not quoted." fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</constructor>
			<constructor visibility="private" name="RuleBasedCollator">
				<comment>
					<description>&quot;Copy constructor.&quot;  Used in clone() for performance.</description>
				</comment>
				<params>
					<param name="that" fulltype="java.text.RuleBasedCollator" type="RuleBasedCollator" />
				</params>
			</constructor>
			<method visibility="public" name="getRules" returncomment="returns the collation rules that the table collation object
 was created from." fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the table-based rules for the collation object.</description>
					<attribute name="@return">
						<description>returns the collation rules that the table collation object
 was created from.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getCollationElementIterator" fulltype="java.text.CollationElementIterator" type="CollationElementIterator">
				<comment>
					<description>Return a CollationElementIterator for the given String.</description>
					<attribute name="@see">
						<description>java.text.CollationElementIterator</description>
					</attribute>
				</comment>
				<params>
					<param name="source" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getCollationElementIterator" fulltype="java.text.CollationElementIterator" type="CollationElementIterator">
				<comment>
					<description>Return a CollationElementIterator for the given String.</description>
					<attribute name="@see">
						<description>java.text.CollationElementIterator</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="source" fulltype="java.text.CharacterIterator" type="CharacterIterator" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="compare" fulltype="int" type="int">
				<comment>
					<description>Compares the character data stored in two different strings based on the
 collation rules.  Returns information about whether a string is less
 than, greater than or equal to another string in a language.
 This can be overriden in a subclass.</description>
				</comment>
				<params>
					<param name="source" fulltype="java.lang.String" type="String" />
					<param name="target" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="getCollationKey" fulltype="java.text.CollationKey" type="CollationKey">
				<comment>
					<description>Transforms the string into a series of characters that can be compared
 with CollationKey.compareTo. This overrides java.text.Collator.getCollationKey.
 It can be overriden in a subclass.</description>
				</comment>
				<params>
					<param name="source" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="clone" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Standard override; no change in semantics.</description>
				</comment>
			</method>
			<method visibility="public" name="equals" returncomment="true if the current table-based collation object is the same
 as the table-based collation object obj; false otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares the equality of two collation objects.</description>
					<attribute name="@param">
						<description>obj the table-based collation object to be compared with this.</description>
					</attribute>
					<attribute name="@return">
						<description>true if the current table-based collation object is the same
 as the table-based collation object obj; false otherwise.</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the table-based collation object to be compared with this." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Generates the hash code for the table-based collation object</description>
				</comment>
			</method>
			<method visibility="package-private" name="getTables" fulltype="java.text.RBCollationTables" type="RBCollationTables">
				<comment>
					<description>Allows CollationElementIterator access to the tables object</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Exception" visibility="public" package="java.text" serializable="true" superclassfulltype="java.lang.Exception" fulltype="java.text.ParseException" type="ParseException">
		<comment>
			<description>Signals that an error has been reached unexpectedly
 while parsing.</description>
			<attribute name="@see">
				<description>java.lang.Exception</description>
			</attribute>
			<attribute name="@see">
				<description>java.text.Format</description>
			</attribute>
			<attribute name="@see">
				<description>java.text.FieldPosition</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Davis</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="errorOffset" fulltype="int" type="int">
				<comment>
					<description>The zero-based character offset into the string being parsed at which
 the error was found during parsing.</description>
					<attribute name="@serial" />
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="ParseException">
				<comment>
					<description>Constructs a ParseException with the specified detail message and
 offset.
 A detail message is a String that describes this particular exception.</description>
					<attribute name="@param">
						<description>s the detail message</description>
					</attribute>
					<attribute name="@param">
						<description>errorOffset the position where the error is found while parsing.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the detail message" fulltype="java.lang.String" type="String" />
					<param name="errorOffset" comment="the position where the error is found while parsing." fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="public" name="getErrorOffset" fulltype="int" type="int">
				<comment>
					<description>Returns the position where the error was found.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.CollationKey" type="CollationKey">
		<implements>
			<interface fulltype="java.lang.Comparable" type="Comparable" />
		</implements>
		<comment>
			<description>A &lt;code&gt;CollationKey&lt;/code&gt; represents a &lt;code&gt;String&lt;/code&gt; under the
 rules of a specific &lt;code&gt;Collator&lt;/code&gt; object. Comparing two
 &lt;code&gt;CollationKey&lt;/code&gt;s returns the relative order of the
 &lt;code&gt;String&lt;/code&gt;s they represent. Using &lt;code&gt;CollationKey&lt;/code&gt;s
 to compare &lt;code&gt;String&lt;/code&gt;s is generally faster than using
 &lt;code&gt;Collator.compare&lt;/code&gt;. Thus, when the &lt;code&gt;String&lt;/code&gt;s
 must be compared multiple times, for example when sorting a list
 of &lt;code&gt;String&lt;/code&gt;s. It&apos;s more efficient to use &lt;code&gt;CollationKey&lt;/code&gt;s.

 &lt;p&gt;
 You can not create &lt;code&gt;CollationKey&lt;/code&gt;s directly. Rather,
 generate them by calling &lt;code&gt;Collator.getCollationKey&lt;/code&gt;.
 You can only compare &lt;code&gt;CollationKey&lt;/code&gt;s generated from
 the same &lt;code&gt;Collator&lt;/code&gt; object.

 &lt;p&gt;
 Generating a &lt;code&gt;CollationKey&lt;/code&gt; for a &lt;code&gt;String&lt;/code&gt;
 involves examining the entire &lt;code&gt;String&lt;/code&gt;
 and converting it to series of bits that can be compared bitwise. This
 allows fast comparisons once the keys are generated. The cost of generating
 keys is recouped in faster comparisons when &lt;code&gt;String&lt;/code&gt;s need
 to be compared many times. On the other hand, the result of a comparison
 is often determined by the first couple of characters of each &lt;code&gt;String&lt;/code&gt;.
 &lt;code&gt;Collator.compare&lt;/code&gt; examines only as many characters as it needs which
 allows it to be faster when doing single comparisons.
 &lt;p&gt;
 The following example shows how &lt;code&gt;CollationKey&lt;/code&gt;s might be used
 to sort a list of &lt;code&gt;String&lt;/code&gt;s.
 &lt;blockquote&gt;
 &lt;pre&gt;
 // Create an array of CollationKeys for the Strings to be sorted.
 Collator myCollator = Collator.getInstance();
 CollationKey[] keys = new CollationKey[3];
 keys[0] = myCollator.getCollationKey(&quot;Tom&quot;);
 keys[1] = myCollator.getCollationKey(&quot;Dick&quot;);
 keys[2] = myCollator.getCollationKey(&quot;Harry&quot;);
 sort( keys );
 &lt;br&gt;
 //...
 &lt;br&gt;
 // Inside body of sort routine, compare keys this way
 if( keys[i].compareTo( keys[j] ) &gt; 0 )
    // swap keys[i] and keys[j]
 &lt;br&gt;
 //...
 &lt;br&gt;
 // Finally, when we&apos;ve returned from sort.
 System.out.println( keys[0].getSourceString() );
 System.out.println( keys[1].getSourceString() );
 System.out.println( keys[2].getSourceString() );
 &lt;/pre&gt;
 &lt;/blockquote&gt;</description>
			<attribute name="@see">
				<description>Collator</description>
			</attribute>
			<attribute name="@see">
				<description>RuleBasedCollator</description>
			</attribute>
			<attribute name="@author">
				<description>Helena Shih</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" visibility="private" name="source" fulltype="java.lang.String" type="String" />
		</fields>
		<methods>
			<constructor visibility="protected" name="CollationKey">
				<comment>
					<description>CollationKey constructor.</description>
					<attribute name="@param">
						<description>source - the source string.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;source&lt;/code&gt; is null.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="- the source string." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method abstract="true" visibility="public" name="compareTo" returncomment="Returns an integer value. Value is less than zero if this is less
 than target, value is zero if this and target are equal and value is greater than
 zero if this is greater than target." fulltype="int" type="int">
				<comment>
					<description>Compare this CollationKey to the target CollationKey. The collation rules of the
 Collator object which created these keys are applied. &lt;strong&gt;Note:&lt;/strong&gt;
 CollationKeys created by different Collators can not be compared.</description>
					<attribute name="@param">
						<description>target target CollationKey</description>
					</attribute>
					<attribute name="@return">
						<description>Returns an integer value. Value is less than zero if this is less
 than target, value is zero if this and target are equal and value is greater than
 zero if this is greater than target.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#compare</description>
					</attribute>
				</comment>
				<params>
					<param name="target" comment="target CollationKey" fulltype="java.text.CollationKey" type="CollationKey" />
				</params>
			</method>
			<method visibility="public" name="getSourceString" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the String that this CollationKey represents.</description>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="toByteArray" fulltype="byte[]" type="byte">
				<comment>
					<description>Converts the CollationKey to a sequence of bits. If two CollationKeys
 could be legitimately compared, then one could compare the byte arrays
 for each of those keys to obtain the same result.  Byte arrays are
 organized most significant byte first.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.Collator" type="Collator">
		<implements>
			<interface fulltype="java.util.Comparator" type="Comparator" />
			<interface fulltype="java.lang.Cloneable" type="Cloneable" />
		</implements>
		<comment>
			<description>The &lt;code&gt;Collator&lt;/code&gt; class performs locale-sensitive
 &lt;code&gt;String&lt;/code&gt; comparison. You use this class to build
 searching and sorting routines for natural language text.

 &lt;p&gt;
 &lt;code&gt;Collator&lt;/code&gt; is an abstract base class. Subclasses
 implement specific collation strategies. One subclass,
 &lt;code&gt;RuleBasedCollator&lt;/code&gt;, is currently provided with
 the Java Platform and is applicable to a wide set of languages. Other
 subclasses may be created to handle more specialized needs.

 &lt;p&gt;
 Like other locale-sensitive classes, you can use the static
 factory method, &lt;code&gt;getInstance&lt;/code&gt;, to obtain the appropriate
 &lt;code&gt;Collator&lt;/code&gt; object for a given locale. You will only need
 to look at the subclasses of &lt;code&gt;Collator&lt;/code&gt; if you need
 to understand the details of a particular collation strategy or
 if you need to modify that strategy.

 &lt;p&gt;
 The following example shows how to compare two strings using
 the &lt;code&gt;Collator&lt;/code&gt; for the default locale.
 &lt;blockquote&gt;
 &lt;pre&gt;
 // Compare two strings in the default locale
 Collator myCollator = Collator.getInstance();
 if( myCollator.compare(&quot;abc&quot;, &quot;ABC&quot;) &lt; 0 )
     System.out.println(&quot;abc is less than ABC&quot;);
 else
     System.out.println(&quot;abc is greater than or equal to ABC&quot;);
 &lt;/pre&gt;
 &lt;/blockquote&gt;

 &lt;p&gt;
 You can set a &lt;code&gt;Collator&lt;/code&gt;&apos;s &lt;em&gt;strength&lt;/em&gt; property
 to determine the level of difference considered significant in
 comparisons. Four strengths are provided: &lt;code&gt;PRIMARY&lt;/code&gt;,
 &lt;code&gt;SECONDARY&lt;/code&gt;, &lt;code&gt;TERTIARY&lt;/code&gt;, and &lt;code&gt;IDENTICAL&lt;/code&gt;.
 The exact assignment of strengths to language features is
 locale dependant.  For example, in Czech, &quot;e&quot; and &quot;f&quot; are considered
 primary differences, while &quot;e&quot; and &quot;&amp;#283;&quot; are secondary differences,
 &quot;e&quot; and &quot;E&quot; are tertiary differences and &quot;e&quot; and &quot;e&quot; are identical.
 The following shows how both case and accents could be ignored for
 US English.
 &lt;blockquote&gt;
 &lt;pre&gt;
 //Get the Collator for US English and set its strength to PRIMARY
 Collator usCollator = Collator.getInstance(Locale.US);
 usCollator.setStrength(Collator.PRIMARY);
 if( usCollator.compare(&quot;abc&quot;, &quot;ABC&quot;) == 0 ) {
     System.out.println(&quot;Strings are equivalent&quot;);
 }
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
 For comparing &lt;code&gt;String&lt;/code&gt;s exactly once, the &lt;code&gt;compare&lt;/code&gt;
 method provides the best performance. When sorting a list of
 &lt;code&gt;String&lt;/code&gt;s however, it is generally necessary to compare each
 &lt;code&gt;String&lt;/code&gt; multiple times. In this case, &lt;code&gt;CollationKey&lt;/code&gt;s
 provide better performance. The &lt;code&gt;CollationKey&lt;/code&gt; class converts
 a &lt;code&gt;String&lt;/code&gt; to a series of bits that can be compared bitwise
 against other &lt;code&gt;CollationKey&lt;/code&gt;s. A &lt;code&gt;CollationKey&lt;/code&gt; is
 created by a &lt;code&gt;Collator&lt;/code&gt; object for a given &lt;code&gt;String&lt;/code&gt;.
 &lt;br&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; &lt;code&gt;CollationKey&lt;/code&gt;s from different
 &lt;code&gt;Collator&lt;/code&gt;s can not be compared. See the class description
 for {@link CollationKey}
 for an example using &lt;code&gt;CollationKey&lt;/code&gt;s.</description>
			<attribute name="@see">
				<description>RuleBasedCollator</description>
			</attribute>
			<attribute name="@see">
				<description>CollationKey</description>
			</attribute>
			<attribute name="@see">
				<description>CollationElementIterator</description>
			</attribute>
			<attribute name="@see">
				<description>Locale</description>
			</attribute>
			<attribute name="@author">
				<description>Helena Shih, Laura Werner, Richard Gillam</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="0" visibility="public" name="PRIMARY" constexpr="0" fulltype="int" type="int">
				<comment>
					<description>Collator strength value.  When set, only PRIMARY differences are
 considered significant during comparison. The assignment of strengths
 to language features is locale dependant. A common example is for
 different base letters (&quot;a&quot; vs &quot;b&quot;) to be considered a PRIMARY difference.</description>
					<attribute name="@see">
						<description>java.text.Collator#setStrength</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#getStrength</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="1" visibility="public" name="SECONDARY" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>Collator strength value.  When set, only SECONDARY and above differences are
 considered significant during comparison. The assignment of strengths
 to language features is locale dependant. A common example is for
 different accented forms of the same base letter (&quot;a&quot; vs &quot;&quot;) to be
 considered a SECONDARY difference.</description>
					<attribute name="@see">
						<description>java.text.Collator#setStrength</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#getStrength</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="2" visibility="public" name="TERTIARY" constexpr="2" fulltype="int" type="int">
				<comment>
					<description>Collator strength value.  When set, only TERTIARY and above differences are
 considered significant during comparison. The assignment of strengths
 to language features is locale dependant. A common example is for
 case differences (&quot;a&quot; vs &quot;A&quot;) to be considered a TERTIARY difference.</description>
					<attribute name="@see">
						<description>java.text.Collator#setStrength</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#getStrength</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="3" visibility="public" name="IDENTICAL" constexpr="3" fulltype="int" type="int">
				<comment>
					<description>Collator strength value.  When set, all differences are
 considered significant during comparison. The assignment of strengths
 to language features is locale dependant. A common example is for control
 characters (&quot;&amp;#092;u0001&quot; vs &quot;&amp;#092;u0002&quot;) to be considered equal at the
 PRIMARY, SECONDARY, and TERTIARY levels but different at the IDENTICAL
 level.  Additionally, differences between pre-composed accents such as
 &quot;&amp;#092;u00C0&quot; (A-grave) and combining accents such as &quot;A&amp;#092;u0300&quot;
 (A, combining-grave) will be considered significant at the IDENTICAL
 level if decomposition is set to NO_DECOMPOSITION.</description>
				</comment>
			</field>
			<field final="true" static="true" const="0" visibility="public" name="NO_DECOMPOSITION" constexpr="0" fulltype="int" type="int">
				<comment>
					<description>Decomposition mode value. With NO_DECOMPOSITION
 set, accented characters will not be decomposed for collation. This
 is the default setting and provides the fastest collation but
 will only produce correct results for languages that do not use accents.</description>
					<attribute name="@see">
						<description>java.text.Collator#getDecomposition</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#setDecomposition</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="1" visibility="public" name="CANONICAL_DECOMPOSITION" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>Decomposition mode value. With CANONICAL_DECOMPOSITION
 set, characters that are canonical variants according to Unicode
 standard will be decomposed for collation. This should be used to get
 correct collation of accented characters.
 &lt;p&gt;
 CANONICAL_DECOMPOSITION corresponds to Normalization Form D as
 described in
 &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr15/tr15-23.html&quot;&gt;Unicode
 Technical Report #15&lt;/a&gt;.</description>
					<attribute name="@see">
						<description>java.text.Collator#getDecomposition</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#setDecomposition</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="2" visibility="public" name="FULL_DECOMPOSITION" constexpr="2" fulltype="int" type="int">
				<comment>
					<description>Decomposition mode value. With FULL_DECOMPOSITION
 set, both Unicode canonical variants and Unicode compatibility variants
 will be decomposed for collation.  This causes not only accented
 characters to be collated, but also characters that have special formats
 to be collated with their norminal form. For example, the half-width and
 full-width ASCII and Katakana characters are then collated together.
 FULL_DECOMPOSITION is the most complete and therefore the slowest
 decomposition mode.
 &lt;p&gt;
 FULL_DECOMPOSITION corresponds to Normalization Form KD as
 described in
 &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr15/tr15-23.html&quot;&gt;Unicode
 Technical Report #15&lt;/a&gt;.</description>
					<attribute name="@see">
						<description>java.text.Collator#getDecomposition</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#setDecomposition</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="strength" fulltype="int" type="int" />
			<field visibility="private" name="decmp" fulltype="int" type="int" />
			<field static="true" visibility="private" name="cache" fulltype="sun.misc.SoftCache" type="SoftCache" />
			<field final="true" static="true" const="-1" visibility="package-private" name="LESS" constexpr="-1" fulltype="int" type="int">
				<comment>
					<description>LESS is returned if source string is compared to be less than target
 string in the compare() method.</description>
					<attribute name="@see">
						<description>java.text.Collator#compare</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="0" visibility="package-private" name="EQUAL" constexpr="0" fulltype="int" type="int">
				<comment>
					<description>EQUAL is returned if source string is compared to be equal to target
 string in the compare() method.</description>
					<attribute name="@see">
						<description>java.text.Collator#compare</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="1" visibility="package-private" name="GREATER" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>GREATER is returned if source string is compared to be greater than
 target string in the compare() method.</description>
					<attribute name="@see">
						<description>java.text.Collator#compare</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="protected" name="Collator">
				<comment>
					<description>Default constructor.  This constructor is
 protected so subclasses can get access to it. Users typically create
 a Collator sub-class by calling the factory method getInstance.</description>
					<attribute name="@see">
						<description>java.text.Collator#getInstance</description>
					</attribute>
				</comment>
			</constructor>
			<method static="true" synchronized="true" visibility="public" name="getInstance" returncomment="the Collator for the default locale.(for example, en_US)" fulltype="java.text.Collator" type="Collator">
				<comment>
					<description>Gets the Collator for the current default locale.
 The default locale is determined by java.util.Locale.getDefault.</description>
					<attribute name="@return">
						<description>the Collator for the default locale.(for example, en_US)</description>
					</attribute>
					<attribute name="@see">
						<description>java.util.Locale#getDefault</description>
					</attribute>
				</comment>
			</method>
			<method static="true" synchronized="true" visibility="public" name="getInstance" returncomment="the Collator for the desired locale." fulltype="java.text.Collator" type="Collator">
				<comment>
					<description>Gets the Collator for the desired locale.</description>
					<attribute name="@param">
						<description>desiredLocale the desired locale.</description>
					</attribute>
					<attribute name="@return">
						<description>the Collator for the desired locale.</description>
					</attribute>
					<attribute name="@see">
						<description>java.util.Locale</description>
					</attribute>
					<attribute name="@see">
						<description>java.util.ResourceBundle</description>
					</attribute>
				</comment>
				<params>
					<param name="desiredLocale" comment="the desired locale." fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="compare" returncomment="Returns an integer value. Value is less than zero if source is less than
 target, value is zero if source and target are equal, value is greater than zero
 if source is greater than target." fulltype="int" type="int">
				<comment>
					<description>Compares the source string to the target string according to the
 collation rules for this Collator.  Returns an integer less than,
 equal to or greater than zero depending on whether the source String is
 less than, equal to or greater than the target string.  See the Collator
 class description for an example of use.
 &lt;p&gt;
 For a one time comparison, this method has the best performance. If a
 given String will be involved in multiple comparisons, CollationKey.compareTo
 has the best performance. See the Collator class description for an example
 using CollationKeys.</description>
					<attribute name="@param">
						<description>source the source string.</description>
					</attribute>
					<attribute name="@param">
						<description>target the target string.</description>
					</attribute>
					<attribute name="@return">
						<description>Returns an integer value. Value is less than zero if source is less than
 target, value is zero if source and target are equal, value is greater than zero
 if source is greater than target.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.CollationKey</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#getCollationKey</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="the source string." fulltype="java.lang.String" type="String" />
					<param name="target" comment="the target string." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="compare" returncomment="a negative integer, zero, or a positive integer as the
         first argument is less than, equal to, or greater than the
         second." fulltype="int" type="int">
				<comment>
					<description>Compares its two arguments for order.  Returns a negative integer,
 zero, or a positive integer as the first argument is less than, equal
 to, or greater than the second.
 &lt;p&gt;
 This implementation merely returns
  &lt;code&gt; compare((String)o1, (String)o2) &lt;/code&gt;.</description>
					<attribute name="@return">
						<description>a negative integer, zero, or a positive integer as the
         first argument is less than, equal to, or greater than the
         second.</description>
					</attribute>
					<attribute name="@exception">
						<description>ClassCastException the arguments cannot be cast to Strings.</description>
					</attribute>
					<attribute name="@see">
						<description>java.util.Comparator</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="o1" fulltype="java.lang.Object" type="Object" />
					<param name="o2" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="getCollationKey" returncomment="the CollationKey for the given String based on this Collator&apos;s collation
 rules. If the source String is null, a null CollationKey is returned." fulltype="java.text.CollationKey" type="CollationKey">
				<comment>
					<description>Transforms the String into a series of bits that can be compared bitwise
 to other CollationKeys. CollationKeys provide better performance than
 Collator.compare when Strings are involved in multiple comparisons.
 See the Collator class description for an example using CollationKeys.</description>
					<attribute name="@param">
						<description>source the string to be transformed into a collation key.</description>
					</attribute>
					<attribute name="@return">
						<description>the CollationKey for the given String based on this Collator&apos;s collation
 rules. If the source String is null, a null CollationKey is returned.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.CollationKey</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#compare</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="the string to be transformed into a collation key." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="equals" returncomment="true if the strings are equal according to the collation
 rules.  false, otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Convenience method for comparing the equality of two strings based on
 this Collator&apos;s collation rules.</description>
					<attribute name="@param">
						<description>source the source string to be compared with.</description>
					</attribute>
					<attribute name="@param">
						<description>target the target string to be compared with.</description>
					</attribute>
					<attribute name="@return">
						<description>true if the strings are equal according to the collation
 rules.  false, otherwise.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#compare</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="the source string to be compared with." fulltype="java.lang.String" type="String" />
					<param name="target" comment="the target string to be compared with." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="getStrength" returncomment="this Collator&apos;s current strength property." fulltype="int" type="int">
				<comment>
					<description>Returns this Collator&apos;s strength property.  The strength property determines
 the minimum level of difference considered significant during comparison.
 See the Collator class description for an example of use.</description>
					<attribute name="@return">
						<description>this Collator&apos;s current strength property.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#setStrength</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#PRIMARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#SECONDARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#TERTIARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#IDENTICAL</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="setStrength" fulltype="void" type="void">
				<comment>
					<description>Sets this Collator&apos;s strength property.  The strength property determines
 the minimum level of difference considered significant during comparison.
 See the Collator class description for an example of use.</description>
					<attribute name="@param">
						<description>newStrength  the new strength value.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#getStrength</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#PRIMARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#SECONDARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#TERTIARY</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#IDENTICAL</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException If the new strength value is not one of
 PRIMARY, SECONDARY, TERTIARY or IDENTICAL.</description>
					</attribute>
				</comment>
				<params>
					<param name="newStrength" comment="the new strength value." fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="getDecomposition" returncomment="the decomposition mode" fulltype="int" type="int">
				<comment>
					<description>Get the decomposition mode of this Collator. Decomposition mode
 determines how Unicode composed characters are handled. Adjusting
 decomposition mode allows the user to select between faster and more
 complete collation behavior.
 &lt;p&gt;The three values for decomposition mode are:
 &lt;UL&gt;
 &lt;LI&gt;NO_DECOMPOSITION,
 &lt;LI&gt;CANONICAL_DECOMPOSITION
 &lt;LI&gt;FULL_DECOMPOSITION.
 &lt;/UL&gt;
 See the documentation for these three constants for a description
 of their meaning.</description>
					<attribute name="@return">
						<description>the decomposition mode</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#setDecomposition</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#NO_DECOMPOSITION</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#CANONICAL_DECOMPOSITION</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#FULL_DECOMPOSITION</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="setDecomposition" fulltype="void" type="void">
				<comment>
					<description>Set the decomposition mode of this Collator. See getDecomposition
 for a description of decomposition mode.</description>
					<attribute name="@param">
						<description>decompositionMode  the new decomposition mode.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#getDecomposition</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#NO_DECOMPOSITION</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#CANONICAL_DECOMPOSITION</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Collator#FULL_DECOMPOSITION</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException If the given value is not a valid decomposition
 mode.</description>
					</attribute>
				</comment>
				<params>
					<param name="decompositionMode" comment="the new decomposition mode." fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" synchronized="true" visibility="public" name="getAvailableLocales" returncomment="An array of locales for which localized
         &lt;code&gt;Collator&lt;/code&gt; instances are available." fulltype="java.util.Locale[]" type="Locale">
				<comment>
					<description>Returns an array of all locales for which the
 &lt;code&gt;getInstance&lt;/code&gt; methods of this class can return
 localized instances.
 The returned array represents the union of locales supported
 by the Java runtime and by installed
 {@link java.text.spi.CollatorProvider CollatorProvider} implementations.
 It must contain at least a Locale instance equal to
 {@link java.util.Locale#US Locale.US}.</description>
					<attribute name="@return">
						<description>An array of locales for which localized
         &lt;code&gt;Collator&lt;/code&gt; instances are available.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="clone" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Overrides Cloneable</description>
				</comment>
			</method>
			<method visibility="public" name="equals" returncomment="true if this Collator is the same as that Collator;
 false otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares the equality of two Collators.</description>
					<attribute name="@param">
						<description>that the Collator to be compared with this.</description>
					</attribute>
					<attribute name="@return">
						<description>true if this Collator is the same as that Collator;
 false otherwise.</description>
					</attribute>
				</comment>
				<params>
					<param name="that" comment="the Collator to be compared with this." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Generates the hash code for this Collator.</description>
				</comment>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.Collator.CollatorGetter" type="Collator.CollatorGetter">
			<implements>
				<interface fulltype="sun.util.LocaleServiceProviderPool.LocalizedObjectGetter" type="LocaleServiceProviderPool.LocalizedObjectGetter" />
			</implements>
			<comment>
				<description>Obtains a Collator instance from a CollatorProvider
 implementation.</description>
			</comment>
			<fields>
				<field final="true" static="true" visibility="private" name="INSTANCE" fulltype="java.text.Collator.CollatorGetter" type="Collator.CollatorGetter" />
			</fields>
			<methods>
				<constructor visibility="private" name="Collator.CollatorGetter" />
				<method visibility="public" name="getObject" fulltype="java.text.Collator" type="Collator">
					<params>
						<param name="collatorProvider" fulltype="java.text.spi.CollatorProvider" type="CollatorProvider" />
						<param name="locale" fulltype="java.util.Locale" type="Locale" />
						<param name="key" fulltype="java.lang.String" type="String" />
						<param name="params" fulltype="java.lang.Object[]" type="Object" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.Collator.CollatorGetter" type="Collator.CollatorGetter">
		<implements>
			<interface fulltype="sun.util.LocaleServiceProviderPool.LocalizedObjectGetter" type="LocaleServiceProviderPool.LocalizedObjectGetter" />
		</implements>
		<comment>
			<description>Obtains a Collator instance from a CollatorProvider
 implementation.</description>
		</comment>
		<fields>
			<field final="true" static="true" visibility="private" name="INSTANCE" fulltype="java.text.Collator.CollatorGetter" type="Collator.CollatorGetter" />
		</fields>
		<methods>
			<constructor visibility="private" name="Collator.CollatorGetter" />
			<method visibility="public" name="getObject" fulltype="java.text.Collator" type="Collator">
				<params>
					<param name="collatorProvider" fulltype="java.text.spi.CollatorProvider" type="CollatorProvider" />
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
					<param name="key" fulltype="java.lang.String" type="String" />
					<param name="params" fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.EntryPair" type="EntryPair">
		<comment>
			<description>This is used for building contracting character tables.  entryName
 is the contracting character name and value is its collation
 order.</description>
		</comment>
		<fields>
			<field visibility="public" name="entryName" fulltype="java.lang.String" type="String" />
			<field visibility="public" name="value" fulltype="int" type="int" />
			<field visibility="public" name="fwd" fulltype="boolean" type="boolean" />
		</fields>
		<methods>
			<constructor visibility="public" name="EntryPair">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="value" fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="EntryPair">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="value" fulltype="int" type="int" />
					<param name="fwd" fulltype="boolean" type="boolean" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="Format" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.Format" fulltype="java.text.MessageFormat" type="MessageFormat">
		<comment>
			<description>&lt;code&gt;MessageFormat&lt;/code&gt; provides a means to produce concatenated
 messages in a language-neutral way. Use this to construct messages
 displayed for end users.

 &lt;p&gt;
 &lt;code&gt;MessageFormat&lt;/code&gt; takes a set of objects, formats them, then
 inserts the formatted strings into the pattern at the appropriate places.

 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt;
 &lt;code&gt;MessageFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;
 classes in that you create a &lt;code&gt;MessageFormat&lt;/code&gt; object with one
 of its constructors (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory
 method). The factory methods aren&apos;t necessary because &lt;code&gt;MessageFormat&lt;/code&gt;
 itself doesn&apos;t implement locale specific behavior. Any locale specific
 behavior is defined by the pattern that you provide as well as the
 subformats used for inserted arguments.

 &lt;h4&gt;&lt;a name=&quot;patterns&quot;&gt;Patterns and Their Interpretation&lt;/a&gt;&lt;/h4&gt;

 &lt;code&gt;MessageFormat&lt;/code&gt; uses patterns of the following form:
 &lt;blockquote&gt;&lt;pre&gt;
 &lt;i&gt;MessageFormatPattern:&lt;/i&gt;
         &lt;i&gt;String&lt;/i&gt;
         &lt;i&gt;MessageFormatPattern&lt;/i&gt; &lt;i&gt;FormatElement&lt;/i&gt; &lt;i&gt;String&lt;/i&gt;

 &lt;i&gt;FormatElement:&lt;/i&gt;
         { &lt;i&gt;ArgumentIndex&lt;/i&gt; }
         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; }
         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; , &lt;i&gt;FormatStyle&lt;/i&gt; }

 &lt;i&gt;FormatType: one of &lt;/i&gt;
         number date time choice

 &lt;i&gt;FormatStyle:&lt;/i&gt;
         short
         medium
         long
         full
         integer
         currency
         percent
         &lt;i&gt;SubformatPattern&lt;/i&gt;

 &lt;i&gt;String:&lt;/i&gt;
         &lt;i&gt;StringPart&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
         &lt;i&gt;String&lt;/i&gt; &lt;i&gt;StringPart&lt;/i&gt;

 &lt;i&gt;StringPart:&lt;/i&gt;
         &apos;&apos;
         &apos; &lt;i&gt;QuotedString&lt;/i&gt; &apos;
         &lt;i&gt;UnquotedString&lt;/i&gt;

 &lt;i&gt;SubformatPattern:&lt;/i&gt;
         &lt;i&gt;SubformatPatternPart&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
         &lt;i&gt;SubformatPattern&lt;/i&gt; &lt;i&gt;SubformatPatternPart&lt;/i&gt;

 &lt;i&gt;SubFormatPatternPart:&lt;/i&gt;
         &apos; &lt;i&gt;QuotedPattern&lt;/i&gt; &apos;
         &lt;i&gt;UnquotedPattern&lt;/i&gt;
 &lt;/pre&gt;&lt;/blockquote&gt;

 &lt;p&gt;
 Within a &lt;i&gt;String&lt;/i&gt;, &lt;code&gt;&quot;&apos;&apos;&quot;&lt;/code&gt; represents a single
 quote. A &lt;i&gt;QuotedString&lt;/i&gt; can contain arbitrary characters
 except single quotes; the surrounding single quotes are removed.
 An &lt;i&gt;UnquotedString&lt;/i&gt; can contain arbitrary characters
 except single quotes and left curly brackets. Thus, a string that
 should result in the formatted message &quot;&apos;{0}&apos;&quot; can be written as
 &lt;code&gt;&quot;&apos;&apos;&apos;{&apos;0}&apos;&apos;&quot;&lt;/code&gt; or &lt;code&gt;&quot;&apos;&apos;&apos;{0}&apos;&apos;&apos;&quot;&lt;/code&gt;.
 &lt;p&gt;
 Within a &lt;i&gt;SubformatPattern&lt;/i&gt;, different rules apply.
 A &lt;i&gt;QuotedPattern&lt;/i&gt; can contain arbitrary characters
 except single quotes; but the surrounding single quotes are
 &lt;strong&gt;not&lt;/strong&gt; removed, so they may be interpreted by the
 subformat. For example, &lt;code&gt;&quot;{1,number,$&apos;#&apos;,##}&quot;&lt;/code&gt; will
 produce a number format with the pound-sign quoted, with a result
 such as: &quot;$#31,45&quot;.
 An &lt;i&gt;UnquotedPattern&lt;/i&gt; can contain arbitrary characters
 except single quotes, but curly braces within it must be balanced.
 For example, &lt;code&gt;&quot;ab {0} de&quot;&lt;/code&gt; and &lt;code&gt;&quot;ab &apos;}&apos; de&quot;&lt;/code&gt;
 are valid subformat patterns, but &lt;code&gt;&quot;ab {0&apos;}&apos; de&quot;&lt;/code&gt; and
 &lt;code&gt;&quot;ab } de&quot;&lt;/code&gt; are not.
 &lt;p&gt;
 &lt;dl&gt;&lt;dt&gt;&lt;b&gt;Warning:&lt;/b&gt;&lt;dd&gt;The rules for using quotes within message
 format patterns unfortunately have shown to be somewhat confusing.
 In particular, it isn&apos;t always obvious to localizers whether single
 quotes need to be doubled or not. Make sure to inform localizers about
 the rules, and tell them (for example, by using comments in resource
 bundle source files) which strings will be processed by MessageFormat.
 Note that localizers may need to use single quotes in translated
 strings where the original version doesn&apos;t have them.
 &lt;/dl&gt;
 &lt;p&gt;
 The &lt;i&gt;ArgumentIndex&lt;/i&gt; value is a non-negative integer written
 using the digits &apos;0&apos; through &apos;9&apos;, and represents an index into the
 &lt;code&gt;arguments&lt;/code&gt; array passed to the &lt;code&gt;format&lt;/code&gt; methods
 or the result array returned by the &lt;code&gt;parse&lt;/code&gt; methods.
 &lt;p&gt;
 The &lt;i&gt;FormatType&lt;/i&gt; and &lt;i&gt;FormatStyle&lt;/i&gt; values are used to create
 a &lt;code&gt;Format&lt;/code&gt; instance for the format element. The following
 table shows how the values map to Format instances. Combinations not
 shown in the table are illegal. A &lt;i&gt;SubformatPattern&lt;/i&gt; must
 be a valid pattern string for the Format subclass used.
 &lt;p&gt;
 &lt;table border=1 summary=&quot;Shows how FormatType and FormatStyle values map to Format instances&quot;&gt;
    &lt;tr&gt;
       &lt;th id=&quot;ft&quot;&gt;Format Type
       &lt;th id=&quot;fs&quot;&gt;Format Style
       &lt;th id=&quot;sc&quot;&gt;Subformat Created
    &lt;tr&gt;
       &lt;td headers=&quot;ft&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;null&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;ft&quot; rowspan=5&gt;&lt;code&gt;number&lt;/code&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;NumberFormat.getInstance(getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;integer&lt;/code&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;NumberFormat.getIntegerInstance(getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;currency&lt;/code&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;NumberFormat.getCurrencyInstance(getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;percent&lt;/code&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;NumberFormat.getPercentInstance(getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;new DecimalFormat(subformatPattern, DecimalFormatSymbols.getInstance(getLocale()))&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;ft&quot; rowspan=6&gt;&lt;code&gt;date&lt;/code&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;short&lt;/code&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;DateFormat.getDateInstance(DateFormat.SHORT, getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;medium&lt;/code&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;long&lt;/code&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;DateFormat.getDateInstance(DateFormat.LONG, getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;full&lt;/code&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;DateFormat.getDateInstance(DateFormat.FULL, getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;new SimpleDateFormat(subformatPattern, getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;ft&quot; rowspan=6&gt;&lt;code&gt;time&lt;/code&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;short&lt;/code&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;medium&lt;/code&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;long&lt;/code&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;DateFormat.getTimeInstance(DateFormat.LONG, getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;full&lt;/code&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;DateFormat.getTimeInstance(DateFormat.FULL, getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;new SimpleDateFormat(subformatPattern, getLocale())&lt;/code&gt;
    &lt;tr&gt;
       &lt;td headers=&quot;ft&quot;&gt;&lt;code&gt;choice&lt;/code&gt;
       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;new ChoiceFormat(subformatPattern)&lt;/code&gt;
 &lt;/table&gt;
 &lt;p&gt;

 &lt;h4&gt;Usage Information&lt;/h4&gt;

 &lt;p&gt;
 Here are some examples of usage.
 In real internationalized programs, the message format pattern and other
 static strings will, of course, be obtained from resource bundles.
 Other parameters will be dynamically determined at runtime.
 &lt;p&gt;
 The first example uses the static method &lt;code&gt;MessageFormat.format&lt;/code&gt;,
 which internally creates a &lt;code&gt;MessageFormat&lt;/code&gt; for one-time use:
 &lt;blockquote&gt;&lt;pre&gt;
 int planet = 7;
 String event = &quot;a disturbance in the Force&quot;;

 String result = MessageFormat.format(
     &quot;At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.&quot;,
     planet, new Date(), event);
 &lt;/pre&gt;&lt;/blockquote&gt;
 The output is:
 &lt;blockquote&gt;&lt;pre&gt;
 At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
 &lt;/pre&gt;&lt;/blockquote&gt;

 &lt;p&gt;
 The following example creates a &lt;code&gt;MessageFormat&lt;/code&gt; instance that
 can be used repeatedly:
 &lt;blockquote&gt;&lt;pre&gt;
 int fileCount = 1273;
 String diskName = &quot;MyDisk&quot;;
 Object[] testArgs = {new Long(fileCount), diskName};

 MessageFormat form = new MessageFormat(
     &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;);

 System.out.println(form.format(testArgs));
 &lt;/pre&gt;&lt;/blockquote&gt;
 The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:
 &lt;blockquote&gt;&lt;pre&gt;
 The disk &quot;MyDisk&quot; contains 0 file(s).
 The disk &quot;MyDisk&quot; contains 1 file(s).
 The disk &quot;MyDisk&quot; contains 1,273 file(s).
 &lt;/pre&gt;&lt;/blockquote&gt;

 &lt;p&gt;
 For more sophisticated patterns, you can use a &lt;code&gt;ChoiceFormat&lt;/code&gt;
 to produce correct forms for singular and plural:
 &lt;blockquote&gt;&lt;pre&gt;
 MessageFormat form = new MessageFormat(&quot;The disk \&quot;{1}\&quot; contains {0}.&quot;);
 double[] filelimits = {0,1,2};
 String[] filepart = {&quot;no files&quot;,&quot;one file&quot;,&quot;{0,number} files&quot;};
 ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
 form.setFormatByArgumentIndex(0, fileform);

 int fileCount = 1273;
 String diskName = &quot;MyDisk&quot;;
 Object[] testArgs = {new Long(fileCount), diskName};

 System.out.println(form.format(testArgs));
 &lt;/pre&gt;&lt;/blockquote&gt;
 The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:
 &lt;blockquote&gt;&lt;pre&gt;
 The disk &quot;MyDisk&quot; contains no files.
 The disk &quot;MyDisk&quot; contains one file.
 The disk &quot;MyDisk&quot; contains 1,273 files.
 &lt;/pre&gt;&lt;/blockquote&gt;

 &lt;p&gt;
 You can create the &lt;code&gt;ChoiceFormat&lt;/code&gt; programmatically, as in the
 above example, or by using a pattern. See {@link ChoiceFormat}
 for more information.
 &lt;blockquote&gt;&lt;pre&gt;
 form.applyPattern(
    &quot;There {0,choice,0#are no files|1#is one file|1&amp;lt;are {0,number,integer} files}.&quot;);
 &lt;/pre&gt;&lt;/blockquote&gt;

 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; As we see above, the string produced
 by a &lt;code&gt;ChoiceFormat&lt;/code&gt; in &lt;code&gt;MessageFormat&lt;/code&gt; is treated as special;
 occurrences of &apos;{&apos; are used to indicate subformats, and cause recursion.
 If you create both a &lt;code&gt;MessageFormat&lt;/code&gt; and &lt;code&gt;ChoiceFormat&lt;/code&gt;
 programmatically (instead of using the string patterns), then be careful not to
 produce a format that recurses on itself, which will cause an infinite loop.
 &lt;p&gt;
 When a single argument is parsed more than once in the string, the last match
 will be the final result of the parsing.  For example,
 &lt;blockquote&gt;&lt;pre&gt;
 MessageFormat mf = new MessageFormat(&quot;{0,number,#.##}, {0,number,#.#}&quot;);
 Object[] objs = {new Double(3.1415)};
 String result = mf.format( objs );
 // result now equals &quot;3.14, 3.1&quot;
 objs = null;
 objs = mf.parse(result, new ParsePosition(0));
 // objs now equals {new Double(3.1)}
 &lt;/pre&gt;&lt;/blockquote&gt;

 &lt;p&gt;
 Likewise, parsing with a MessageFormat object using patterns containing
 multiple occurrences of the same argument would return the last match.  For
 example,
 &lt;blockquote&gt;&lt;pre&gt;
 MessageFormat mf = new MessageFormat(&quot;{0}, {0}, {0}&quot;);
 String forParsing = &quot;x, y, z&quot;;
 Object[] objs = mf.parse(forParsing, new ParsePosition(0));
 // result now equals {new String(&quot;z&quot;)}
 &lt;/pre&gt;&lt;/blockquote&gt;

 &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;

 &lt;p&gt;
 Message formats are not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently, it must be synchronized
 externally.</description>
			<attribute name="@see">
				<description>java.util.Locale</description>
			</attribute>
			<attribute name="@see">
				<description>Format</description>
			</attribute>
			<attribute name="@see">
				<description>NumberFormat</description>
			</attribute>
			<attribute name="@see">
				<description>DecimalFormat</description>
			</attribute>
			<attribute name="@see">
				<description>ChoiceFormat</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Davis</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="6479157306784022952" visibility="private" name="serialVersionUID" constexpr="6479157306784022952L" fulltype="long" type="long" />
			<field visibility="private" name="locale" fulltype="java.util.Locale" type="Locale">
				<comment>
					<description>The locale to use for formatting numbers and dates.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" name="pattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>The string that the formatted values are to be plugged into.  In other words, this
 is the pattern supplied on construction with all of the {} expressions taken out.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field final="true" static="true" const="10" visibility="private" name="INITIAL_FORMATS" constexpr="10" fulltype="int" type="int">
				<comment>
					<description>The initially expected number of subformats in the format</description>
				</comment>
			</field>
			<field visibility="private" name="formats" fulltype="java.text.Format[]" type="Format">
				<comment>
					<description>An array of formatters, which are used to format the arguments.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" name="offsets" fulltype="int[]" type="int">
				<comment>
					<description>The positions where the results of formatting each argument are to be inserted
 into the pattern.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" name="argumentNumbers" fulltype="int[]" type="int">
				<comment>
					<description>The argument numbers corresponding to each formatter.  (The formatters are stored
 in the order they occur in the pattern, not in the order in which the arguments
 are specified.)</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" name="maxOffset" fulltype="int" type="int">
				<comment>
					<description>One less than the number of entries in &lt;code&gt;offsets&lt;/code&gt;.  Can also be thought of
 as the index of the highest-numbered element in &lt;code&gt;offsets&lt;/code&gt; that is being used.
 All of these arrays should have the same number of elements being used as &lt;code&gt;offsets&lt;/code&gt;
 does, and so this variable suffices to tell us how many entries are in all of them.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="typeList" fulltype="java.lang.String[]" type="String" />
			<field final="true" static="true" visibility="private" name="modifierList" fulltype="java.lang.String[]" type="String" />
			<field final="true" static="true" visibility="private" name="dateModifierList" fulltype="java.lang.String[]" type="String" />
		</fields>
		<methods>
			<constructor visibility="public" name="MessageFormat">
				<comment>
					<description>Constructs a MessageFormat for the default locale and the
 specified pattern.
 The constructor first sets the locale, then parses the pattern and
 creates a list of subformats for the format elements contained in it.
 Patterns and their interpretation are specified in the
 &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.</description>
					<attribute name="@param">
						<description>pattern the pattern for this message format</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the pattern is invalid</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="the pattern for this message format" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="MessageFormat">
				<comment>
					<description>Constructs a MessageFormat for the specified locale and
 pattern.
 The constructor first sets the locale, then parses the pattern and
 creates a list of subformats for the format elements contained in it.
 Patterns and their interpretation are specified in the
 &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.</description>
					<attribute name="@param">
						<description>pattern the pattern for this message format</description>
					</attribute>
					<attribute name="@param">
						<description>locale the locale for this message format</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the pattern is invalid</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="the pattern for this message format" fulltype="java.lang.String" type="String" />
					<param name="locale" comment="the locale for this message format" fulltype="java.util.Locale" type="Locale" />
				</params>
			</constructor>
			<method visibility="public" name="setLocale" fulltype="void" type="void">
				<comment>
					<description>Sets the locale to be used when creating or comparing subformats.
 This affects subsequent calls
 &lt;ul&gt;
 &lt;li&gt;to the {@link #applyPattern applyPattern}
     and {@link #toPattern toPattern} methods if format elements specify
     a format type and therefore have the subformats created in the
     &lt;code&gt;applyPattern&lt;/code&gt; method, as well as
 &lt;li&gt;to the &lt;code&gt;format&lt;/code&gt; and
     {@link #formatToCharacterIterator formatToCharacterIterator} methods
     if format elements do not specify a format type and therefore have
     the subformats created in the formatting methods.
 &lt;/ul&gt;
 Subformats that have already been created are not affected.</description>
					<attribute name="@param">
						<description>locale the locale to be used when creating or comparing subformats</description>
					</attribute>
				</comment>
				<params>
					<param name="locale" comment="the locale to be used when creating or comparing subformats" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method visibility="public" name="getLocale" returncomment="the locale used when creating or comparing subformats" fulltype="java.util.Locale" type="Locale">
				<comment>
					<description>Gets the locale that&apos;s used when creating or comparing subformats.</description>
					<attribute name="@return">
						<description>the locale used when creating or comparing subformats</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="applyPattern" fulltype="void" type="void">
				<comment>
					<description>Sets the pattern used by this message format.
 The method parses the pattern and creates a list of subformats
 for the format elements contained in it.
 Patterns and their interpretation are specified in the
 &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.</description>
					<attribute name="@param">
						<description>pattern the pattern for this message format</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the pattern is invalid</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="the pattern for this message format" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="toPattern" returncomment="a pattern representing the current state of the message format" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns a pattern representing the current state of the message format.
 The string is constructed from internal information and therefore
 does not necessarily equal the previously applied pattern.</description>
					<attribute name="@return">
						<description>a pattern representing the current state of the message format</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setFormatsByArgumentIndex" fulltype="void" type="void">
				<comment>
					<description>Sets the formats to use for the values passed into
 &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;
 methods. The indices of elements in &lt;code&gt;newFormats&lt;/code&gt;
 correspond to the argument indices used in the previously set
 pattern string.
 The order of formats in &lt;code&gt;newFormats&lt;/code&gt; thus corresponds to
 the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed
 to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned
 by the &lt;code&gt;parse&lt;/code&gt; methods.
 &lt;p&gt;
 If an argument index is used for more than one format element
 in the pattern string, then the corresponding new format is used
 for all such format elements. If an argument index is not used
 for any format element in the pattern string, then the
 corresponding new format is ignored. If fewer formats are provided
 than needed, then only the formats for argument indices less
 than &lt;code&gt;newFormats.length&lt;/code&gt; are replaced.</description>
					<attribute name="@param">
						<description>newFormats the new formats to use</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;newFormats&lt;/code&gt; is null</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="newFormats" comment="the new formats to use" fulltype="java.text.Format[]" type="Format" />
				</params>
			</method>
			<method visibility="public" name="setFormats" fulltype="void" type="void">
				<comment>
					<description>Sets the formats to use for the format elements in the
 previously set pattern string.
 The order of formats in &lt;code&gt;newFormats&lt;/code&gt; corresponds to
 the order of format elements in the pattern string.
 &lt;p&gt;
 If more formats are provided than needed by the pattern string,
 the remaining ones are ignored. If fewer formats are provided
 than needed, then only the first &lt;code&gt;newFormats.length&lt;/code&gt;
 formats are replaced.
 &lt;p&gt;
 Since the order of format elements in a pattern string often
 changes during localization, it is generally better to use the
 {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex}
 method, which assumes an order of formats corresponding to the
 order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to
 the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by
 the &lt;code&gt;parse&lt;/code&gt; methods.</description>
					<attribute name="@param">
						<description>newFormats the new formats to use</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;newFormats&lt;/code&gt; is null</description>
					</attribute>
				</comment>
				<params>
					<param name="newFormats" comment="the new formats to use" fulltype="java.text.Format[]" type="Format" />
				</params>
			</method>
			<method visibility="public" name="setFormatByArgumentIndex" fulltype="void" type="void">
				<comment>
					<description>Sets the format to use for the format elements within the
 previously set pattern string that use the given argument
 index.
 The argument index is part of the format element definition and
 represents an index into the &lt;code&gt;arguments&lt;/code&gt; array passed
 to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned
 by the &lt;code&gt;parse&lt;/code&gt; methods.
 &lt;p&gt;
 If the argument index is used for more than one format element
 in the pattern string, then the new format is used for all such
 format elements. If the argument index is not used for any format
 element in the pattern string, then the new format is ignored.</description>
					<attribute name="@param">
						<description>argumentIndex the argument index for which to use the new format</description>
					</attribute>
					<attribute name="@param">
						<description>newFormat the new format to use</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="argumentIndex" comment="the argument index for which to use the new format" fulltype="int" type="int" />
					<param name="newFormat" comment="the new format to use" fulltype="java.text.Format" type="Format" />
				</params>
			</method>
			<method visibility="public" name="setFormat" fulltype="void" type="void">
				<comment>
					<description>Sets the format to use for the format element with the given
 format element index within the previously set pattern string.
 The format element index is the zero-based number of the format
 element counting from the start of the pattern string.
 &lt;p&gt;
 Since the order of format elements in a pattern string often
 changes during localization, it is generally better to use the
 {@link #setFormatByArgumentIndex setFormatByArgumentIndex}
 method, which accesses format elements based on the argument
 index they specify.</description>
					<attribute name="@param">
						<description>formatElementIndex the index of a format element within the pattern</description>
					</attribute>
					<attribute name="@param">
						<description>newFormat the format to use for the specified format element</description>
					</attribute>
					<attribute name="@exception">
						<description>ArrayIndexOutOfBoundsException if formatElementIndex is equal to or
            larger than the number of format elements in the pattern string</description>
					</attribute>
				</comment>
				<params>
					<param name="formatElementIndex" comment="the index of a format element within the pattern" fulltype="int" type="int" />
					<param name="newFormat" comment="the format to use for the specified format element" fulltype="java.text.Format" type="Format" />
				</params>
			</method>
			<method visibility="public" name="getFormatsByArgumentIndex" returncomment="the formats used for the arguments within the pattern" fulltype="java.text.Format[]" type="Format">
				<comment>
					<description>Gets the formats used for the values passed into
 &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;
 methods. The indices of elements in the returned array
 correspond to the argument indices used in the previously set
 pattern string.
 The order of formats in the returned array thus corresponds to
 the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed
 to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned
 by the &lt;code&gt;parse&lt;/code&gt; methods.
 &lt;p&gt;
 If an argument index is used for more than one format element
 in the pattern string, then the format used for the last such
 format element is returned in the array. If an argument index
 is not used for any format element in the pattern string, then
 null is returned in the array.</description>
					<attribute name="@return">
						<description>the formats used for the arguments within the pattern</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getFormats" returncomment="the formats used for the format elements in the pattern" fulltype="java.text.Format[]" type="Format">
				<comment>
					<description>Gets the formats used for the format elements in the
 previously set pattern string.
 The order of formats in the returned array corresponds to
 the order of format elements in the pattern string.
 &lt;p&gt;
 Since the order of format elements in a pattern string often
 changes during localization, it&apos;s generally better to use the
 {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex}
 method, which assumes an order of formats corresponding to the
 order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to
 the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by
 the &lt;code&gt;parse&lt;/code&gt; methods.</description>
					<attribute name="@return">
						<description>the formats used for the format elements in the pattern</description>
					</attribute>
				</comment>
			</method>
			<method final="true" visibility="public" name="format" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;&apos;s
 pattern, with format elements replaced by the formatted objects, to the
 provided &lt;code&gt;StringBuffer&lt;/code&gt;.
 &lt;p&gt;
 The text substituted for the individual format elements is derived from
 the current subformat of the format element and the
 &lt;code&gt;arguments&lt;/code&gt; element at the format element&apos;s argument index
 as indicated by the first matching line of the following table. An
 argument is &lt;i&gt;unavailable&lt;/i&gt; if &lt;code&gt;arguments&lt;/code&gt; is
 &lt;code&gt;null&lt;/code&gt; or has fewer than argumentIndex+1 elements.
 &lt;p&gt;
 &lt;table border=1 summary=&quot;Examples of subformat,argument,and formatted text&quot;&gt;
    &lt;tr&gt;
       &lt;th&gt;Subformat
       &lt;th&gt;Argument
       &lt;th&gt;Formatted Text
    &lt;tr&gt;
       &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
       &lt;td&gt;&lt;i&gt;unavailable&lt;/i&gt;
       &lt;td&gt;&lt;code&gt;&quot;{&quot; + argumentIndex + &quot;}&quot;&lt;/code&gt;
    &lt;tr&gt;
       &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
       &lt;td&gt;&lt;code&gt;&quot;null&quot;&lt;/code&gt;
    &lt;tr&gt;
       &lt;td&gt;&lt;code&gt;instanceof ChoiceFormat&lt;/code&gt;
       &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
       &lt;td&gt;&lt;code&gt;subformat.format(argument).indexOf(&apos;{&apos;) &gt;= 0 ?&lt;br&gt;
           (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :
           subformat.format(argument)&lt;/code&gt;
    &lt;tr&gt;
       &lt;td&gt;&lt;code&gt;!= null&lt;/code&gt;
       &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
       &lt;td&gt;&lt;code&gt;subformat.format(argument)&lt;/code&gt;
    &lt;tr&gt;
       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
       &lt;td&gt;&lt;code&gt;instanceof Number&lt;/code&gt;
       &lt;td&gt;&lt;code&gt;NumberFormat.getInstance(getLocale()).format(argument)&lt;/code&gt;
    &lt;tr&gt;
       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
       &lt;td&gt;&lt;code&gt;instanceof Date&lt;/code&gt;
       &lt;td&gt;&lt;code&gt;DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)&lt;/code&gt;
    &lt;tr&gt;
       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
       &lt;td&gt;&lt;code&gt;instanceof String&lt;/code&gt;
       &lt;td&gt;&lt;code&gt;argument&lt;/code&gt;
    &lt;tr&gt;
       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
       &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
       &lt;td&gt;&lt;code&gt;argument.toString()&lt;/code&gt;
 &lt;/table&gt;
 &lt;p&gt;
 If &lt;code&gt;pos&lt;/code&gt; is non-null, and refers to
 &lt;code&gt;Field.ARGUMENT&lt;/code&gt;, the location of the first formatted
 string will be returned.</description>
					<attribute name="@param">
						<description>arguments an array of objects to be formatted and substituted.</description>
					</attribute>
					<attribute name="@param">
						<description>result where text is appended.</description>
					</attribute>
					<attribute name="@param">
						<description>pos On input: an alignment field, if desired.
            On output: the offsets of the alignment field.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if an argument in the
            &lt;code&gt;arguments&lt;/code&gt; array is not of the type
            expected by the format element(s) that use it.</description>
					</attribute>
				</comment>
				<params>
					<param name="arguments" comment="an array of objects to be formatted and substituted." fulltype="java.lang.Object[]" type="Object" />
					<param name="result" comment="where text is appended." fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="pos" comment="On input: an alignment field, if desired.
            On output: the offsets of the alignment field." fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method static="true" visibility="public" name="format" fulltype="java.lang.String" type="String">
				<comment>
					<description>Creates a MessageFormat with the given pattern and uses it
 to format the given arguments. This is equivalent to
 &lt;blockquote&gt;
     &lt;code&gt;(new {@link #MessageFormat(String) MessageFormat}(pattern)).{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
 &lt;/blockquote&gt;</description>
					<attribute name="@exception">
						<description>IllegalArgumentException if the pattern is invalid,
            or if an argument in the &lt;code&gt;arguments&lt;/code&gt; array
            is not of the type expected by the format element(s)
            that use it.</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" fulltype="java.lang.String" type="String" />
					<param name="arguments" fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method final="true" visibility="public" name="format" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;&apos;s
 pattern, with format elements replaced by the formatted objects, to the
 provided &lt;code&gt;StringBuffer&lt;/code&gt;.
 This is equivalent to
 &lt;blockquote&gt;
     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[]) arguments, result, pos)&lt;/code&gt;
 &lt;/blockquote&gt;</description>
					<attribute name="@param">
						<description>arguments an array of objects to be formatted and substituted.</description>
					</attribute>
					<attribute name="@param">
						<description>result where text is appended.</description>
					</attribute>
					<attribute name="@param">
						<description>pos On input: an alignment field, if desired.
            On output: the offsets of the alignment field.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if an argument in the
            &lt;code&gt;arguments&lt;/code&gt; array is not of the type
            expected by the format element(s) that use it.</description>
					</attribute>
				</comment>
				<params>
					<param name="arguments" comment="an array of objects to be formatted and substituted." fulltype="java.lang.Object" type="Object" />
					<param name="result" comment="where text is appended." fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="pos" comment="On input: an alignment field, if desired.
            On output: the offsets of the alignment field." fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method visibility="public" name="formatToCharacterIterator" returncomment="AttributedCharacterIterator describing the formatted value." fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
				<comment>
					<description>Formats an array of objects and inserts them into the
 &lt;code&gt;MessageFormat&lt;/code&gt;&apos;s pattern, producing an
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
 You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
 to build the resulting String, as well as to determine information
 about the resulting String.
 &lt;p&gt;
 The text of the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; is
 the same that would be returned by
 &lt;blockquote&gt;
     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
 In addition, the &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; contains at
 least attributes indicating where text was generated from an
 argument in the &lt;code&gt;arguments&lt;/code&gt; array. The keys of these attributes are of
 type &lt;code&gt;MessageFormat.Field&lt;/code&gt;, their values are
 &lt;code&gt;Integer&lt;/code&gt; objects indicating the index in the &lt;code&gt;arguments&lt;/code&gt;
 array of the argument from which the text was generated.
 &lt;p&gt;
 The attributes/value from the underlying &lt;code&gt;Format&lt;/code&gt;
 instances that &lt;code&gt;MessageFormat&lt;/code&gt; uses will also be
 placed in the resulting &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
 This allows you to not only find where an argument is placed in the
 resulting String, but also which fields it contains in turn.</description>
					<attribute name="@param">
						<description>arguments an array of objects to be formatted and substituted.</description>
					</attribute>
					<attribute name="@return">
						<description>AttributedCharacterIterator describing the formatted value.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;arguments&lt;/code&gt; is null.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if an argument in the
            &lt;code&gt;arguments&lt;/code&gt; array is not of the type
            expected by the format element(s) that use it.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="arguments" comment="an array of objects to be formatted and substituted." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="parse" fulltype="java.lang.Object[]" type="Object">
				<comment>
					<description>Parses the string.

 &lt;p&gt;Caveats: The parse may fail in a number of circumstances.
 For example:
 &lt;ul&gt;
 &lt;li&gt;If one of the arguments does not occur in the pattern.
 &lt;li&gt;If the format of an argument loses information, such as
     with a choice format where a large number formats to &quot;many&quot;.
 &lt;li&gt;Does not yet handle recursion (where
     the substituted strings contain {n} references.)
 &lt;li&gt;Will not always find a match (or the correct match)
     if some part of the parse is ambiguous.
     For example, if the pattern &quot;{1},{2}&quot; is used with the
     string arguments {&quot;a,b&quot;, &quot;c&quot;}, it will format as &quot;a,b,c&quot;.
     When the result is parsed, it will return {&quot;a&quot;, &quot;b,c&quot;}.
 &lt;li&gt;If a single argument is parsed more than once in the string,
     then the later parse wins.
 &lt;/ul&gt;
 When the parse fails, use ParsePosition.getErrorIndex() to find out
 where in the string the parsing failed.  The returned error
 index is the starting offset of the sub-patterns that the string
 is comparing with.  For example, if the parsing string &quot;AAA {0} BBB&quot;
 is comparing against the pattern &quot;AAD {0} BBB&quot;, the error index is
 0. When an error occurs, the call to this method will return null.
 If the source is null, return an empty array.</description>
				</comment>
				<params>
					<param name="source" fulltype="java.lang.String" type="String" />
					<param name="pos" fulltype="java.text.ParsePosition" type="ParsePosition" />
				</params>
			</method>
			<method visibility="public" name="parse" returncomment="An &lt;code&gt;Object&lt;/code&gt; array parsed from the string." fulltype="java.lang.Object[]" type="Object">
				<comment>
					<description>Parses text from the beginning of the given string to produce an object
 array.
 The method may not use the entire text of the given string.
 &lt;p&gt;
 See the {@link #parse(String, ParsePosition)} method for more information
 on message parsing.</description>
					<attribute name="@param">
						<description>source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</description>
					</attribute>
					<attribute name="@return">
						<description>An &lt;code&gt;Object&lt;/code&gt; array parsed from the string.</description>
					</attribute>
					<attribute name="@exception">
						<description>ParseException if the beginning of the specified string
            cannot be parsed.</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if the beginning of the specified string
            cannot be parsed." fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
			<method visibility="public" name="parseObject" returncomment="An &lt;code&gt;Object&lt;/code&gt; array parsed from the string. In case of
         error, returns null." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Parses text from a string to produce an object array.
 &lt;p&gt;
 The method attempts to parse text starting at the index given by
 &lt;code&gt;pos&lt;/code&gt;.
 If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
 to the index after the last character used (parsing does not necessarily
 use all characters up to the end of the string), and the parsed
 object array is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
 indicate the starting point for the next call to this method.
 If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
 changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
 the character where the error occurred, and null is returned.
 &lt;p&gt;
 See the {@link #parse(String, ParsePosition)} method for more information
 on message parsing.</description>
					<attribute name="@param">
						<description>source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</description>
					</attribute>
					<attribute name="@param">
						<description>pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
            index information as described above.</description>
					</attribute>
					<attribute name="@return">
						<description>An &lt;code&gt;Object&lt;/code&gt; array parsed from the string. In case of
         error, returns null.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;pos&lt;/code&gt; is null.</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed." fulltype="java.lang.String" type="String" />
					<param name="pos" comment="A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
            index information as described above." fulltype="java.text.ParsePosition" type="ParsePosition" />
				</params>
			</method>
			<method visibility="public" name="clone" returncomment="a clone of this instance." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Creates and returns a copy of this object.</description>
					<attribute name="@return">
						<description>a clone of this instance.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Equality comparison between two message format objects</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Generates a hash code for the message format object.</description>
				</comment>
			</method>
			<method visibility="private" name="subformat" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Internal routine used by format. If &lt;code&gt;characterIterators&lt;/code&gt; is
 non-null, AttributedCharacterIterator will be created from the
 subformats as necessary. If &lt;code&gt;characterIterators&lt;/code&gt; is null
 and &lt;code&gt;fp&lt;/code&gt; is non-null and identifies
 &lt;code&gt;Field.MESSAGE_ARGUMENT&lt;/code&gt;, the location of
 the first replaced argument will be set in it.</description>
					<attribute name="@exception">
						<description>IllegalArgumentException if an argument in the
            &lt;code&gt;arguments&lt;/code&gt; array is not of the type
            expected by the format element(s) that use it.</description>
					</attribute>
				</comment>
				<params>
					<param name="arguments" fulltype="java.lang.Object[]" type="Object" />
					<param name="result" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="fp" fulltype="java.text.FieldPosition" type="FieldPosition" />
					<param name="characterIterators" fulltype="java.util.List" type="List" />
				</params>
			</method>
			<method visibility="private" name="append" fulltype="void" type="void">
				<comment>
					<description>Convenience method to append all the characters in
 &lt;code&gt;iterator&lt;/code&gt; to the StringBuffer &lt;code&gt;result&lt;/code&gt;.</description>
				</comment>
				<params>
					<param name="result" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="iterator" fulltype="java.text.CharacterIterator" type="CharacterIterator" />
				</params>
			</method>
			<method visibility="private" name="makeFormat" fulltype="void" type="void">
				<params>
					<param name="position" fulltype="int" type="int" />
					<param name="offsetNumber" fulltype="int" type="int" />
					<param name="segments" fulltype="java.lang.StringBuffer[]" type="StringBuffer" />
				</params>
			</method>
			<method final="true" static="true" visibility="private" name="findKeyword" fulltype="int" type="int">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="list" fulltype="java.lang.String[]" type="String" />
				</params>
			</method>
			<method final="true" static="true" visibility="private" name="copyAndFixQuotes" fulltype="void" type="void">
				<params>
					<param name="source" fulltype="java.lang.String" type="String" />
					<param name="start" fulltype="int" type="int" />
					<param name="end" fulltype="int" type="int" />
					<param name="target" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<comment>
					<description>After reading an object from the input stream, do a simple verification
 to maintain class invariants.</description>
					<attribute name="@throws">
						<description>InvalidObjectException if the objects read from the stream is invalid.</description>
					</attribute>
				</comment>
				<params>
					<param name="in" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
		<jelclass superclass="Format.Field" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.Format.Field" fulltype="java.text.MessageFormat.Field" type="MessageFormat.Field">
			<comment>
				<description>Defines constants that are used as attribute keys in the
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
 from &lt;code&gt;MessageFormat.formatToCharacterIterator&lt;/code&gt;.</description>
				<attribute name="@since">
					<description>1.4</description>
				</attribute>
			</comment>
			<fields>
				<field final="true" static="true" const="7899943957617360810" visibility="private" name="serialVersionUID" constexpr="7899943957617360810L" fulltype="long" type="long" />
				<field final="true" static="true" visibility="public" name="ARGUMENT" fulltype="java.text.MessageFormat.Field" type="MessageFormat.Field">
					<comment>
						<description>Constant identifying a portion of a message that was generated
 from an argument passed into &lt;code&gt;formatToCharacterIterator&lt;/code&gt;.
 The value associated with the key will be an &lt;code&gt;Integer&lt;/code&gt;
 indicating the index in the &lt;code&gt;arguments&lt;/code&gt; array of the
 argument from which the text was generated.</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="protected" name="MessageFormat.Field">
					<comment>
						<description>Creates a Field with the specified name.</description>
						<attribute name="@param">
							<description>name Name of the attribute</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="Name of the attribute" fulltype="java.lang.String" type="String" />
					</params>
				</constructor>
				<method visibility="protected" name="readResolve" returncomment="resolved MessageFormat.Field constant" fulltype="java.lang.Object" type="Object">
					<comment>
						<description>Resolves instances being deserialized to the predefined constants.</description>
						<attribute name="@throws">
							<description>InvalidObjectException if the constant could not be
         resolved.</description>
						</attribute>
						<attribute name="@return">
							<description>resolved MessageFormat.Field constant</description>
						</attribute>
					</comment>
					<exceptions>
						<exception comment="if the constant could not be
         resolved." fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
					</exceptions>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Format.Field" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.Format.Field" fulltype="java.text.MessageFormat.Field" type="MessageFormat.Field">
		<comment>
			<description>Defines constants that are used as attribute keys in the
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
 from &lt;code&gt;MessageFormat.formatToCharacterIterator&lt;/code&gt;.</description>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="7899943957617360810" visibility="private" name="serialVersionUID" constexpr="7899943957617360810L" fulltype="long" type="long" />
			<field final="true" static="true" visibility="public" name="ARGUMENT" fulltype="java.text.MessageFormat.Field" type="MessageFormat.Field">
				<comment>
					<description>Constant identifying a portion of a message that was generated
 from an argument passed into &lt;code&gt;formatToCharacterIterator&lt;/code&gt;.
 The value associated with the key will be an &lt;code&gt;Integer&lt;/code&gt;
 indicating the index in the &lt;code&gt;arguments&lt;/code&gt; array of the
 argument from which the text was generated.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="protected" name="MessageFormat.Field">
				<comment>
					<description>Creates a Field with the specified name.</description>
					<attribute name="@param">
						<description>name Name of the attribute</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="Name of the attribute" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method visibility="protected" name="readResolve" returncomment="resolved MessageFormat.Field constant" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Resolves instances being deserialized to the predefined constants.</description>
					<attribute name="@throws">
						<description>InvalidObjectException if the constant could not be
         resolved.</description>
					</attribute>
					<attribute name="@return">
						<description>resolved MessageFormat.Field constant</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the constant could not be
         resolved." fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.text" interface="true" fulltype="java.text.CharacterIterator" type="CharacterIterator">
		<implements>
			<interface fulltype="java.lang.Cloneable" type="Cloneable" />
		</implements>
		<comment>
			<description>This interface defines a protocol for bidirectional iteration over text.
 The iterator iterates over a bounded sequence of characters.  Characters
 are indexed with values beginning with the value returned by getBeginIndex() and
 continuing through the value returned by getEndIndex()-1.
 &lt;p&gt;
 Iterators maintain a current character index, whose valid range is from
 getBeginIndex() to getEndIndex(); the value getEndIndex() is included to allow
 handling of zero-length text ranges and for historical reasons.
 The current index can be retrieved by calling getIndex() and set directly
 by calling setIndex(), first(), and last().
 &lt;p&gt;
 The methods previous() and next() are used for iteration. They return DONE if
 they would move outside the range from getBeginIndex() to getEndIndex() -1,
 signaling that the iterator has reached the end of the sequence. DONE is
 also returned by other methods to indicate that the current index is
 outside this range.

 &lt;P&gt;Examples:&lt;P&gt;

 Traverse the text from start to finish
 &lt;pre&gt;
 public void traverseForward(CharacterIterator iter) {
     for(char c = iter.first(); c != CharacterIterator.DONE; c = iter.next()) {
         processChar(c);
     }
 }
 &lt;/pre&gt;

 Traverse the text backwards, from end to start
 &lt;pre&gt;
 public void traverseBackward(CharacterIterator iter) {
     for(char c = iter.last(); c != CharacterIterator.DONE; c = iter.previous()) {
         processChar(c);
     }
 }
 &lt;/pre&gt;

 Traverse both forward and backward from a given position in the text.
 Calls to notBoundary() in this example represents some
 additional stopping criteria.
 &lt;pre&gt;
 public void traverseOut(CharacterIterator iter, int pos) {
     for (char c = iter.setIndex(pos);
              c != CharacterIterator.DONE &amp;&amp; notBoundary(c);
              c = iter.next()) {
     }
     int end = iter.getIndex();
     for (char c = iter.setIndex(pos);
             c != CharacterIterator.DONE &amp;&amp; notBoundary(c);
             c = iter.previous()) {
     }
     int start = iter.getIndex();
     processSection(start, end);
 }
 &lt;/pre&gt;</description>
			<attribute name="@see">
				<description>StringCharacterIterator</description>
			</attribute>
			<attribute name="@see">
				<description>AttributedCharacterIterator</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="65535" visibility="public" name="DONE" constexpr="65535" fulltype="char" type="char">
				<comment>
					<description>Constant that is returned when the iterator has reached either the end
 or the beginning of the text. The value is &apos;\\uFFFF&apos;, the &quot;not a
 character&quot; value which should not occur in any valid Unicode string.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<method visibility="public" name="first" returncomment="the first character in the text, or DONE if the text is empty" fulltype="char" type="char">
				<comment>
					<description>Sets the position to getBeginIndex() and returns the character at that
 position.</description>
					<attribute name="@return">
						<description>the first character in the text, or DONE if the text is empty</description>
					</attribute>
					<attribute name="@see">
						<description>#getBeginIndex()</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="last" returncomment="the last character in the text, or DONE if the text is empty" fulltype="char" type="char">
				<comment>
					<description>Sets the position to getEndIndex()-1 (getEndIndex() if the text is empty)
 and returns the character at that position.</description>
					<attribute name="@return">
						<description>the last character in the text, or DONE if the text is empty</description>
					</attribute>
					<attribute name="@see">
						<description>#getEndIndex()</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="current" returncomment="the character at the current position or DONE if the current
 position is off the end of the text." fulltype="char" type="char">
				<comment>
					<description>Gets the character at the current position (as returned by getIndex()).</description>
					<attribute name="@return">
						<description>the character at the current position or DONE if the current
 position is off the end of the text.</description>
					</attribute>
					<attribute name="@see">
						<description>#getIndex()</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="next" returncomment="the character at the new position or DONE if the new
 position is off the end of the text range." fulltype="char" type="char">
				<comment>
					<description>Increments the iterator&apos;s index by one and returns the character
 at the new index.  If the resulting index is greater or equal
 to getEndIndex(), the current index is reset to getEndIndex() and
 a value of DONE is returned.</description>
					<attribute name="@return">
						<description>the character at the new position or DONE if the new
 position is off the end of the text range.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="previous" returncomment="the character at the new position or DONE if the current
 position is equal to getBeginIndex()." fulltype="char" type="char">
				<comment>
					<description>Decrements the iterator&apos;s index by one and returns the character
 at the new index. If the current index is getBeginIndex(), the index
 remains at getBeginIndex() and a value of DONE is returned.</description>
					<attribute name="@return">
						<description>the character at the new position or DONE if the current
 position is equal to getBeginIndex().</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setIndex" returncomment="the character at the specified position or DONE if the specified position is equal to getEndIndex()" fulltype="char" type="char">
				<comment>
					<description>Sets the position to the specified position in the text and returns that
 character.</description>
					<attribute name="@param">
						<description>position the position within the text.  Valid values range from
 getBeginIndex() to getEndIndex().  An IllegalArgumentException is thrown
 if an invalid value is supplied.</description>
					</attribute>
					<attribute name="@return">
						<description>the character at the specified position or DONE if the specified position is equal to getEndIndex()</description>
					</attribute>
				</comment>
				<params>
					<param name="position" comment="the position within the text.  Valid values range from
 getBeginIndex() to getEndIndex().  An IllegalArgumentException is thrown
 if an invalid value is supplied." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getBeginIndex" returncomment="the index at which the text begins." fulltype="int" type="int">
				<comment>
					<description>Returns the start index of the text.</description>
					<attribute name="@return">
						<description>the index at which the text begins.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getEndIndex" returncomment="the index after the last character in the text" fulltype="int" type="int">
				<comment>
					<description>Returns the end index of the text.  This index is the index of the first
 character following the end of the text.</description>
					<attribute name="@return">
						<description>the index after the last character in the text</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getIndex" returncomment="the current index." fulltype="int" type="int">
				<comment>
					<description>Returns the current index.</description>
					<attribute name="@return">
						<description>the current index.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="clone" returncomment="A copy of this" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Create a copy of this iterator</description>
					<attribute name="@return">
						<description>A copy of this</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="public" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.CollationElementIterator" type="CollationElementIterator">
		<comment>
			<description>The &lt;code&gt;CollationElementIterator&lt;/code&gt; class is used as an iterator
 to walk through each character of an international string. Use the iterator
 to return the ordering priority of the positioned character. The ordering
 priority of a character, which we refer to as a key, defines how a character
 is collated in the given collation object.

 &lt;p&gt;
 For example, consider the following in Spanish:
 &lt;blockquote&gt;
 &lt;pre&gt;
 &quot;ca&quot; -&gt; the first key is key(&apos;c&apos;) and second key is key(&apos;a&apos;).
 &quot;cha&quot; -&gt; the first key is key(&apos;ch&apos;) and second key is key(&apos;a&apos;).
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 And in German,
 &lt;blockquote&gt;
 &lt;pre&gt;
 &quot;b&quot;-&gt; the first key is key(&apos;a&apos;), the second key is key(&apos;e&apos;), and
 the third key is key(&apos;b&apos;).
 &lt;/pre&gt;
 &lt;/blockquote&gt;
 The key of a character is an integer composed of primary order(short),
 secondary order(byte), and tertiary order(byte). Java strictly defines
 the size and signedness of its primitive data types. Therefore, the static
 functions &lt;code&gt;primaryOrder&lt;/code&gt;, &lt;code&gt;secondaryOrder&lt;/code&gt;, and
 &lt;code&gt;tertiaryOrder&lt;/code&gt; return &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;,
 and &lt;code&gt;short&lt;/code&gt; respectively to ensure the correctness of the key
 value.

 &lt;p&gt;
 Example of the iterator usage,
 &lt;blockquote&gt;
 &lt;pre&gt;

  String testString = &quot;This is a test&quot;;
  RuleBasedCollator ruleBasedCollator = (RuleBasedCollator)Collator.getInstance();
  CollationElementIterator collationElementIterator = ruleBasedCollator.getCollationElementIterator(testString);
  int primaryOrder = CollationElementIterator.primaryOrder(collationElementIterator.next());
 &lt;/pre&gt;
 &lt;/blockquote&gt;

 &lt;p&gt;
 &lt;code&gt;CollationElementIterator.next&lt;/code&gt; returns the collation order
 of the next character. A collation order consists of primary order,
 secondary order and tertiary order. The data type of the collation
 order is &lt;strong&gt;int&lt;/strong&gt;. The first 16 bits of a collation order
 is its primary order; the next 8 bits is the secondary order and the
 last 8 bits is the tertiary order.</description>
			<attribute name="@see">
				<description>Collator</description>
			</attribute>
			<attribute name="@see">
				<description>RuleBasedCollator</description>
			</attribute>
			<attribute name="@author">
				<description>Helena Shih, Laura Werner, Richard Gillam</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-1" visibility="public" name="NULLORDER" constexpr="-1" fulltype="int" type="int">
				<comment>
					<description>Null order which indicates the end of string is reached by the
 cursor.</description>
				</comment>
			</field>
			<field final="true" static="true" const="2147418112" visibility="package-private" name="UNMAPPEDCHARVALUE" constexpr="2147418112" fulltype="int" type="int" />
			<field visibility="private" name="text" fulltype="NormalizerBase" type="NormalizerBase" />
			<field visibility="private" name="buffer" fulltype="int[]" type="int" />
			<field visibility="private" name="expIndex" fulltype="int" type="int" />
			<field visibility="private" name="key" fulltype="java.lang.StringBuffer" type="StringBuffer" />
			<field visibility="private" name="swapOrder" fulltype="int" type="int" />
			<field visibility="private" name="ordering" fulltype="java.text.RBCollationTables" type="RBCollationTables" />
			<field visibility="private" name="owner" fulltype="java.text.RuleBasedCollator" type="RuleBasedCollator" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="CollationElementIterator">
				<comment>
					<description>CollationElementIterator constructor.  This takes the source string and
 the collation object.  The cursor will walk thru the source string based
 on the predefined collation rules.  If the source string is empty,
 NULLORDER will be returned on the calls to next().</description>
					<attribute name="@param">
						<description>sourceText the source string.</description>
					</attribute>
					<attribute name="@param">
						<description>order the collation object.</description>
					</attribute>
				</comment>
				<params>
					<param name="sourceText" comment="the source string." fulltype="java.lang.String" type="String" />
					<param name="owner" fulltype="java.text.RuleBasedCollator" type="RuleBasedCollator" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="CollationElementIterator">
				<comment>
					<description>CollationElementIterator constructor.  This takes the source string and
 the collation object.  The cursor will walk thru the source string based
 on the predefined collation rules.  If the source string is empty,
 NULLORDER will be returned on the calls to next().</description>
					<attribute name="@param">
						<description>sourceText the source string.</description>
					</attribute>
					<attribute name="@param">
						<description>order the collation object.</description>
					</attribute>
				</comment>
				<params>
					<param name="sourceText" comment="the source string." fulltype="java.text.CharacterIterator" type="CharacterIterator" />
					<param name="owner" fulltype="java.text.RuleBasedCollator" type="RuleBasedCollator" />
				</params>
			</constructor>
			<method visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Resets the cursor to the beginning of the string.  The next call
 to next() will return the first collation element in the string.</description>
				</comment>
			</method>
			<method visibility="public" name="next" fulltype="int" type="int">
				<comment>
					<description>Get the next collation element in the string.  &lt;p&gt;This iterator iterates
 over a sequence of collation elements that were built from the string.
 Because there isn&apos;t necessarily a one-to-one mapping from characters to
 collation elements, this doesn&apos;t mean the same thing as &quot;return the
 collation element [or ordering priority] of the next character in the
 string&quot;.&lt;/p&gt;
 &lt;p&gt;This function returns the collation element that the iterator is currently
 pointing to and then updates the internal pointer to point to the next element.
 previous() updates the pointer first and then returns the element.  This
 means that when you change direction while iterating (i.e., call next() and
 then call previous(), or call previous() and then call next()), you&apos;ll get
 back the same element twice.&lt;/p&gt;</description>
				</comment>
			</method>
			<method visibility="public" name="previous" fulltype="int" type="int">
				<comment>
					<description>Get the previous collation element in the string.  &lt;p&gt;This iterator iterates
 over a sequence of collation elements that were built from the string.
 Because there isn&apos;t necessarily a one-to-one mapping from characters to
 collation elements, this doesn&apos;t mean the same thing as &quot;return the
 collation element [or ordering priority] of the previous character in the
 string&quot;.&lt;/p&gt;
 &lt;p&gt;This function updates the iterator&apos;s internal pointer to point to the
 collation element preceding the one it&apos;s currently pointing to and then
 returns that element, while next() returns the current element and then
 updates the pointer.  This means that when you change direction while
 iterating (i.e., call next() and then call previous(), or call previous()
 and then call next()), you&apos;ll get back the same element twice.&lt;/p&gt;</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method final="true" static="true" visibility="public" name="primaryOrder" returncomment="the element&apos;s primary component" fulltype="int" type="int">
				<comment>
					<description>Return the primary component of a collation element.</description>
					<attribute name="@param">
						<description>order the collation element</description>
					</attribute>
					<attribute name="@return">
						<description>the element&apos;s primary component</description>
					</attribute>
				</comment>
				<params>
					<param name="order" comment="the collation element" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="secondaryOrder" returncomment="the element&apos;s secondary component" fulltype="short" type="short">
				<comment>
					<description>Return the secondary component of a collation element.</description>
					<attribute name="@param">
						<description>order the collation element</description>
					</attribute>
					<attribute name="@return">
						<description>the element&apos;s secondary component</description>
					</attribute>
				</comment>
				<params>
					<param name="order" comment="the collation element" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="tertiaryOrder" returncomment="the element&apos;s tertiary component" fulltype="short" type="short">
				<comment>
					<description>Return the tertiary component of a collation element.</description>
					<attribute name="@param">
						<description>order the collation element</description>
					</attribute>
					<attribute name="@return">
						<description>the element&apos;s tertiary component</description>
					</attribute>
				</comment>
				<params>
					<param name="order" comment="the collation element" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="package-private" name="strengthOrder" fulltype="int" type="int">
				<comment>
					<description>Get the comparison order in the desired strength.  Ignore the other
  differences.</description>
					<attribute name="@param">
						<description>order The order value</description>
					</attribute>
				</comment>
				<params>
					<param name="order" comment="The order value" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="setOffset" fulltype="void" type="void">
				<comment>
					<description>Sets the iterator to point to the collation element corresponding to
 the specified character (the parameter is a CHARACTER offset in the
 original string, not an offset into its corresponding sequence of
 collation elements).  The value returned by the next call to next()
 will be the collation element corresponding to the specified position
 in the text.  If that position is in the middle of a contracting
 character sequence, the result of the next call to next() is the
 collation element for that sequence.  This means that getOffset()
 is not guaranteed to return the same value as was passed to a preceding
 call to setOffset().</description>
					<attribute name="@param">
						<description>newOffset The new character offset into the original text.</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="newOffset" comment="The new character offset into the original text." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getOffset" returncomment="The character offset in the original text corresponding to the collation
 element that will be returned by the next call to next()." fulltype="int" type="int">
				<comment>
					<description>Returns the character offset in the original text corresponding to the next
 collation element.  (That is, getOffset() returns the position in the text
 corresponding to the collation element that will be returned by the next
 call to next().)  This value will always be the index of the FIRST character
 corresponding to the collation element (a contracting character sequence is
 when two or more characters all correspond to the same collation element).
 This means if you do setOffset(x) followed immediately by getOffset(), getOffset()
 won&apos;t necessarily return x.</description>
					<attribute name="@return">
						<description>The character offset in the original text corresponding to the collation
 element that will be returned by the next call to next().</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getMaxExpansion" returncomment="the maximum length of any expansion sequences ending
         with the specified order." fulltype="int" type="int">
				<comment>
					<description>Return the maximum length of any expansion sequences that end
 with the specified comparison order.</description>
					<attribute name="@param">
						<description>order a collation order returned by previous or next.</description>
					</attribute>
					<attribute name="@return">
						<description>the maximum length of any expansion sequences ending
         with the specified order.</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="order" comment="a collation order returned by previous or next." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="setText" fulltype="void" type="void">
				<comment>
					<description>Set a new string over which to iterate.</description>
					<attribute name="@param">
						<description>source  the new source text</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="the new source text" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="setText" fulltype="void" type="void">
				<comment>
					<description>Set a new string over which to iterate.</description>
					<attribute name="@param">
						<description>source  the new source text.</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="the new source text." fulltype="java.text.CharacterIterator" type="CharacterIterator" />
				</params>
			</method>
			<method final="true" static="true" visibility="private" name="isThaiPreVowel" fulltype="boolean" type="boolean">
				<comment>
					<description>Determine if a character is a Thai vowel (which sorts after
 its base consonant).</description>
				</comment>
				<params>
					<param name="ch" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" static="true" visibility="private" name="isThaiBaseConsonant" fulltype="boolean" type="boolean">
				<comment>
					<description>Determine if a character is a Thai base consonant</description>
				</comment>
				<params>
					<param name="ch" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" static="true" visibility="private" name="isLaoPreVowel" fulltype="boolean" type="boolean">
				<comment>
					<description>Determine if a character is a Lao vowel (which sorts after
 its base consonant).</description>
				</comment>
				<params>
					<param name="ch" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" static="true" visibility="private" name="isLaoBaseConsonant" fulltype="boolean" type="boolean">
				<comment>
					<description>Determine if a character is a Lao base consonant</description>
				</comment>
				<params>
					<param name="ch" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="makeReorderedBuffer" fulltype="int[]" type="int">
				<comment>
					<description>This method produces a buffer which contains the collation
 elements for the two characters, with colFirst&apos;s values preceding
 another character&apos;s.  Presumably, the other character precedes colFirst
 in logical order (otherwise you wouldn&apos;t need this method would you?).
 The assumption is that the other char&apos;s value(s) have already been
 computed.  If this char has a single element it is passed to this
 method as lastValue, and lastExpansion is null.  If it has an
 expansion it is passed in lastExpansion, and colLastValue is ignored.</description>
				</comment>
				<params>
					<param name="colFirst" fulltype="int" type="int" />
					<param name="lastValue" fulltype="int" type="int" />
					<param name="lastExpansion" fulltype="int[]" type="int" />
					<param name="forward" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method final="true" static="true" visibility="package-private" name="isIgnorable" returncomment="true if a character is ignorable, false otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Check if a comparison order is ignorable.</description>
					<attribute name="@return">
						<description>true if a character is ignorable, false otherwise.</description>
					</attribute>
				</comment>
				<params>
					<param name="order" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="nextContractChar" returncomment="the next contracting character&apos;s ordering.  Returns NULLORDER
 if the end of string is reached." fulltype="int" type="int">
				<comment>
					<description>Get the ordering priority of the next contracting character in the
 string.</description>
					<attribute name="@param">
						<description>ch the starting character of a contracting character token</description>
					</attribute>
					<attribute name="@return">
						<description>the next contracting character&apos;s ordering.  Returns NULLORDER
 if the end of string is reached.</description>
					</attribute>
				</comment>
				<params>
					<param name="ch" comment="the starting character of a contracting character token" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="prevContractChar" returncomment="the next contracting character&apos;s ordering.  Returns NULLORDER
 if the end of string is reached." fulltype="int" type="int">
				<comment>
					<description>Get the ordering priority of the previous contracting character in the
 string.</description>
					<attribute name="@param">
						<description>ch the starting character of a contracting character token</description>
					</attribute>
					<attribute name="@return">
						<description>the next contracting character&apos;s ordering.  Returns NULLORDER
 if the end of string is reached.</description>
					</attribute>
				</comment>
				<params>
					<param name="ch" comment="the starting character of a contracting character token" fulltype="int" type="int" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.text" interface="true" fulltype="java.text.AttributedCharacterIterator" type="AttributedCharacterIterator">
		<implements>
			<interface fulltype="java.text.CharacterIterator" type="CharacterIterator" />
		</implements>
		<comment>
			<description>An AttributedCharacterIterator allows iteration through both text and
 related attribute information.

 &lt;p&gt;
 An attribute is a key/value pair, identified by the key.  No two
 attributes on a given character can have the same key.

 &lt;p&gt;The values for an attribute are immutable, or must not be mutated
 by clients or storage.  They are always passed by reference, and not
 cloned.

 &lt;p&gt;A &lt;em&gt;run with respect to an attribute&lt;/em&gt; is a maximum text range for
 which:
 &lt;ul&gt;
 &lt;li&gt;the attribute is undefined or null for the entire range, or
 &lt;li&gt;the attribute value is defined and has the same non-null value for the
     entire range.
 &lt;/ul&gt;

 &lt;p&gt;A &lt;em&gt;run with respect to a set of attributes&lt;/em&gt; is a maximum text range for
 which this condition is met for each member attribute.

 &lt;p&gt;The returned indexes are limited to the range of the iterator.

 &lt;p&gt;The returned attribute information is limited to runs that contain
 the current character.

 &lt;p&gt;
 Attribute keys are instances of AttributedCharacterIterator.Attribute and its
 subclasses, such as java.awt.font.TextAttribute.</description>
			<attribute name="@see">
				<description>AttributedCharacterIterator.Attribute</description>
			</attribute>
			<attribute name="@see">
				<description>java.awt.font.TextAttribute</description>
			</attribute>
			<attribute name="@see">
				<description>AttributedString</description>
			</attribute>
			<attribute name="@see">
				<description>Annotation</description>
			</attribute>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="getRunStart" fulltype="int" type="int">
				<comment>
					<description>Returns the index of the first character of the run
 with respect to all attributes containing the current character.</description>
				</comment>
			</method>
			<method visibility="public" name="getRunStart" fulltype="int" type="int">
				<comment>
					<description>Returns the index of the first character of the run
 with respect to the given attribute containing the current character.</description>
				</comment>
				<params>
					<param name="attribute" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
				</params>
			</method>
			<method visibility="public" name="getRunStart" fulltype="int" type="int">
				<comment>
					<description>Returns the index of the first character of the run
 with respect to the given attributes containing the current character.</description>
				</comment>
				<params>
					<param name="attributes" fulltype="java.util.Set" type="Set" />
				</params>
			</method>
			<method visibility="public" name="getRunLimit" fulltype="int" type="int">
				<comment>
					<description>Returns the index of the first character following the run
 with respect to all attributes containing the current character.</description>
				</comment>
			</method>
			<method visibility="public" name="getRunLimit" fulltype="int" type="int">
				<comment>
					<description>Returns the index of the first character following the run
 with respect to the given attribute containing the current character.</description>
				</comment>
				<params>
					<param name="attribute" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
				</params>
			</method>
			<method visibility="public" name="getRunLimit" fulltype="int" type="int">
				<comment>
					<description>Returns the index of the first character following the run
 with respect to the given attributes containing the current character.</description>
				</comment>
				<params>
					<param name="attributes" fulltype="java.util.Set" type="Set" />
				</params>
			</method>
			<method visibility="public" name="getAttributes" fulltype="java.util.Map" type="Map">
				<comment>
					<description>Returns a map with the attributes defined on the current
 character.</description>
				</comment>
			</method>
			<method visibility="public" name="getAttribute" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Returns the value of the named attribute for the current character.
 Returns null if the attribute is not defined.</description>
					<attribute name="@param">
						<description>attribute the key of the attribute whose value is requested.</description>
					</attribute>
				</comment>
				<params>
					<param name="attribute" comment="the key of the attribute whose value is requested." fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute" />
				</params>
			</method>
			<method visibility="public" name="getAllAttributeKeys" fulltype="java.util.Set" type="Set">
				<comment>
					<description>Returns the keys of all attributes defined on the
 iterator&apos;s text range. The set is empty if no
 attributes are defined.</description>
				</comment>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="public" package="java.text" serializable="true" superclassfulltype="java.lang.Object" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute">
			<implements>
				<interface fulltype="java.io.Serializable" type="Serializable" />
			</implements>
			<comment>
				<description>Defines attribute keys that are used to identify text attributes. These
 keys are used in AttributedCharacterIterator and AttributedString.</description>
				<attribute name="@see">
					<description>AttributedCharacterIterator</description>
				</attribute>
				<attribute name="@see">
					<description>AttributedString</description>
				</attribute>
				<attribute name="@since">
					<description>1.2</description>
				</attribute>
			</comment>
			<fields>
				<field visibility="private" name="name" fulltype="java.lang.String" type="String">
					<comment>
						<description>The name of this Attribute. The name is used primarily by readResolve
 to look up the corresponding predefined instance when deserializing
 an instance.</description>
						<attribute name="@serial" />
					</comment>
				</field>
				<field final="true" static="true" visibility="private" name="instanceMap" fulltype="java.util.Map" type="Map" />
				<field final="true" static="true" visibility="public" name="LANGUAGE" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute">
					<comment>
						<description>Attribute key for the language of some text.
 &lt;p&gt; Values are instances of Locale.</description>
						<attribute name="@see">
							<description>java.util.Locale</description>
						</attribute>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="READING" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute">
					<comment>
						<description>Attribute key for the reading of some text. In languages where the written form
 and the pronunciation of a word are only loosely related (such as Japanese),
 it is often necessary to store the reading (pronunciation) along with the
 written form.
 &lt;p&gt;Values are instances of Annotation holding instances of String.</description>
						<attribute name="@see">
							<description>Annotation</description>
						</attribute>
						<attribute name="@see">
							<description>java.lang.String</description>
						</attribute>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="INPUT_METHOD_SEGMENT" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute">
					<comment>
						<description>Attribute key for input method segments. Input methods often break
 up text into segments, which usually correspond to words.
 &lt;p&gt;Values are instances of Annotation holding a null reference.</description>
						<attribute name="@see">
							<description>Annotation</description>
						</attribute>
					</comment>
				</field>
				<field final="true" static="true" const="-9142742483513960612" visibility="private" name="serialVersionUID" constexpr="-9142742483513960612L" fulltype="long" type="long" />
			</fields>
			<methods>
				<constructor visibility="protected" name="AttributedCharacterIterator.Attribute">
					<comment>
						<description>Constructs an Attribute with the given name.</description>
					</comment>
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
					</params>
				</constructor>
				<method final="true" visibility="public" name="equals" fulltype="boolean" type="boolean">
					<comment>
						<description>Compares two objects for equality. This version only returns true
 for &lt;code&gt;x.equals(y)&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; refer
 to the same object, and guarantees this for all subclasses.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
				<method final="true" visibility="public" name="hashCode" fulltype="int" type="int">
					<comment>
						<description>Returns a hash code value for the object. This version is identical to
 the one in Object, but is also final.</description>
					</comment>
				</method>
				<method visibility="public" name="toString" fulltype="java.lang.String" type="String">
					<comment>
						<description>Returns a string representation of the object. This version returns the
 concatenation of class name, &quot;(&quot;, a name identifying the attribute and &quot;)&quot;.</description>
					</comment>
				</method>
				<method visibility="protected" name="getName" fulltype="java.lang.String" type="String">
					<comment>
						<description>Returns the name of the attribute.</description>
					</comment>
				</method>
				<method visibility="protected" name="readResolve" fulltype="java.lang.Object" type="Object">
					<comment>
						<description>Resolves instances being deserialized to the predefined constants.</description>
					</comment>
					<exceptions>
						<exception fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
					</exceptions>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.text" serializable="true" superclassfulltype="java.lang.Object" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
		</implements>
		<comment>
			<description>Defines attribute keys that are used to identify text attributes. These
 keys are used in AttributedCharacterIterator and AttributedString.</description>
			<attribute name="@see">
				<description>AttributedCharacterIterator</description>
			</attribute>
			<attribute name="@see">
				<description>AttributedString</description>
			</attribute>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="name" fulltype="java.lang.String" type="String">
				<comment>
					<description>The name of this Attribute. The name is used primarily by readResolve
 to look up the corresponding predefined instance when deserializing
 an instance.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="instanceMap" fulltype="java.util.Map" type="Map" />
			<field final="true" static="true" visibility="public" name="LANGUAGE" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute">
				<comment>
					<description>Attribute key for the language of some text.
 &lt;p&gt; Values are instances of Locale.</description>
					<attribute name="@see">
						<description>java.util.Locale</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="READING" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute">
				<comment>
					<description>Attribute key for the reading of some text. In languages where the written form
 and the pronunciation of a word are only loosely related (such as Japanese),
 it is often necessary to store the reading (pronunciation) along with the
 written form.
 &lt;p&gt;Values are instances of Annotation holding instances of String.</description>
					<attribute name="@see">
						<description>Annotation</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.String</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="INPUT_METHOD_SEGMENT" fulltype="java.text.AttributedCharacterIterator.Attribute" type="AttributedCharacterIterator.Attribute">
				<comment>
					<description>Attribute key for input method segments. Input methods often break
 up text into segments, which usually correspond to words.
 &lt;p&gt;Values are instances of Annotation holding a null reference.</description>
					<attribute name="@see">
						<description>Annotation</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="-9142742483513960612" visibility="private" name="serialVersionUID" constexpr="-9142742483513960612L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="protected" name="AttributedCharacterIterator.Attribute">
				<comment>
					<description>Constructs an Attribute with the given name.</description>
				</comment>
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method final="true" visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Compares two objects for equality. This version only returns true
 for &lt;code&gt;x.equals(y)&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; refer
 to the same object, and guarantees this for all subclasses.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method final="true" visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Returns a hash code value for the object. This version is identical to
 the one in Object, but is also final.</description>
				</comment>
			</method>
			<method visibility="public" name="toString" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns a string representation of the object. This version returns the
 concatenation of class name, &quot;(&quot;, a name identifying the attribute and &quot;)&quot;.</description>
				</comment>
			</method>
			<method visibility="protected" name="getName" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the name of the attribute.</description>
				</comment>
			</method>
			<method visibility="protected" name="readResolve" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Resolves instances being deserialized to the predefined constants.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.MergeCollation" type="MergeCollation">
		<comment>
			<description>Utility class for normalizing and merging patterns for collation.
 Patterns are strings of the form &lt;entry&gt;*, where &lt;entry&gt; has the
 form:
 &lt;pattern&gt; := &lt;entry&gt;*
 &lt;entry&gt; := &lt;separator&gt;&lt;chars&gt;{&quot;/&quot;&lt;extension&gt;}
 &lt;separator&gt; := &quot;=&quot;, &quot;,&quot;, &quot;;&quot;, &quot;&lt;&quot;, &quot;&amp;&quot;
 &lt;chars&gt;, and &lt;extension&gt; are both arbitrary strings.
 unquoted whitespaces are ignored.
 &apos;xxx&apos; can be used to quote characters
 One difference from Collator is that &amp; is used to reset to a current
 point. Or, in other words, it introduces a new sequence which is to
 be added to the old.
 That is: &quot;a &lt; b &lt; c &lt; d&quot; is the same as &quot;a &lt; b &amp; b &lt; c &amp; c &lt; d&quot; OR
 &quot;a &lt; b &lt; d &amp; b &lt; c&quot;
 XXX: make &apos;&apos; be a single quote.</description>
			<attribute name="@see">
				<description>PatternEntry</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Davis, Helena Shih</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="patterns" fulltype="java.util.ArrayList" type="ArrayList" />
			<field visibility="private" transient="true" name="saveEntry" fulltype="java.text.PatternEntry" type="PatternEntry" />
			<field visibility="private" transient="true" name="lastEntry" fulltype="java.text.PatternEntry" type="PatternEntry" />
			<field visibility="private" transient="true" name="excess" fulltype="java.lang.StringBuffer" type="StringBuffer" />
			<field visibility="private" transient="true" name="statusArray" fulltype="byte[]" type="byte" />
			<field final="true" const="1" visibility="private" name="BITARRAYMASK" constexpr="1" fulltype="byte" type="byte" />
			<field final="true" const="3" visibility="private" name="BYTEPOWER" constexpr="3" fulltype="int" type="int" />
			<field final="true" const="7" visibility="private" name="BYTEMASK" constexpr="7" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="public" name="MergeCollation">
				<comment>
					<description>Creates from a pattern</description>
					<attribute name="@exception">
						<description>ParseException If the input pattern is incorrect.</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the input pattern is incorrect." fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</constructor>
			<method visibility="public" name="getPattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>recovers current pattern</description>
				</comment>
			</method>
			<method visibility="public" name="getPattern" fulltype="java.lang.String" type="String">
				<comment>
					<description>recovers current pattern.</description>
					<attribute name="@param">
						<description>withWhiteSpace puts spacing around the entries, and \n
 before &amp; and &lt;</description>
					</attribute>
				</comment>
				<params>
					<param name="withWhiteSpace" comment="puts spacing around the entries, and \n
 before &amp; and &lt;" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method final="true" visibility="private" name="findLastWithNoExtension" fulltype="java.text.PatternEntry" type="PatternEntry">
				<params>
					<param name="i" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="emitPattern" returncomment="emits the string in the format understable to the collation
 builder." fulltype="java.lang.String" type="String">
				<comment>
					<description>emits the pattern for collation builder.</description>
					<attribute name="@return">
						<description>emits the string in the format understable to the collation
 builder.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="emitPattern" returncomment="emits the string in the format understable to the collation
 builder." fulltype="java.lang.String" type="String">
				<comment>
					<description>emits the pattern for collation builder.</description>
					<attribute name="@param">
						<description>withWhiteSpace puts spacing around the entries, and \n
 before &amp; and &lt;</description>
					</attribute>
					<attribute name="@return">
						<description>emits the string in the format understable to the collation
 builder.</description>
					</attribute>
				</comment>
				<params>
					<param name="withWhiteSpace" comment="puts spacing around the entries, and \n
 before &amp; and &lt;" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="setPattern" fulltype="void" type="void">
				<comment>
					<description>sets the pattern.</description>
				</comment>
				<params>
					<param name="pattern" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
			<method visibility="public" name="addPattern" fulltype="void" type="void">
				<comment>
					<description>adds a pattern to the current one.</description>
					<attribute name="@param">
						<description>pattern the new pattern to be added</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="the new pattern to be added" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
			<method visibility="public" name="getCount" returncomment="the size of pattern entries" fulltype="int" type="int">
				<comment>
					<description>gets count of separate entries</description>
					<attribute name="@return">
						<description>the size of pattern entries</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getItemAt" returncomment="the requested pattern entry" fulltype="java.text.PatternEntry" type="PatternEntry">
				<comment>
					<description>gets count of separate entries</description>
					<attribute name="@param">
						<description>index the offset of the desired pattern entry</description>
					</attribute>
					<attribute name="@return">
						<description>the requested pattern entry</description>
					</attribute>
				</comment>
				<params>
					<param name="index" comment="the offset of the desired pattern entry" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="private" name="fixEntry" fulltype="void" type="void">
				<params>
					<param name="newEntry" fulltype="java.text.PatternEntry" type="PatternEntry" />
				</params>
				<exceptions>
					<exception fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
			<method final="true" visibility="private" name="findLastEntry" fulltype="int" type="int">
				<params>
					<param name="entry" fulltype="java.text.PatternEntry" type="PatternEntry" />
					<param name="excessChars" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
				<exceptions>
					<exception fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.BreakDictionary" type="BreakDictionary">
		<comment>
			<description>This is the class that represents the list of known words used by
 DictionaryBasedBreakIterator.  The conceptual data structure used
 here is a trie: there is a node hanging off the root node for every
 letter that can start a word.  Each of these nodes has a node hanging
 off of it for every letter that can be the second letter of a word
 if this node is the first letter, and so on.  The trie is represented
 as a two-dimensional array that can be treated as a table of state
 transitions.  Indexes are used to compress this array, taking
 advantage of the fact that this array will always be very sparse.</description>
		</comment>
		<fields>
			<field static="true" visibility="private" name="supportedVersion" fulltype="int" type="int">
				<comment>
					<description>The version of the dictionary that was read in.</description>
				</comment>
			</field>
			<field visibility="private" name="columnMap" fulltype="sun.text.CompactByteArray" type="CompactByteArray">
				<comment>
					<description>Maps from characters to column numbers.  The main use of this is to
 avoid making room in the array for empty columns.</description>
				</comment>
			</field>
			<field visibility="private" name="supplementaryCharColumnMap" fulltype="sun.text.SupplementaryCharacterData" type="SupplementaryCharacterData" />
			<field visibility="private" name="numCols" fulltype="int" type="int">
				<comment>
					<description>The number of actual columns in the table</description>
				</comment>
			</field>
			<field visibility="private" name="numColGroups" fulltype="int" type="int">
				<comment>
					<description>Columns are organized into groups of 32.  This says how many
 column groups.  (We could calculate this, but we store the
 value to avoid having to repeatedly calculate it.)</description>
				</comment>
			</field>
			<field visibility="private" name="table" fulltype="short[]" type="short">
				<comment>
					<description>The actual compressed state table.  Each conceptual row represents
 a state, and the cells in it contain the row numbers of the states
 to transition to for each possible letter.  0 is used to indicate
 an illegal combination of letters (i.e., the error state).  The
 table is compressed by eliminating all the unpopulated (i.e., zero)
 cells.  Multiple conceptual rows can then be doubled up in a single
 physical row by sliding them up and possibly shifting them to one
 side or the other so the populated cells don&apos;t collide.  Indexes
 are used to identify unpopulated cells and to locate populated cells.</description>
				</comment>
			</field>
			<field visibility="private" name="rowIndex" fulltype="short[]" type="short">
				<comment>
					<description>This index maps logical row numbers to physical row numbers</description>
				</comment>
			</field>
			<field visibility="private" name="rowIndexFlags" fulltype="int[]" type="int">
				<comment>
					<description>A bitmap is used to tell which cells in the comceptual table are
 populated.  This array contains all the unique bit combinations
 in that bitmap.  If the table is more than 32 columns wide,
 successive entries in this array are used for a single row.</description>
				</comment>
			</field>
			<field visibility="private" name="rowIndexFlagsIndex" fulltype="short[]" type="short">
				<comment>
					<description>This index maps from a logical row number into the bitmap table above.
 (This keeps us from storing duplicate bitmap combinations.)  Since there
 are a lot of rows with only one populated cell, instead of wasting space
 in the bitmap table, we just store a negative number in this index for
 rows with one populated cell.  The absolute value of that number is
 the column number of the populated cell.</description>
				</comment>
			</field>
			<field visibility="private" name="rowIndexShifts" fulltype="byte[]" type="byte">
				<comment>
					<description>For each logical row, this index contains a constant that is added to
 the logical column number to get the physical column number</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="BreakDictionary">
				<params>
					<param name="dictionaryName" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.util.MissingResourceException" type="MissingResourceException" />
				</exceptions>
			</constructor>
			<method visibility="private" name="readDictionaryFile" fulltype="void" type="void">
				<params>
					<param name="dictionaryName" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.util.MissingResourceException" type="MissingResourceException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="getNextStateFromCharacter" returncomment="The new state to transition to" fulltype="short" type="short">
				<comment>
					<description>Uses the column map to map the character to a column number, then
 passes the row and column number to getNextState()</description>
					<attribute name="@param">
						<description>row The current state</description>
					</attribute>
					<attribute name="@param">
						<description>ch The character whose column we&apos;re interested in</description>
					</attribute>
					<attribute name="@return">
						<description>The new state to transition to</description>
					</attribute>
				</comment>
				<params>
					<param name="row" comment="The current state" fulltype="int" type="int" />
					<param name="ch" comment="The character whose column we&apos;re interested in" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="public" name="getNextState" returncomment="The row number of the new state to transition to" fulltype="short" type="short">
				<comment>
					<description>Returns the value in the cell with the specified (logical) row and
 column numbers.  In DictionaryBasedBreakIterator, the row number is
 a state number, the column number is an input, and the return value
 is the row number of the new state to transition to.  (0 is the
 &quot;error&quot; state, and -1 is the &quot;end of word&quot; state in a dictionary)</description>
					<attribute name="@param">
						<description>row The row number of the current state</description>
					</attribute>
					<attribute name="@param">
						<description>col The column number of the input character (0 means &quot;not a
 dictionary character&quot;)</description>
					</attribute>
					<attribute name="@return">
						<description>The row number of the new state to transition to</description>
					</attribute>
				</comment>
				<params>
					<param name="row" comment="The row number of the current state" fulltype="int" type="int" />
					<param name="col" comment="The column number of the input character (0 means &quot;not a
 dictionary character&quot;)" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="private" name="cellIsPopulated" fulltype="boolean" type="boolean">
				<comment>
					<description>Given (logical) row and column numbers, returns true if the
 cell in that position is populated</description>
				</comment>
				<params>
					<param name="row" fulltype="int" type="int" />
					<param name="col" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="private" name="internalAt" returncomment="The value stored in the cell" fulltype="short" type="short">
				<comment>
					<description>Implementation of getNextState() when we know the specified cell is
 populated.</description>
					<attribute name="@param">
						<description>row The PHYSICAL row number of the cell</description>
					</attribute>
					<attribute name="@param">
						<description>col The PHYSICAL column number of the cell</description>
					</attribute>
					<attribute name="@return">
						<description>The value stored in the cell</description>
					</attribute>
				</comment>
				<params>
					<param name="row" comment="The PHYSICAL row number of the cell" fulltype="int" type="int" />
					<param name="col" comment="The PHYSICAL column number of the cell" fulltype="int" type="int" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Format" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.Format" fulltype="java.text.DateFormat" type="DateFormat">
		<comment>
			<description>DateFormat is an abstract class for date/time formatting subclasses which
 formats and parses dates or time in a language-independent manner.
 The date/time formatting subclass, such as SimpleDateFormat, allows for
 formatting (i.e., date -&gt; text), parsing (text -&gt; date), and
 normalization.  The date is represented as a &lt;code&gt;Date&lt;/code&gt; object or
 as the milliseconds since January 1, 1970, 00:00:00 GMT.

 &lt;p&gt;DateFormat provides many class methods for obtaining default date/time
 formatters based on the default or a given locale and a number of formatting
 styles. The formatting styles include FULL, LONG, MEDIUM, and SHORT. More
 detail and examples of using these styles are provided in the method
 descriptions.

 &lt;p&gt;DateFormat helps you to format and parse dates for any locale.
 Your code can be completely independent of the locale conventions for
 months, days of the week, or even the calendar format: lunar vs. solar.

 &lt;p&gt;To format a date for the current Locale, use one of the
 static factory methods:
 &lt;pre&gt;
  myString = DateFormat.getDateInstance().format(myDate);
 &lt;/pre&gt;
 &lt;p&gt;If you are formatting multiple dates, it is
 more efficient to get the format and use it multiple times so that
 the system doesn&apos;t have to fetch the information about the local
 language and country conventions multiple times.
 &lt;pre&gt;
  DateFormat df = DateFormat.getDateInstance();
  for (int i = 0; i &lt; myDate.length; ++i) {
    output.println(df.format(myDate[i]) + &quot;; &quot;);
  }
 &lt;/pre&gt;
 &lt;p&gt;To format a date for a different Locale, specify it in the
 call to getDateInstance().
 &lt;pre&gt;
  DateFormat df = DateFormat.getDateInstance(DateFormat.LONG, Locale.FRANCE);
 &lt;/pre&gt;
 &lt;p&gt;You can use a DateFormat to parse also.
 &lt;pre&gt;
  myDate = df.parse(myString);
 &lt;/pre&gt;
 &lt;p&gt;Use getDateInstance to get the normal date format for that country.
 There are other static factory methods available.
 Use getTimeInstance to get the time format for that country.
 Use getDateTimeInstance to get a date and time format. You can pass in
 different options to these factory methods to control the length of the
 result; from SHORT to MEDIUM to LONG to FULL. The exact result depends
 on the locale, but generally:
 &lt;ul&gt;&lt;li&gt;SHORT is completely numeric, such as 12.13.52 or 3:30pm
 &lt;li&gt;MEDIUM is longer, such as Jan 12, 1952
 &lt;li&gt;LONG is longer, such as January 12, 1952 or 3:30:32pm
 &lt;li&gt;FULL is pretty completely specified, such as
 Tuesday, April 12, 1952 AD or 3:30:42pm PST.
 &lt;/ul&gt;

 &lt;p&gt;You can also set the time zone on the format if you wish.
 If you want even more control over the format or parsing,
 (or want to give your users more control),
 you can try casting the DateFormat you get from the factory methods
 to a SimpleDateFormat. This will work for the majority
 of countries; just remember to put it in a try block in case you
 encounter an unusual one.

 &lt;p&gt;You can also use forms of the parse and format methods with
 ParsePosition and FieldPosition to
 allow you to
 &lt;ul&gt;&lt;li&gt;progressively parse through pieces of a string.
 &lt;li&gt;align any particular field, or find out where it is for selection
 on the screen.
 &lt;/ul&gt;

 &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;

 &lt;p&gt;
 Date formats are not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently, it must be synchronized
 externally.</description>
			<attribute name="@see">
				<description>Format</description>
			</attribute>
			<attribute name="@see">
				<description>NumberFormat</description>
			</attribute>
			<attribute name="@see">
				<description>SimpleDateFormat</description>
			</attribute>
			<attribute name="@see">
				<description>java.util.Calendar</description>
			</attribute>
			<attribute name="@see">
				<description>java.util.GregorianCalendar</description>
			</attribute>
			<attribute name="@see">
				<description>java.util.TimeZone</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Davis, Chen-Lieh Huang, Alan Liu</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="calendar" fulltype="java.util.Calendar" type="Calendar">
				<comment>
					<description>The calendar that &lt;code&gt;DateFormat&lt;/code&gt; uses to produce the time field
 values needed to implement date and time formatting.  Subclasses should
 initialize this to a calendar appropriate for the locale associated with
 this &lt;code&gt;DateFormat&lt;/code&gt;.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="protected" name="numberFormat" fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>The number formatter that &lt;code&gt;DateFormat&lt;/code&gt; uses to format numbers
 in dates and times.  Subclasses should initialize this to a number format
 appropriate for the locale associated with this &lt;code&gt;DateFormat&lt;/code&gt;.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field final="true" static="true" const="0" visibility="public" name="ERA_FIELD" constexpr="0" fulltype="int" type="int">
				<comment>
					<description>Useful constant for ERA field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="1" visibility="public" name="YEAR_FIELD" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>Useful constant for YEAR field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="2" visibility="public" name="MONTH_FIELD" constexpr="2" fulltype="int" type="int">
				<comment>
					<description>Useful constant for MONTH field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="3" visibility="public" name="DATE_FIELD" constexpr="3" fulltype="int" type="int">
				<comment>
					<description>Useful constant for DATE field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="4" visibility="public" name="HOUR_OF_DAY1_FIELD" constexpr="4" fulltype="int" type="int">
				<comment>
					<description>Useful constant for one-based HOUR_OF_DAY field alignment.
 Used in FieldPosition of date/time formatting.
 HOUR_OF_DAY1_FIELD is used for the one-based 24-hour clock.
 For example, 23:59 + 01:00 results in 24:59.</description>
				</comment>
			</field>
			<field final="true" static="true" const="5" visibility="public" name="HOUR_OF_DAY0_FIELD" constexpr="5" fulltype="int" type="int">
				<comment>
					<description>Useful constant for zero-based HOUR_OF_DAY field alignment.
 Used in FieldPosition of date/time formatting.
 HOUR_OF_DAY0_FIELD is used for the zero-based 24-hour clock.
 For example, 23:59 + 01:00 results in 00:59.</description>
				</comment>
			</field>
			<field final="true" static="true" const="6" visibility="public" name="MINUTE_FIELD" constexpr="6" fulltype="int" type="int">
				<comment>
					<description>Useful constant for MINUTE field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="7" visibility="public" name="SECOND_FIELD" constexpr="7" fulltype="int" type="int">
				<comment>
					<description>Useful constant for SECOND field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="8" visibility="public" name="MILLISECOND_FIELD" constexpr="8" fulltype="int" type="int">
				<comment>
					<description>Useful constant for MILLISECOND field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="9" visibility="public" name="DAY_OF_WEEK_FIELD" constexpr="9" fulltype="int" type="int">
				<comment>
					<description>Useful constant for DAY_OF_WEEK field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="10" visibility="public" name="DAY_OF_YEAR_FIELD" constexpr="10" fulltype="int" type="int">
				<comment>
					<description>Useful constant for DAY_OF_YEAR field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="11" visibility="public" name="DAY_OF_WEEK_IN_MONTH_FIELD" constexpr="11" fulltype="int" type="int">
				<comment>
					<description>Useful constant for DAY_OF_WEEK_IN_MONTH field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="12" visibility="public" name="WEEK_OF_YEAR_FIELD" constexpr="12" fulltype="int" type="int">
				<comment>
					<description>Useful constant for WEEK_OF_YEAR field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="13" visibility="public" name="WEEK_OF_MONTH_FIELD" constexpr="13" fulltype="int" type="int">
				<comment>
					<description>Useful constant for WEEK_OF_MONTH field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="14" visibility="public" name="AM_PM_FIELD" constexpr="14" fulltype="int" type="int">
				<comment>
					<description>Useful constant for AM_PM field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="15" visibility="public" name="HOUR1_FIELD" constexpr="15" fulltype="int" type="int">
				<comment>
					<description>Useful constant for one-based HOUR field alignment.
 Used in FieldPosition of date/time formatting.
 HOUR1_FIELD is used for the one-based 12-hour clock.
 For example, 11:30 PM + 1 hour results in 12:30 AM.</description>
				</comment>
			</field>
			<field final="true" static="true" const="16" visibility="public" name="HOUR0_FIELD" constexpr="16" fulltype="int" type="int">
				<comment>
					<description>Useful constant for zero-based HOUR field alignment.
 Used in FieldPosition of date/time formatting.
 HOUR0_FIELD is used for the zero-based 12-hour clock.
 For example, 11:30 PM + 1 hour results in 00:30 AM.</description>
				</comment>
			</field>
			<field final="true" static="true" const="17" visibility="public" name="TIMEZONE_FIELD" constexpr="17" fulltype="int" type="int">
				<comment>
					<description>Useful constant for TIMEZONE field alignment.
 Used in FieldPosition of date/time formatting.</description>
				</comment>
			</field>
			<field final="true" static="true" const="7218322306649953788" visibility="private" name="serialVersionUID" constexpr="7218322306649953788L" fulltype="long" type="long" />
			<field final="true" static="true" const="0" visibility="public" name="FULL" constexpr="0" fulltype="int" type="int">
				<comment>
					<description>Constant for full style pattern.</description>
				</comment>
			</field>
			<field final="true" static="true" const="1" visibility="public" name="LONG" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>Constant for long style pattern.</description>
				</comment>
			</field>
			<field final="true" static="true" const="2" visibility="public" name="MEDIUM" constexpr="2" fulltype="int" type="int">
				<comment>
					<description>Constant for medium style pattern.</description>
				</comment>
			</field>
			<field final="true" static="true" const="3" visibility="public" name="SHORT" constexpr="3" fulltype="int" type="int">
				<comment>
					<description>Constant for short style pattern.</description>
				</comment>
			</field>
			<field final="true" static="true" const="2" visibility="public" name="DEFAULT" constexpr="2" fulltype="int" type="int">
				<comment>
					<description>Constant for default style pattern.  Its value is MEDIUM.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="protected" name="DateFormat">
				<comment>
					<description>Create a new date format.</description>
				</comment>
			</constructor>
			<method final="true" visibility="public" name="format" returncomment="the string buffer passed in as toAppendTo, with formatted text appended." fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Overrides Format.
 Formats a time object into a time string. Examples of time objects
 are a time value expressed in milliseconds and a Date object.</description>
					<attribute name="@param">
						<description>obj must be a Number or a Date.</description>
					</attribute>
					<attribute name="@param">
						<description>toAppendTo the string buffer for the returning time string.</description>
					</attribute>
					<attribute name="@return">
						<description>the string buffer passed in as toAppendTo, with formatted text appended.</description>
					</attribute>
					<attribute name="@param">
						<description>fieldPosition keeps track of the position of the field
 within the returned string.
 On input: an alignment field,
 if desired. On output: the offsets of the alignment field. For
 example, given a time text &quot;1996.07.10 AD at 15:08:56 PDT&quot;,
 if the given fieldPosition is DateFormat.YEAR_FIELD, the
 begin index and end index of fieldPosition will be set to
 0 and 4, respectively.
 Notice that if the same time field appears
 more than once in a pattern, the fieldPosition will be set for the first
 occurrence of that time field. For instance, formatting a Date to
 the time string &quot;1 PM PDT (Pacific Daylight Time)&quot; using the pattern
 &quot;h a z (zzzz)&quot; and the alignment field DateFormat.TIMEZONE_FIELD,
 the begin index and end index of fieldPosition will be set to
 5 and 8, respectively, for the first occurrence of the timezone
 pattern character &apos;z&apos;.</description>
					</attribute>
					<attribute name="@see">
						<description>java.text.Format</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="must be a Number or a Date." fulltype="java.lang.Object" type="Object" />
					<param name="toAppendTo" comment="the string buffer for the returning time string." fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="fieldPosition" comment="keeps track of the position of the field
 within the returned string.
 On input: an alignment field,
 if desired. On output: the offsets of the alignment field. For
 example, given a time text &quot;1996.07.10 AD at 15:08:56 PDT&quot;,
 if the given fieldPosition is DateFormat.YEAR_FIELD, the
 begin index and end index of fieldPosition will be set to
 0 and 4, respectively.
 Notice that if the same time field appears
 more than once in a pattern, the fieldPosition will be set for the first
 occurrence of that time field. For instance, formatting a Date to
 the time string &quot;1 PM PDT (Pacific Daylight Time)&quot; using the pattern
 &quot;h a z (zzzz)&quot; and the alignment field DateFormat.TIMEZONE_FIELD,
 the begin index and end index of fieldPosition will be set to
 5 and 8, respectively, for the first occurrence of the timezone
 pattern character &apos;z&apos;." fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="format" returncomment="the string buffer passed in as toAppendTo, with formatted text appended." fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Formats a Date into a date/time string.</description>
					<attribute name="@param">
						<description>date a Date to be formatted into a date/time string.</description>
					</attribute>
					<attribute name="@param">
						<description>toAppendTo the string buffer for the returning date/time string.</description>
					</attribute>
					<attribute name="@param">
						<description>fieldPosition keeps track of the position of the field
 within the returned string.
 On input: an alignment field,
 if desired. On output: the offsets of the alignment field. For
 example, given a time text &quot;1996.07.10 AD at 15:08:56 PDT&quot;,
 if the given fieldPosition is DateFormat.YEAR_FIELD, the
 begin index and end index of fieldPosition will be set to
 0 and 4, respectively.
 Notice that if the same time field appears
 more than once in a pattern, the fieldPosition will be set for the first
 occurrence of that time field. For instance, formatting a Date to
 the time string &quot;1 PM PDT (Pacific Daylight Time)&quot; using the pattern
 &quot;h a z (zzzz)&quot; and the alignment field DateFormat.TIMEZONE_FIELD,
 the begin index and end index of fieldPosition will be set to
 5 and 8, respectively, for the first occurrence of the timezone
 pattern character &apos;z&apos;.</description>
					</attribute>
					<attribute name="@return">
						<description>the string buffer passed in as toAppendTo, with formatted text appended.</description>
					</attribute>
				</comment>
				<params>
					<param name="date" comment="a Date to be formatted into a date/time string." fulltype="java.util.Date" type="Date" />
					<param name="toAppendTo" comment="the string buffer for the returning date/time string." fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="fieldPosition" comment="keeps track of the position of the field
 within the returned string.
 On input: an alignment field,
 if desired. On output: the offsets of the alignment field. For
 example, given a time text &quot;1996.07.10 AD at 15:08:56 PDT&quot;,
 if the given fieldPosition is DateFormat.YEAR_FIELD, the
 begin index and end index of fieldPosition will be set to
 0 and 4, respectively.
 Notice that if the same time field appears
 more than once in a pattern, the fieldPosition will be set for the first
 occurrence of that time field. For instance, formatting a Date to
 the time string &quot;1 PM PDT (Pacific Daylight Time)&quot; using the pattern
 &quot;h a z (zzzz)&quot; and the alignment field DateFormat.TIMEZONE_FIELD,
 the begin index and end index of fieldPosition will be set to
 5 and 8, respectively, for the first occurrence of the timezone
 pattern character &apos;z&apos;." fulltype="java.text.FieldPosition" type="FieldPosition" />
				</params>
			</method>
			<method final="true" visibility="public" name="format" returncomment="the formatted time string." fulltype="java.lang.String" type="String">
				<comment>
					<description>Formats a Date into a date/time string.</description>
					<attribute name="@param">
						<description>date the time value to be formatted into a time string.</description>
					</attribute>
					<attribute name="@return">
						<description>the formatted time string.</description>
					</attribute>
				</comment>
				<params>
					<param name="date" comment="the time value to be formatted into a time string." fulltype="java.util.Date" type="Date" />
				</params>
			</method>
			<method visibility="public" name="parse" returncomment="A &lt;code&gt;Date&lt;/code&gt; parsed from the string." fulltype="java.util.Date" type="Date">
				<comment>
					<description>Parses text from the beginning of the given string to produce a date.
 The method may not use the entire text of the given string.
 &lt;p&gt;
 See the {@link #parse(String, ParsePosition)} method for more information
 on date parsing.</description>
					<attribute name="@param">
						<description>source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</description>
					</attribute>
					<attribute name="@return">
						<description>A &lt;code&gt;Date&lt;/code&gt; parsed from the string.</description>
					</attribute>
					<attribute name="@exception">
						<description>ParseException if the beginning of the specified string
            cannot be parsed.</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if the beginning of the specified string
            cannot be parsed." fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="parse" returncomment="A Date, or null if the input could not be parsed" fulltype="java.util.Date" type="Date">
				<comment>
					<description>Parse a date/time string according to the given parse position.  For
 example, a time text &quot;07/10/96 4:5 PM, PDT&quot; will be parsed into a Date
 that is equivalent to Date(837039928046).

 &lt;p&gt; By default, parsing is lenient: If the input is not in the form used
 by this object&apos;s format method but can still be parsed as a date, then
 the parse succeeds.  Clients may insist on strict adherence to the
 format by calling setLenient(false).</description>
					<attribute name="@see">
						<description>java.text.DateFormat#setLenient(boolean)</description>
					</attribute>
					<attribute name="@param">
						<description>source  The date/time string to be parsed</description>
					</attribute>
					<attribute name="@param">
						<description>pos   On input, the position at which to start parsing; on
              output, the position at which parsing terminated, or the
              start position if the parse failed.</description>
					</attribute>
					<attribute name="@return">
						<description>A Date, or null if the input could not be parsed</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="The date/time string to be parsed" fulltype="java.lang.String" type="String" />
					<param name="pos" comment="On input, the position at which to start parsing; on
              output, the position at which parsing terminated, or the
              start position if the parse failed." fulltype="java.text.ParsePosition" type="ParsePosition" />
				</params>
			</method>
			<method visibility="public" name="parseObject" returncomment="A &lt;code&gt;Date&lt;/code&gt; parsed from the string. In case of
         error, returns null." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Parses text from a string to produce a &lt;code&gt;Date&lt;/code&gt;.
 &lt;p&gt;
 The method attempts to parse text starting at the index given by
 &lt;code&gt;pos&lt;/code&gt;.
 If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
 to the index after the last character used (parsing does not necessarily
 use all characters up to the end of the string), and the parsed
 date is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
 indicate the starting point for the next call to this method.
 If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
 changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
 the character where the error occurred, and null is returned.
 &lt;p&gt;
 See the {@link #parse(String, ParsePosition)} method for more information
 on date parsing.</description>
					<attribute name="@param">
						<description>source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</description>
					</attribute>
					<attribute name="@param">
						<description>pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
            index information as described above.</description>
					</attribute>
					<attribute name="@return">
						<description>A &lt;code&gt;Date&lt;/code&gt; parsed from the string. In case of
         error, returns null.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if &lt;code&gt;pos&lt;/code&gt; is null.</description>
					</attribute>
				</comment>
				<params>
					<param name="source" comment="A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed." fulltype="java.lang.String" type="String" />
					<param name="pos" comment="A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
            index information as described above." fulltype="java.text.ParsePosition" type="ParsePosition" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="getTimeInstance" returncomment="a time formatter." fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Gets the time formatter with the default formatting style
 for the default locale.</description>
					<attribute name="@return">
						<description>a time formatter.</description>
					</attribute>
				</comment>
			</method>
			<method final="true" static="true" visibility="public" name="getTimeInstance" returncomment="a time formatter." fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Gets the time formatter with the given formatting style
 for the default locale.</description>
					<attribute name="@param">
						<description>style the given formatting style. For example,
 SHORT for &quot;h:mm a&quot; in the US locale.</description>
					</attribute>
					<attribute name="@return">
						<description>a time formatter.</description>
					</attribute>
				</comment>
				<params>
					<param name="style" comment="the given formatting style. For example,
 SHORT for &quot;h:mm a&quot; in the US locale." fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="getTimeInstance" returncomment="a time formatter." fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Gets the time formatter with the given formatting style
 for the given locale.</description>
					<attribute name="@param">
						<description>style the given formatting style. For example,
 SHORT for &quot;h:mm a&quot; in the US locale.</description>
					</attribute>
					<attribute name="@param">
						<description>aLocale the given locale.</description>
					</attribute>
					<attribute name="@return">
						<description>a time formatter.</description>
					</attribute>
				</comment>
				<params>
					<param name="style" comment="the given formatting style. For example,
 SHORT for &quot;h:mm a&quot; in the US locale." fulltype="int" type="int" />
					<param name="aLocale" comment="the given locale." fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="getDateInstance" returncomment="a date formatter." fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Gets the date formatter with the default formatting style
 for the default locale.</description>
					<attribute name="@return">
						<description>a date formatter.</description>
					</attribute>
				</comment>
			</method>
			<method final="true" static="true" visibility="public" name="getDateInstance" returncomment="a date formatter." fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Gets the date formatter with the given formatting style
 for the default locale.</description>
					<attribute name="@param">
						<description>style the given formatting style. For example,
 SHORT for &quot;M/d/yy&quot; in the US locale.</description>
					</attribute>
					<attribute name="@return">
						<description>a date formatter.</description>
					</attribute>
				</comment>
				<params>
					<param name="style" comment="the given formatting style. For example,
 SHORT for &quot;M/d/yy&quot; in the US locale." fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="getDateInstance" returncomment="a date formatter." fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Gets the date formatter with the given formatting style
 for the given locale.</description>
					<attribute name="@param">
						<description>style the given formatting style. For example,
 SHORT for &quot;M/d/yy&quot; in the US locale.</description>
					</attribute>
					<attribute name="@param">
						<description>aLocale the given locale.</description>
					</attribute>
					<attribute name="@return">
						<description>a date formatter.</description>
					</attribute>
				</comment>
				<params>
					<param name="style" comment="the given formatting style. For example,
 SHORT for &quot;M/d/yy&quot; in the US locale." fulltype="int" type="int" />
					<param name="aLocale" comment="the given locale." fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="getDateTimeInstance" returncomment="a date/time formatter." fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Gets the date/time formatter with the default formatting style
 for the default locale.</description>
					<attribute name="@return">
						<description>a date/time formatter.</description>
					</attribute>
				</comment>
			</method>
			<method final="true" static="true" visibility="public" name="getDateTimeInstance" returncomment="a date/time formatter." fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Gets the date/time formatter with the given date and time
 formatting styles for the default locale.</description>
					<attribute name="@param">
						<description>dateStyle the given date formatting style. For example,
 SHORT for &quot;M/d/yy&quot; in the US locale.</description>
					</attribute>
					<attribute name="@param">
						<description>timeStyle the given time formatting style. For example,
 SHORT for &quot;h:mm a&quot; in the US locale.</description>
					</attribute>
					<attribute name="@return">
						<description>a date/time formatter.</description>
					</attribute>
				</comment>
				<params>
					<param name="dateStyle" comment="the given date formatting style. For example,
 SHORT for &quot;M/d/yy&quot; in the US locale." fulltype="int" type="int" />
					<param name="timeStyle" comment="the given time formatting style. For example,
 SHORT for &quot;h:mm a&quot; in the US locale." fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="getDateTimeInstance" returncomment="a date/time formatter." fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Gets the date/time formatter with the given formatting styles
 for the given locale.</description>
					<attribute name="@param">
						<description>dateStyle the given date formatting style.</description>
					</attribute>
					<attribute name="@param">
						<description>timeStyle the given time formatting style.</description>
					</attribute>
					<attribute name="@param">
						<description>aLocale the given locale.</description>
					</attribute>
					<attribute name="@return">
						<description>a date/time formatter.</description>
					</attribute>
				</comment>
				<params>
					<param name="dateStyle" comment="the given date formatting style." fulltype="int" type="int" />
					<param name="timeStyle" comment="the given time formatting style." fulltype="int" type="int" />
					<param name="aLocale" comment="the given locale." fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
			<method final="true" static="true" visibility="public" name="getInstance" fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Get a default date/time formatter that uses the SHORT style for both the
 date and the time.</description>
				</comment>
			</method>
			<method static="true" visibility="public" name="getAvailableLocales" returncomment="An array of locales for which localized
         &lt;code&gt;DateFormat&lt;/code&gt; instances are available." fulltype="java.util.Locale[]" type="Locale">
				<comment>
					<description>Returns an array of all locales for which the
 &lt;code&gt;get*Instance&lt;/code&gt; methods of this class can return
 localized instances.
 The returned array represents the union of locales supported by the Java
 runtime and by installed
 {@link java.text.spi.DateFormatProvider DateFormatProvider} implementations.
 It must contain at least a &lt;code&gt;Locale&lt;/code&gt; instance equal to
 {@link java.util.Locale#US Locale.US}.</description>
					<attribute name="@return">
						<description>An array of locales for which localized
         &lt;code&gt;DateFormat&lt;/code&gt; instances are available.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setCalendar" fulltype="void" type="void">
				<comment>
					<description>Set the calendar to be used by this date format.  Initially, the default
 calendar for the specified or default locale is used.</description>
					<attribute name="@param">
						<description>newCalendar the new Calendar to be used by the date format</description>
					</attribute>
				</comment>
				<params>
					<param name="newCalendar" comment="the new Calendar to be used by the date format" fulltype="java.util.Calendar" type="Calendar" />
				</params>
			</method>
			<method visibility="public" name="getCalendar" returncomment="the calendar associated with this date/time formatter." fulltype="java.util.Calendar" type="Calendar">
				<comment>
					<description>Gets the calendar associated with this date/time formatter.</description>
					<attribute name="@return">
						<description>the calendar associated with this date/time formatter.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setNumberFormat" fulltype="void" type="void">
				<comment>
					<description>Allows you to set the number formatter.</description>
					<attribute name="@param">
						<description>newNumberFormat the given new NumberFormat.</description>
					</attribute>
				</comment>
				<params>
					<param name="newNumberFormat" comment="the given new NumberFormat." fulltype="java.text.NumberFormat" type="NumberFormat" />
				</params>
			</method>
			<method visibility="public" name="getNumberFormat" returncomment="the number formatter which this date/time formatter uses." fulltype="java.text.NumberFormat" type="NumberFormat">
				<comment>
					<description>Gets the number formatter which this date/time formatter uses to
 format and parse a time.</description>
					<attribute name="@return">
						<description>the number formatter which this date/time formatter uses.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setTimeZone" fulltype="void" type="void">
				<comment>
					<description>Sets the time zone for the calendar of this DateFormat object.</description>
					<attribute name="@param">
						<description>zone the given new time zone.</description>
					</attribute>
				</comment>
				<params>
					<param name="zone" comment="the given new time zone." fulltype="java.util.TimeZone" type="TimeZone" />
				</params>
			</method>
			<method visibility="public" name="getTimeZone" returncomment="the time zone associated with the calendar of DateFormat." fulltype="java.util.TimeZone" type="TimeZone">
				<comment>
					<description>Gets the time zone.</description>
					<attribute name="@return">
						<description>the time zone associated with the calendar of DateFormat.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setLenient" fulltype="void" type="void">
				<comment>
					<description>Specify whether or not date/time parsing is to be lenient.  With
 lenient parsing, the parser may use heuristics to interpret inputs that
 do not precisely match this object&apos;s format.  With strict parsing,
 inputs must match this object&apos;s format.</description>
					<attribute name="@param">
						<description>lenient when true, parsing is lenient</description>
					</attribute>
					<attribute name="@see">
						<description>java.util.Calendar#setLenient</description>
					</attribute>
				</comment>
				<params>
					<param name="lenient" comment="when true, parsing is lenient" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="isLenient" fulltype="boolean" type="boolean">
				<comment>
					<description>Tell whether date/time parsing is to be lenient.</description>
				</comment>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Overrides hashCode</description>
				</comment>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Overrides equals</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="clone" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Overrides Cloneable</description>
				</comment>
			</method>
			<method static="true" visibility="private" name="get" fulltype="java.text.DateFormat" type="DateFormat">
				<comment>
					<description>Creates a DateFormat with the given time and/or date style in the given
 locale.</description>
					<attribute name="@param">
						<description>timeStyle a value from 0 to 3 indicating the time format,
 ignored if flags is 2</description>
					</attribute>
					<attribute name="@param">
						<description>dateStyle a value from 0 to 3 indicating the time format,
 ignored if flags is 1</description>
					</attribute>
					<attribute name="@param">
						<description>flags either 1 for a time format, 2 for a date format,
 or 3 for a date/time format</description>
					</attribute>
					<attribute name="@param">
						<description>loc the locale for the format</description>
					</attribute>
				</comment>
				<params>
					<param name="timeStyle" comment="a value from 0 to 3 indicating the time format,
 ignored if flags is 2" fulltype="int" type="int" />
					<param name="dateStyle" comment="a value from 0 to 3 indicating the time format,
 ignored if flags is 1" fulltype="int" type="int" />
					<param name="flags" comment="either 1 for a time format, 2 for a date format,
 or 3 for a date/time format" fulltype="int" type="int" />
					<param name="loc" comment="the locale for the format" fulltype="java.util.Locale" type="Locale" />
				</params>
			</method>
		</methods>
		<jelclass superclass="Format.Field" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.Format.Field" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
			<comment>
				<description>Defines constants that are used as attribute keys in the
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
 from &lt;code&gt;DateFormat.formatToCharacterIterator&lt;/code&gt; and as
 field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.
 &lt;p&gt;
 The class also provides two methods to map
 between its constants and the corresponding Calendar constants.</description>
				<attribute name="@since">
					<description>1.4</description>
				</attribute>
				<attribute name="@see">
					<description>java.util.Calendar</description>
				</attribute>
			</comment>
			<fields>
				<field final="true" static="true" const="7441350119349544720" visibility="private" name="serialVersionUID" constexpr="7441350119349544720L" fulltype="long" type="long" />
				<field final="true" static="true" visibility="private" name="instanceMap" fulltype="java.util.Map" type="Map" />
				<field final="true" static="true" visibility="private" name="calendarToFieldMapping" fulltype="java.text.DateFormat.Field[]" type="DateFormat.Field" />
				<field visibility="private" name="calendarField" fulltype="int" type="int">
					<comment>
						<description>Calendar field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="ERA" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the era field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="YEAR" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the year field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="MONTH" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the month field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="DAY_OF_MONTH" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the day of month field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="HOUR_OF_DAY1" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the hour of day field, where the legal values
 are 1 to 24.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="HOUR_OF_DAY0" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the hour of day field, where the legal values
 are 0 to 23.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="MINUTE" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the minute field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="SECOND" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the second field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="MILLISECOND" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the millisecond field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="DAY_OF_WEEK" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the day of week field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="DAY_OF_YEAR" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the day of year field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="DAY_OF_WEEK_IN_MONTH" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the day of week field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="WEEK_OF_YEAR" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the week of year field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="WEEK_OF_MONTH" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the week of month field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="AM_PM" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the time of day indicator
 (e.g. &quot;a.m.&quot; or &quot;p.m.&quot;) field.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="HOUR1" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the hour field, where the legal values are
 1 to 12.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="HOUR0" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the hour field, where the legal values are
 0 to 11.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="TIME_ZONE" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Constant identifying the time zone field.</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="protected" name="DateFormat.Field">
					<comment>
						<description>Creates a &lt;code&gt;Field&lt;/code&gt;.</description>
						<attribute name="@param">
							<description>name the name of the &lt;code&gt;Field&lt;/code&gt;</description>
						</attribute>
						<attribute name="@param">
							<description>calendarField the &lt;code&gt;Calendar&lt;/code&gt; constant this
        &lt;code&gt;Field&lt;/code&gt; corresponds to; any value, even one
        outside the range of legal &lt;code&gt;Calendar&lt;/code&gt; values may
        be used, but &lt;code&gt;-1&lt;/code&gt; should be used for values
        that don&apos;t correspond to legal &lt;code&gt;Calendar&lt;/code&gt; values</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the &lt;code&gt;Field&lt;/code&gt;" fulltype="java.lang.String" type="String" />
						<param name="calendarField" comment="the &lt;code&gt;Calendar&lt;/code&gt; constant this
        &lt;code&gt;Field&lt;/code&gt; corresponds to; any value, even one
        outside the range of legal &lt;code&gt;Calendar&lt;/code&gt; values may
        be used, but &lt;code&gt;-1&lt;/code&gt; should be used for values
        that don&apos;t correspond to legal &lt;code&gt;Calendar&lt;/code&gt; values" fulltype="int" type="int" />
					</params>
				</constructor>
				<method static="true" visibility="public" name="ofCalendarField" returncomment="Field instance representing calendarField." fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
					<comment>
						<description>Returns the &lt;code&gt;Field&lt;/code&gt; constant that corresponds to
 the &lt;code&gt;Calendar&lt;/code&gt; constant &lt;code&gt;calendarField&lt;/code&gt;.
 If there is no direct mapping between the &lt;code&gt;Calendar&lt;/code&gt;
 constant and a &lt;code&gt;Field&lt;/code&gt;, null is returned.</description>
						<attribute name="@throws">
							<description>IllegalArgumentException if &lt;code&gt;calendarField&lt;/code&gt; is
         not the value of a &lt;code&gt;Calendar&lt;/code&gt; field constant.</description>
						</attribute>
						<attribute name="@param">
							<description>calendarField Calendar field constant</description>
						</attribute>
						<attribute name="@return">
							<description>Field instance representing calendarField.</description>
						</attribute>
						<attribute name="@see">
							<description>java.util.Calendar</description>
						</attribute>
					</comment>
					<params>
						<param name="calendarField" comment="Calendar field constant" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="public" name="getCalendarField" returncomment="Calendar constant for this field" fulltype="int" type="int">
					<comment>
						<description>Returns the &lt;code&gt;Calendar&lt;/code&gt; field associated with this
 attribute. For example, if this represents the hours field of
 a &lt;code&gt;Calendar&lt;/code&gt;, this would return
 &lt;code&gt;Calendar.HOUR&lt;/code&gt;. If there is no corresponding
 &lt;code&gt;Calendar&lt;/code&gt; constant, this will return -1.</description>
						<attribute name="@return">
							<description>Calendar constant for this field</description>
						</attribute>
						<attribute name="@see">
							<description>java.util.Calendar</description>
						</attribute>
					</comment>
				</method>
				<method visibility="protected" name="readResolve" returncomment="resolved DateFormat.Field constant" fulltype="java.lang.Object" type="Object">
					<comment>
						<description>Resolves instances being deserialized to the predefined constants.</description>
						<attribute name="@throws">
							<description>InvalidObjectException if the constant could not be
         resolved.</description>
						</attribute>
						<attribute name="@return">
							<description>resolved DateFormat.Field constant</description>
						</attribute>
					</comment>
					<exceptions>
						<exception comment="if the constant could not be
         resolved." fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
					</exceptions>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.DateFormat.DateFormatGetter" type="DateFormat.DateFormatGetter">
			<implements>
				<interface fulltype="sun.util.LocaleServiceProviderPool.LocalizedObjectGetter" type="LocaleServiceProviderPool.LocalizedObjectGetter" />
			</implements>
			<comment>
				<description>Obtains a DateFormat instance from a DateFormatProvider
 implementation.</description>
			</comment>
			<fields>
				<field final="true" static="true" visibility="private" name="INSTANCE" fulltype="java.text.DateFormat.DateFormatGetter" type="DateFormat.DateFormatGetter" />
			</fields>
			<methods>
				<constructor visibility="private" name="DateFormat.DateFormatGetter" />
				<method visibility="public" name="getObject" fulltype="java.text.DateFormat" type="DateFormat">
					<params>
						<param name="dateFormatProvider" fulltype="java.text.spi.DateFormatProvider" type="DateFormatProvider" />
						<param name="locale" fulltype="java.util.Locale" type="Locale" />
						<param name="key" fulltype="java.lang.String" type="String" />
						<param name="params" fulltype="java.lang.Object[]" type="Object" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Format.Field" visibility="public" package="java.text" serializable="true" superclassfulltype="java.text.Format.Field" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
		<comment>
			<description>Defines constants that are used as attribute keys in the
 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
 from &lt;code&gt;DateFormat.formatToCharacterIterator&lt;/code&gt; and as
 field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.
 &lt;p&gt;
 The class also provides two methods to map
 between its constants and the corresponding Calendar constants.</description>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
			<attribute name="@see">
				<description>java.util.Calendar</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="7441350119349544720" visibility="private" name="serialVersionUID" constexpr="7441350119349544720L" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="instanceMap" fulltype="java.util.Map" type="Map" />
			<field final="true" static="true" visibility="private" name="calendarToFieldMapping" fulltype="java.text.DateFormat.Field[]" type="DateFormat.Field" />
			<field visibility="private" name="calendarField" fulltype="int" type="int">
				<comment>
					<description>Calendar field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="ERA" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the era field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="YEAR" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the year field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="MONTH" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the month field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="DAY_OF_MONTH" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the day of month field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="HOUR_OF_DAY1" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the hour of day field, where the legal values
 are 1 to 24.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="HOUR_OF_DAY0" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the hour of day field, where the legal values
 are 0 to 23.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="MINUTE" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the minute field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="SECOND" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the second field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="MILLISECOND" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the millisecond field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="DAY_OF_WEEK" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the day of week field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="DAY_OF_YEAR" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the day of year field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="DAY_OF_WEEK_IN_MONTH" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the day of week field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="WEEK_OF_YEAR" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the week of year field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="WEEK_OF_MONTH" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the week of month field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="AM_PM" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the time of day indicator
 (e.g. &quot;a.m.&quot; or &quot;p.m.&quot;) field.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="HOUR1" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the hour field, where the legal values are
 1 to 12.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="HOUR0" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the hour field, where the legal values are
 0 to 11.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="TIME_ZONE" fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Constant identifying the time zone field.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="protected" name="DateFormat.Field">
				<comment>
					<description>Creates a &lt;code&gt;Field&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>name the name of the &lt;code&gt;Field&lt;/code&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>calendarField the &lt;code&gt;Calendar&lt;/code&gt; constant this
        &lt;code&gt;Field&lt;/code&gt; corresponds to; any value, even one
        outside the range of legal &lt;code&gt;Calendar&lt;/code&gt; values may
        be used, but &lt;code&gt;-1&lt;/code&gt; should be used for values
        that don&apos;t correspond to legal &lt;code&gt;Calendar&lt;/code&gt; values</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the &lt;code&gt;Field&lt;/code&gt;" fulltype="java.lang.String" type="String" />
					<param name="calendarField" comment="the &lt;code&gt;Calendar&lt;/code&gt; constant this
        &lt;code&gt;Field&lt;/code&gt; corresponds to; any value, even one
        outside the range of legal &lt;code&gt;Calendar&lt;/code&gt; values may
        be used, but &lt;code&gt;-1&lt;/code&gt; should be used for values
        that don&apos;t correspond to legal &lt;code&gt;Calendar&lt;/code&gt; values" fulltype="int" type="int" />
				</params>
			</constructor>
			<method static="true" visibility="public" name="ofCalendarField" returncomment="Field instance representing calendarField." fulltype="java.text.DateFormat.Field" type="DateFormat.Field">
				<comment>
					<description>Returns the &lt;code&gt;Field&lt;/code&gt; constant that corresponds to
 the &lt;code&gt;Calendar&lt;/code&gt; constant &lt;code&gt;calendarField&lt;/code&gt;.
 If there is no direct mapping between the &lt;code&gt;Calendar&lt;/code&gt;
 constant and a &lt;code&gt;Field&lt;/code&gt;, null is returned.</description>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;calendarField&lt;/code&gt; is
         not the value of a &lt;code&gt;Calendar&lt;/code&gt; field constant.</description>
					</attribute>
					<attribute name="@param">
						<description>calendarField Calendar field constant</description>
					</attribute>
					<attribute name="@return">
						<description>Field instance representing calendarField.</description>
					</attribute>
					<attribute name="@see">
						<description>java.util.Calendar</description>
					</attribute>
				</comment>
				<params>
					<param name="calendarField" comment="Calendar field constant" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getCalendarField" returncomment="Calendar constant for this field" fulltype="int" type="int">
				<comment>
					<description>Returns the &lt;code&gt;Calendar&lt;/code&gt; field associated with this
 attribute. For example, if this represents the hours field of
 a &lt;code&gt;Calendar&lt;/code&gt;, this would return
 &lt;code&gt;Calendar.HOUR&lt;/code&gt;. If there is no corresponding
 &lt;code&gt;Calendar&lt;/code&gt; constant, this will return -1.</description>
					<attribute name="@return">
						<description>Calendar constant for this field</description>
					</attribute>
					<attribute name="@see">
						<description>java.util.Calendar</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="readResolve" returncomment="resolved DateFormat.Field constant" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Resolves instances being deserialized to the predefined constants.</description>
					<attribute name="@throws">
						<description>InvalidObjectException if the constant could not be
         resolved.</description>
					</attribute>
					<attribute name="@return">
						<description>resolved DateFormat.Field constant</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the constant could not be
         resolved." fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.DateFormat.DateFormatGetter" type="DateFormat.DateFormatGetter">
		<implements>
			<interface fulltype="sun.util.LocaleServiceProviderPool.LocalizedObjectGetter" type="LocaleServiceProviderPool.LocalizedObjectGetter" />
		</implements>
		<comment>
			<description>Obtains a DateFormat instance from a DateFormatProvider
 implementation.</description>
		</comment>
		<fields>
			<field final="true" static="true" visibility="private" name="INSTANCE" fulltype="java.text.DateFormat.DateFormatGetter" type="DateFormat.DateFormatGetter" />
		</fields>
		<methods>
			<constructor visibility="private" name="DateFormat.DateFormatGetter" />
			<method visibility="public" name="getObject" fulltype="java.text.DateFormat" type="DateFormat">
				<params>
					<param name="dateFormatProvider" fulltype="java.text.spi.DateFormatProvider" type="DateFormatProvider" />
					<param name="locale" fulltype="java.util.Locale" type="Locale" />
					<param name="key" fulltype="java.lang.String" type="String" />
					<param name="params" fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.ParsePosition" type="ParsePosition">
		<comment>
			<description>&lt;code&gt;ParsePosition&lt;/code&gt; is a simple class used by &lt;code&gt;Format&lt;/code&gt;
 and its subclasses to keep track of the current position during parsing.
 The &lt;code&gt;parseObject&lt;/code&gt; method in the various &lt;code&gt;Format&lt;/code&gt;
 classes requires a &lt;code&gt;ParsePosition&lt;/code&gt; object as an argument.

 &lt;p&gt;
 By design, as you parse through a string with different formats,
 you can use the same &lt;code&gt;ParsePosition&lt;/code&gt;, since the index parameter
 records the current position.</description>
			<attribute name="@author">
				<description>Mark Davis</description>
			</attribute>
			<attribute name="@see">
				<description>java.text.Format</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="index" fulltype="int" type="int">
				<comment>
					<description>Input: the place you start parsing.
 &lt;br&gt;Output: position where the parse stopped.
 This is designed to be used serially,
 with each call setting index up for the next one.</description>
				</comment>
			</field>
			<field visibility="package-private" name="errorIndex" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="public" name="ParsePosition">
				<comment>
					<description>Create a new ParsePosition with the given initial index.</description>
				</comment>
				<params>
					<param name="index" fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="public" name="getIndex" fulltype="int" type="int">
				<comment>
					<description>Retrieve the current parse position.  On input to a parse method, this
 is the index of the character at which parsing will begin; on output, it
 is the index of the character following the last character parsed.</description>
				</comment>
			</method>
			<method visibility="public" name="setIndex" fulltype="void" type="void">
				<comment>
					<description>Set the current parse position.</description>
				</comment>
				<params>
					<param name="index" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="setErrorIndex" fulltype="void" type="void">
				<comment>
					<description>Set the index at which a parse error occurred.  Formatters
 should set this before returning an error code from their
 parseObject method.  The default value is -1 if this is not set.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="ei" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getErrorIndex" fulltype="int" type="int">
				<comment>
					<description>Retrieve the index at which an error occurred, or -1 if the
 error index has not been set.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Overrides equals</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" returncomment="a hash code value for this object" fulltype="int" type="int">
				<comment>
					<description>Returns a hash code for this ParsePosition.</description>
					<attribute name="@return">
						<description>a hash code value for this object</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toString" returncomment="a string representation of this object" fulltype="java.lang.String" type="String">
				<comment>
					<description>Return a string representation of this ParsePosition.</description>
					<attribute name="@return">
						<description>a string representation of this object</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="package-private" package="java.text" superclassfulltype="java.lang.Object" fulltype="java.text.RBTableBuilder" type="RBTableBuilder">
		<comment>
			<description>This class contains all the code to parse a RuleBasedCollator pattern
 and build a RBCollationTables object from it.  A particular instance
 of tis class exists only during the actual build process-- once an
 RBCollationTables object has been built, the RBTableBuilder object
 goes away.  This object carries all of the state which is only needed
 during the build process, plus a &quot;shadow&quot; copy of all of the state
 that will go into the tables object itself.  This object communicates
 with RBCollationTables through a separate class, RBCollationTables.BuildAPI,
 this is an inner class of RBCollationTables and provides a separate
 private API for communication with RBTableBuilder.
 This class isn&apos;t just an inner class of RBCollationTables itself because
 of its large size.  For source-code readability, it seemed better for the
 builder to have its own source file.</description>
		</comment>
		<fields>
			<field final="true" static="true" const="1879048192" visibility="package-private" name="CHARINDEX" constexpr="1879048192" fulltype="int" type="int" />
			<field final="true" static="true" const="65535" visibility="private" name="IGNORABLEMASK" constexpr="65535" fulltype="int" type="int" />
			<field final="true" static="true" const="65536" visibility="private" name="PRIMARYORDERINCREMENT" constexpr="65536" fulltype="int" type="int" />
			<field final="true" static="true" const="256" visibility="private" name="SECONDARYORDERINCREMENT" constexpr="256" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="private" name="TERTIARYORDERINCREMENT" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="20" visibility="private" name="INITIALTABLESIZE" constexpr="20" fulltype="int" type="int" />
			<field final="true" static="true" const="5" visibility="private" name="MAXKEYSIZE" constexpr="5" fulltype="int" type="int" />
			<field visibility="private" name="tables" fulltype="java.text.RBCollationTables.BuildAPI" type="RBCollationTables.BuildAPI" />
			<field visibility="private" name="mPattern" fulltype="java.text.MergeCollation" type="MergeCollation" />
			<field visibility="private" name="isOverIgnore" fulltype="boolean" type="boolean" />
			<field visibility="private" name="keyBuf" fulltype="char[]" type="char" />
			<field visibility="private" name="contractFlags" fulltype="sun.text.IntHashtable" type="IntHashtable" />
			<field visibility="private" name="frenchSec" fulltype="boolean" type="boolean" />
			<field visibility="private" name="seAsianSwapping" fulltype="boolean" type="boolean" />
			<field visibility="private" name="mapping" fulltype="sun.text.UCompactIntArray" type="UCompactIntArray" />
			<field visibility="private" name="contractTable" fulltype="java.util.Vector" type="Vector" />
			<field visibility="private" name="expandTable" fulltype="java.util.Vector" type="Vector" />
			<field visibility="private" name="maxSecOrder" fulltype="short" type="short" />
			<field visibility="private" name="maxTerOrder" fulltype="short" type="short" />
		</fields>
		<methods>
			<constructor visibility="public" name="RBTableBuilder">
				<params>
					<param name="tables" fulltype="java.text.RBCollationTables.BuildAPI" type="RBCollationTables.BuildAPI" />
				</params>
			</constructor>
			<method visibility="public" name="build" fulltype="void" type="void">
				<comment>
					<description>Create a table-based collation object with the given rules.
 This is the main function that actually builds the tables and
 stores them back in the RBCollationTables object.  It is called
 ONLY by the RBCollationTables constructor.</description>
					<attribute name="@see">
						<description>java.util.RuleBasedCollator#RuleBasedCollator</description>
					</attribute>
					<attribute name="@exception">
						<description>ParseException If the rules format is incorrect.</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" fulltype="java.lang.String" type="String" />
					<param name="decmp" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If the rules format is incorrect." fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
			<method visibility="private" name="addComposedChars" fulltype="void" type="void">
				<comment>
					<description>Add expanding entries for pre-composed unicode characters so that this
 collator can be used reasonably well with decomposition turned off.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
			<method final="true" visibility="private" name="commit" fulltype="void" type="void">
				<comment>
					<description>Look up for unmapped values in the expanded character table.

 When the expanding character tables are built by addExpandOrder,
 it doesn&apos;t know what the final ordering of each character
 in the expansion will be.  Instead, it just puts the raw character
 code into the table, adding CHARINDEX as a flag.  Now that we&apos;ve
 finished building the mapping table, we can go back and look up
 that character to see what its real collation order is and
 stick that into the expansion table.  That lets us avoid doing
 a two-stage lookup later.</description>
				</comment>
			</method>
			<method final="true" visibility="private" name="increment" fulltype="int" type="int">
				<comment>
					<description>Increment of the last order based on the comparison level.</description>
				</comment>
				<params>
					<param name="aStrength" fulltype="int" type="int" />
					<param name="lastValue" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="private" name="addOrder" fulltype="void" type="void">
				<comment>
					<description>Adds a character and its designated order into the collation table.</description>
				</comment>
				<params>
					<param name="ch" fulltype="int" type="int" />
					<param name="anOrder" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="private" name="addContractOrder" fulltype="void" type="void">
				<params>
					<param name="groupChars" fulltype="java.lang.String" type="String" />
					<param name="anOrder" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="private" name="addContractOrder" fulltype="void" type="void">
				<comment>
					<description>Adds the contracting string into the collation table.</description>
				</comment>
				<params>
					<param name="groupChars" fulltype="java.lang.String" type="String" />
					<param name="anOrder" fulltype="int" type="int" />
					<param name="fwd" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="private" name="getContractOrder" fulltype="int" type="int">
				<comment>
					<description>If the given string has been specified as a contracting string
 in this collation table, return its ordering.
 Otherwise return UNMAPPED.</description>
				</comment>
				<params>
					<param name="groupChars" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method final="true" visibility="private" name="getCharOrder" fulltype="int" type="int">
				<params>
					<param name="ch" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="getContractValues" fulltype="java.util.Vector" type="Vector">
				<comment>
					<description>Get the entry of hash table of the contracting string in the collation
  table.</description>
					<attribute name="@param">
						<description>ch the starting character of the contracting string</description>
					</attribute>
				</comment>
				<params>
					<param name="ch" comment="the starting character of the contracting string" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="getContractValuesImpl" fulltype="java.util.Vector" type="Vector">
				<params>
					<param name="index" fulltype="int" type="int" />
				</params>
			</method>
			<method final="true" visibility="private" name="addExpandOrder" fulltype="void" type="void">
				<comment>
					<description>Adds the expanding string into the collation table.</description>
				</comment>
				<params>
					<param name="contractChars" fulltype="java.lang.String" type="String" />
					<param name="expandChars" fulltype="java.lang.String" type="String" />
					<param name="anOrder" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
			<method final="true" visibility="private" name="addExpandOrder" fulltype="void" type="void">
				<params>
					<param name="ch" fulltype="int" type="int" />
					<param name="expandChars" fulltype="java.lang.String" type="String" />
					<param name="anOrder" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.text.ParseException" type="ParseException" />
				</exceptions>
			</method>
			<method visibility="private" name="addExpansion" fulltype="int" type="int">
				<comment>
					<description>Create a new entry in the expansion table that contains the orderings
 for the given characers.  If anOrder is valid, it is added to the
 beginning of the expanded list of orders.</description>
				</comment>
				<params>
					<param name="anOrder" fulltype="int" type="int" />
					<param name="expandChars" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="addContractFlags" fulltype="void" type="void">
				<params>
					<param name="chars" fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
</jel>
